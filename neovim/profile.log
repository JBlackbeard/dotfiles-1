SCRIPT  /home/spiros/.config/nvim/init.vim
Sourced 1 time
Total time:   0.549133
 Self time:   0.061815

count  total (s)   self (s)
                            " ######################################################################################################################
                            " ### Author : Spiros Kabasakalis <Kabasakalis@gmail.com>                                                            ###
                            " ######################################################################################################################
                            " ### Neovim Configuration                                                                                           ###
                            " ### Neovimmer since : Thu Apr 14 2016                                                                              ###                                                                             ###
                            " ######################################################################################################################
                            
                            
    1              0.000014 let home_path = $HOME
                            
                            "Plugins managed with vim-plug {{{
    1              0.000032 if filereadable(expand("~/.config/nvim/plugins.vim"))
    1              0.000033   source ~/.config/nvim/plugins.vim
    1              0.000002 endif
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Basic settings (Neovim defaults: https://neovim.io/doc/user/vim_diff.html#nvim-option-defaults) {{{
                            " ======================================================================================================================
                            "https://neovim.io/doc/user/provider.html#provider-python
    1              0.000004 let g:python_host_prog  = '/usr/bin/python2'
    1              0.000016 let g:python3_host_prog = expand("$HOME/.pyenv/shims/python3")
                            
                            " Virtual Python Environments
                            "https://github.com/zchee/deoplete-jedi/wiki/Setting-up-Python-for-Neovim
                            " let g:python_host_prog  = expand("SHOME/.pyenv/versions/neovim2/bin/python")
                            " let g:python3_host_prog = expand("$HOME/.pyenv/versions/neovim3/bin/python")
                            
                            " let g:loaded_python_provider = 1 "To disable Python 2 support:
                            " let g:loaded_python3_provider = 1 " To disable Python 3 support:
                            
    1              0.000010 let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 0
    1              0.000005 let $NVIM_TUI_ENABLE_TRUE_COLOR = 1
                            
    1              0.000402 filetype indent on                " Enable filetype-specific indenting
    1              0.000373 filetype plugin on                " Enable filetype-specific plugins
                            
    1              0.000004 let mapleader=" "                 " leader
    1   0.000017   0.000014 set nocompatible                  " choose no compatibility with legacy vi
    1   0.000007   0.000006 set hidden
    1   0.000021   0.000020 set runtimepath+=~/
    1   0.000012   0.000011 set tabstop=2
    1   0.000007   0.000007 set shiftwidth=2
    1   0.000007   0.000005 set expandtab
    1   0.000006   0.000005 set smartindent
    1   0.000006   0.000005 set autoindent
    1   0.000006   0.000005 set linebreak                     " And when Vim does wrap lines, have it break the lines on spaces and punctuation only (http://vim.wikia.com/wiki/Word_wrap_without_line_breaks)
    1   0.000013   0.000011 set textwidth=120                 " Make it obvious where 120(80) characters is
    1   0.000006   0.000006 set colorcolumn=+1
    1   0.000007   0.000005 set number
    1   0.000008   0.000007 set numberwidth=2
    1   0.000006   0.000005 set scrolloff=5                   " Screen scrolls 5 lines in front of the cursor
    1   0.000006   0.000005 set sidescrolloff=3
    1   0.000010   0.000006 set backspace=2                   " Backspace deletes like most programs in insert mode
    1   0.000006   0.000005 set nobackup
    1   0.000008   0.000007 set nowritebackup
    1   0.000007   0.000006 set noswapfile                    "New buffers will be loaded without creating a swapfile  http://robots.thoughtbot.com/post/18739402579/global-gitignore#comment-458413287
    1   0.000007   0.000006 set history=1000
    1   0.000006   0.000005 set ruler                         " show the cursor position all the time
    1   0.000006   0.000005 set showcmd                       " display incomplete commands
    1   0.000006   0.000006 set laststatus=2                  " Always display the status line
    1   0.000006   0.000005 set autowrite                     " Automatically :write before running commands
                            "set cursorline                   " Highlight current line
    1   0.000007   0.000006 set clipboard+=unnamed            " Allow to use system clipboard
    1   0.000006   0.000006 set showmatch                     " Show matching brackets when text indicator is over them
    1   0.000006   0.000005 set matchtime=2                   " How many tenths of a second to blink when matching brackets
    1   0.000006   0.000006 set nostartofline                 " Prevent cursor from moving to beginning of line when switching buffers
    1   0.000006   0.000005 set virtualedit=block             " To be able to select past EOL in visual block mode
    1   0.000007   0.000006 set updatetime=1000               " Update time used to create swap file or other things
    1   0.000011   0.000010 set nojoinspaces                  " No extra space when joining a line which ends with . ? !
    1   0.000007   0.000006 set splitbelow                    " Open new split panes to right and bottom, which feels more natural
    1   0.000006   0.000005 set splitright
    1   0.000016   0.000015 set mouse-=a                      " disable mouse support, what am I a vimposer?
    1   0.000009   0.000008 set complete+=kspell              " Autocomplete with dictionary words when spell check is on
    1   0.000009   0.000008 set diffopt+=vertical             " Always use vertical diffs
    1   0.000006   0.000005 set wildmenu                      " turn on the wildmenu cuz everyone says to
    1   0.000006   0.000005 set autoread                      " have vim re-load files when they're changed outside of vim
    1   0.000007   0.000006 set formatoptions+=j              " Delete comment charalter when joining commented lines
    1   0.000010   0.000009 set sc                            " show commands as you type them
    1   0.000006   0.000005 set lazyredraw                    " make vim a little speedier
    1   0.000006   0.000005 set ttyfast
                            " Save temporary/backup files not in the local directory, but in your ~/.vim
                            " directory, to keep them out of git repos.
                            " Pretty sure you need to mkdir backup, swap, and undo first to make this work
    1   0.000007   0.000005 set backupdir=~/.config/nvim/backup//
    1   0.000006   0.000005 set directory=~/.config/nvim/swap//
    1   0.000005   0.000005 set undodir=~/.config/nvim/undo//
                            
    1   0.000005   0.000004 set tags=./tags;                  " Set the tag file search order
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Color and highlighting settings {{{
                            " ======================================================================================================================
                            
                            " Available themes:
                            " jellybeans
                            " lucid
                            " railscasts
                            " Tomorrow-Night
                            " seoul256
                            " tropikos
                            " gotham256
                            " Color scheme based on time
                            " Turn syntax highlighting on
                            " Switch syntax highlighting on, when the terminal has colors
                            " Also switch on highlighting the last used search pattern.
                            
                            " if (has("termguicolors"))
                            "   set termguicolors
                            " endif
                            
    1              0.000008 if (&t_Co > 2 || has("gui_running")) && !exists("syntax_on")
                              " Turn syntax highlighting on
                              syntax on
                              " start highlighting from 256 lines backwards
                              syntax sync minlines=256
                            endif
                            
    1              0.000003 let g:rehash256=1
                            " Theme
    1              0.000040 colorscheme  Tomorrow-Night
                            "transparency
    1              0.000739 hi Normal  ctermfg=252 ctermbg=none
                            
                            " Highlight VCS conflict markers
    1              0.000037 match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'
                            
                            "" Error highlight
    1              0.000044 highlight	Error ctermfg=red ctermbg=blue guifg=red ctermbg=NONE
                            
                            "" Spell highligh"" Spell highlightt
    1              0.000035 highlight SpellBad ctermfg=red ctermbg=black guifg=red ctermbg=NONE
                            
                            " Highlight term cursor differently
    1              0.000030 highlight TermCursor ctermfg=green guifg=green
                            
                            " Listchars highlighting
    1              0.000023 highlight NonText ctermfg=235 guifg=gray
    1              0.000028 highlight SpecialKey ctermfg=235 guifg=gray
                            
                            " Remove underline in folded lines
    1              0.000020 hi! Folded term=NONE cterm=NONE gui=NONE ctermbg=NONE
                            
                            " LineNumber Gutter background color
    1              0.000019 highlight LineNr ctermfg=NONE ctermbg=NONE
                            
                            " SignColumn (Git Gutter)
    1              0.000019 highlight SignColumn ctermfg=NONE ctermbg=NONE
                            
                            " Link highlight groups to improve buftabline colors
    1              0.000029 hi! link BufTabLineCurrent Identifier
    1              0.000028 hi! link BufTabLineActive Comment
    1              0.000028 hi! link BufTabLineHidden Comment
    1              0.000028 hi! link BufTabLineFill Comment
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Search settings {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1   0.000016   0.000013 set ignorecase                    " Ignore case by default
    1   0.000010   0.000009 set smartcase                     " Make search case sensitive only if it contains uppercase letters
    1   0.000010   0.000008 set wrapscan                      " Search again from top when reached the bottom
    1   0.000009   0.000008 set nohlsearch                    " Don't highlight after search
    1   0.000008   0.000007 set incsearch                     " incremental searching
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Persistent undo settings {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000008 if has('persistent_undo')
    1   0.050661   0.050654   set undofile
    1   0.000026   0.000024   set undodir=~/.config/nvim/undo//
    1              0.000003 endif
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Timeout settings {{{
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Time out on key codes but not mappings. Basically this makes terminal Vim work sanely. (by Steve Losh)
    1   0.000010   0.000009 set notimeout
    1   0.000009   0.000008 set ttimeout
    1   0.000014   0.000012 set ttimeoutlen=10
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Folding settings {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1   0.000012   0.000011 set foldmethod=marker             " Markers are used to specify folds.
    1   0.000412   0.000410 set foldlevel=2                   " Start folding automatically from level 2
    1   0.000010   0.000008 set fillchars="fold: "            " Characters to fill the statuslines and vertical separators
                            " set foldenable                  " folding
                            " set foldlevelstart=10
                            " set foldnestmax=10
                            " set foldmethod=indent
                            " set nowrap
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " White characters settings {{{
                            " ---------------------------------------------------------------------------------------------------------------------
                            "set list                         " Show listchars by default
    1   0.000017   0.000016 set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮,trail:·,nbsp:·
                            "set showbreak=↪
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Spelling settings {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1   0.000012   0.000011 set spellfile=~/.config/nvim/dictionary.utf-8.add
    1   0.000708   0.000707 set spelllang=en_us               " Set language to US English
    1   0.000011   0.000010 set nospell                       " Disable checking by default (use <F4> to toggle)
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Omni completion settings {{{
                            " ---------------------------------------------------------------------------------------------------------------------
                            " set completeopt-=preview          " Don't show preview scratch buffers
                            " set wildignore=*.o,*.obj,*~
                            " " set wildignore+=*.png,*.jpg,*.jpeg
                            " set wildignore+=*vim/backups*
                            " set wildignore+=*sass-cache*
                            " set wildignore+=*DS_Store*
                            " set wildignore+=*.gem
                            " set wildignore+=tmp/**
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Neovim specific configuration {{{
                            " ======================================================================================================================
    1              0.000022 if has("nvim")
                              " change cursor to bar in insert mode
                              "let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
                              " run tests with :T
    1              0.000008   let test#strategy = "neoterm"
                              " ======================================================================================================================
                              " Neoterm
                              " ======================================================================================================================
    1              0.000005   let g:neoterm_position = 'horizontal'
    1              0.000004   let g:neoterm_automap_keys = ',tt'
    1              0.000004   let g:neoterm_size = '10'
    1              0.000004   let g:neoterm_keep_term_open = 1
                              "let g:neoterm_run_tests_bg = 1
                              "let g:neoterm_raise_when_tests_fail = 1
                              " pretty much essential: by default in terminal mode, you have to press ctrl-\-n to get into normal mode
                              " ain't nobody got time for that
    1              0.000060   :tnoremap <Esc> <C-\><C-n>
                              " optional: make it easier to switch between terminal splits
                              " ctrl doesn't work for some reason so I use alt
                              " I think the terminal is capturing ctrl and not bubbling to vim or something
    1              0.000018   tnoremap <C-h> <C-\><C-n><C-w>h
    1              0.000018   tnoremap <C-j> <C-\><C-n><C-w>j
    1              0.000018   tnoremap <C-k> <C-\><C-n><C-w>k
    1              0.000016   tnoremap <C-l> <C-\><C-n><C-w>l
                              " run set test lib
                              " nnoremap <silent> ,rt :call neoterm#test#run('all')<cr>
                              " nnoremap <silent> ,rf :call neoterm#test#run('file')<cr>
                              " nnoremap <silent> ,rn :call neoterm#test#run('current')<cr>
                              " nnoremap <silent> ,rr :call neoterm#test#rerun()<cr>
                              " Useful maps
                              " hide/close terminal
    1              0.000040   nnoremap <silent> ,th :call neoterm#close()<cr>
                              " clear terminal
    1              0.000025   nnoremap <silent> ,tl :call neoterm#clear()<cr>
                              " kills the current job (send a <c-c>)
    1              0.000024   nnoremap <silent> ,tc :call neoterm#kill()<cr>
                              " Rails commands
    1              0.000017   command! Troutes :T rake routes
    1              0.000016   command! -nargs=+ Troute :T rake routes | grep <args>
    1              0.000009   command! Tmigrate :T rake db:migrate
                              " Git commands
    1              0.000011   command! -nargs=+ Tg :T git <args>
    1              0.000002 endif
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Core key bindings-Remappings {{{
                            " ======================================================================================================================
                            
                            " Save file
    1              0.000026 nnoremap <Leader>s :w<CR>
                            
                            " Quiting and saving all
    1              0.000016 cnoremap ww wqall
    1              0.000017 cnoremap qq qall
    1              0.000017 cnoremap <ESC><ESC> qall!<CR>
                            
                            
                            " Quicker window movement
    1              0.000028 nmap <silent> <C-w><C-w> :call utils#intelligentCycling()<CR>
                            " up and down have been  mapped to tmux window navigation
                            " nnoremap <C-j> <C-w>j
                            " nnoremap <C-k> <C-w>k
    1              0.000021 nnoremap <C-h> <C-w>h
    1              0.000019 nnoremap <C-l> <C-w>l
                            
                            
                            " Intelligent windows resizing using ctrl + arrow keys
                            " Easier for Poker 3.
    1              0.000030 nnoremap <silent> <Right> :call utils#intelligentVerticalResize('right')<CR>
    1              0.000029 nnoremap <silent> <Left> :call utils#intelligentVerticalResize('left')<CR>
    1              0.000024 nnoremap <silent> <Up> :resize +1<CR>
    1              0.000023 nnoremap <silent> <Down> :resize -1<CR>
                            
                            " nnoremap <silent> <C-Right> :call utils#intelligentVerticalResize('right')<CR>
                            " nnoremap <silent> <C-Left> :call utils#intelligentVerticalResize('left')<CR>
                            " nnoremap <silent> <C-Up> :resize +1<CR>
                            " nnoremap <silent> <C-Down> :resize -1<CR>
                            
    1              0.000022 nnoremap <silent> ,r zR
                            
                            " Switch between the last two files
    1              0.000027 nnoremap <leader><leader> <c-^>
                            
                            " Toggle between normal and relative numbering.
    1              0.000027 nnoremap <leader>\ :call utils#NumberToggle()<cr>
                            
                            " Buffers navigation and management
    1              0.000025 nnoremap <leader>] :bn<CR>
    1              0.000024 nnoremap <leader>[  :bp<CR>
                            "Close buffer workaround
    1              0.000023 map <C-x> :bn<cr>:bd #<cr>:bp<cr>
                            
                            "Close all buffers
                            "map <C-c> :bufdo bd<cr>
                            
                            "Delete Current File
    1              0.000031 nnoremap <leader>rm :call delete(expand('%')) \| bdelete!<CR>
                            
                            " Quickly open a vertical split of my init.vim and source my init.vim
    1              0.000029 nnoremap <silent> <leader>ev :vs ~/.config/nvim/init.vim<CR>
                            " Reload init.vim
                            "nnoremap <silent> <leader>sv :so ~/.config/nvim/init.vim<CR>
                            
                            " H to beginning of line, L to the end
    1              0.000019 noremap H ^
    1              0.000018 noremap L $
                            
                            " D deletes to the end of the line, and Y yanks to end of line
    1              0.000018 nnoremap D d$
    1              0.000018 nnoremap Y y$
                            
                            " place whole file on the system clipboard (and return cursor to where it was)
    1              0.000025 nmap <Leader>a maggVG"*y`a
                            
                            " Select all contents of file
    1              0.000025 nmap <Leader>v <esc>ggVG<CR>
                            
                            " After block yank and paste, move cursor to the end of operated text and don't override register
    1              0.000020 vnoremap y y`]
    1              0.000019 vnoremap p "_dP`]
    1              0.000019 nnoremap p p`]
                            
                            " Yank and paste from clipboard
    1              0.000025 nnoremap <leader>y "+y
    1              0.000024 vnoremap <leader>y "+y
    1              0.000025 nnoremap <leader>yy "+yy
    1              0.000024 nnoremap <leader>p "+p
                            
                            " have x (removes single character) not go into the default registry
    1              0.000019 nnoremap x "_x
                            " Make X an operator that removes without placing text in the default registry
    1              0.000018 nmap X "_d
    1              0.000022 nmap XX "_dd
    1              0.000018 vmap X "_d
    1              0.000018 vmap x "_d
                            
                            " Don't yank to default register when changing something
    1              0.000019 nnoremap c "xc
    1              0.000018 xnoremap c "xc
                            
                            " Reselect last-pasted text
    1              0.000022 nnoremap gp `[v`]
                            
                            " Move visual block
    1              0.000020 vnoremap J :m '>+1<CR>gv=gv
    1              0.000019 vnoremap K :m '<-2<CR>gv=gv
                            
                            " Fix the cw at the end of line bug default Vim has special treatment (:help cw)
    1              0.000022 nmap cw ce
    1              0.000023 nmap dw de
                            
                            " Quick-fix window navigation
    1              0.000023 nnoremap ]q :cnext<CR>
    1              0.000023 nnoremap [q :cprevious<CR>
                            
                            " Location list navigation
    1              0.000022 nnoremap ]l :lnext<CR>
    1              0.000023 nnoremap [l :lprevious<CR>
                            
                            " Error mnemonic (Neomake uses location list)
    1              0.000022 nnoremap ]e :lnext<CR>
    1              0.000024 nnoremap [e :lprevious<CR>
                            
                            " CTags generation / navigation (:tselect to select from menu)
    1              0.000022 nnoremap ]t :tn<CR>
    1              0.000022 nnoremap [t :tp<CR>
    1              0.000022 nnoremap ,ts :ts<CR>
                            "nnoremap ,tg :GenerateTags<CR>
                            
                            " Keep the cursor in place while joining lines
    1              0.000019 nnoremap J mzJ`z
                            " [S]plit line (sister to [J]oin lines) S is covered by cc.
    1              0.000026 nnoremap <leader>c mzi<CR><ESC>`z
                            
                            
                            " Start substitute,replace on current word under the cursor
    1              0.000025 nnoremap ,s :%s///gc<Left><Left><Left>
                            
                            " Start search on current word under the cursor
    1              0.000022 nnoremap ,/ /<CR>
                            
                            " Start reverse search on current word under the cursor
    1              0.000023 nnoremap ,? ?<CR>
                            
                            " Faster sort
    1              0.000022 vnoremap ,s :!sort<CR>
                            
                            " Easier fold toggling
                            " Toggle
    1              0.000022 nnoremap <silent> ,n za
                            " Close all
    1              0.000021 nnoremap <silent> ,m zM
                            " Open  all
    1              0.000021 nnoremap <silent> ,r zR
                            
                            " Enter gives a new line when in command mode without entering insert mode. Likewise, shift+enter gives a new line
                            " above the cursor
    1              0.000021 nmap <CR> o<Esc>
    1              0.000023 nnoremap <S-Enter> O<Esc>
                            
                            " Have the indent commands re-highlight the last visual selection to make
                            " multiple indentations easier
    1              0.000019 vnoremap > >gv
    1              0.000018 vnoremap < <gv
                            
                            " Make the dot command work as expected in visual mode (via
                            " https://www.reddit.com/r/vim/comments/3y2mgt/do_you_have_any_minor_customizationsmappings_that/cya0x04)
    1              0.000040 vnoremap . :norm.<CR>
                            
                            " Center screen when jumping to next match
    1              0.000020 nnoremap n nzz
    1              0.000018 nnoremap N Nzz
    1              0.000019 vnoremap n nzz
    1              0.000020 vnoremap N Nzz
                            
                            " Center screen when moving up and down
    1              0.000020 nnoremap <C-u> <C-u>zz
    1              0.000020 nnoremap <C-o> <C-o>zz
    1              0.000020 vnoremap <C-u> <C-u>zz
    1              0.000019 vnoremap <C-o> <C-o>zz
                            
                            " Use CamelCaseMotion instead of default motions
    1              0.000023 map <silent> w <Plug>CamelCaseMotion_w
    1              0.000022 map <silent> b <Plug>CamelCaseMotion_b
    1              0.000022 map <silent> e <Plug>CamelCaseMotion_e
    1              0.000027 map <silent> ge <Plug>CamelCaseMotion_ge
    1              0.000018 sunmap w
    1              0.000017 sunmap b
    1              0.000017 sunmap e
    1              0.000018 sunmap ge
                            
                            
                            " vim-test mappings
    1              0.000028 map <silent> <leader>f :TestFile<CR>
    1              0.000028 map <silent> <leader>T :TestSuite<CR>
    1              0.000027 map <silent> <leader>t :TestNearest<CR>
    1              0.000027 map <silent> <leader>. :TestLast<CR>
                            "map <silent> <leader>g :TestVisit<CR>
                            
                            " allows you to visually select a section and then hit @ to run a macro on all lines
                            " https://medium.com/@schtoeffel/you-don-t-need-more-than-one-cursor-in-vim-2c44117d51db#.3dcn9prw6
    1              0.000023 xnoremap @ :<C-u>call utils#ExecuteMacroOverVisualRange()<CR>
                            
                            "" Turn off recording
    1              0.000018 map q <Nop>
                            
                            " For conceal markers.
    1              0.000006 if has('conceal')
    1   0.000020   0.000017   set conceallevel=2 concealcursor=niv
    1              0.000003 endif
                            "}}}
                            
                            " -----------------------------------------------------
                            " vim-tmux-navigator {{{
                            " -----------------------------------------------------
                            "" also see settings in tmux.conf Alternatives for next/previous windows.
                            "" tmux left right window navigation
                            
    1              0.000006 let g:tmux_navigator_no_mappings = 1
    1              0.000024 nnoremap <silent> <C-j> :TmuxNavigateLeft<cr>
    1              0.000021 nnoremap <silent> <C-k> :TmuxNavigateRight<cr>
                            
                            "}}}
                            
                            " -----------------------------------------------------
                            " CtrlP Config {{{
                            " -----------------------------------------------------
                            "Disable/Enable
                            " let g:loaded_ctrlp = 1
    1              0.000006 let g:ctrlp_dont_split = 'nerdtree'
    1              0.000004 let g:ctrlp_dont_split = 'startify'
                            " Setup some default ignores
    1              0.000014 let g:ctrlp_custom_ignore = {
                              \ 'dir':  '\v[\/](\.(git|hg|svn)|\_site)$',
                              \ 'file': '\v\.(exe|so|dll|class|png|jpg|jpeg)$',
                            \}
                            " Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
    1              0.000042 if executable('ag')
                              " Use Ag over Grep
    1   0.000011   0.000010   set grepprg=ag\ --nogroup\ --nocolor
                              " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
    1              0.000006   let g:ctrlp_user_command = 'ag -Q -l --nocolor --hidden -g "" %s'
                              " ag is fast enough that CtrlP doesn't need to cache
    1              0.000004   let g:ctrlp_use_caching = 0
    1              0.000002 endif
    1              0.000032 nnoremap <Leader>o :CtrlP<CR>                 " Open file menu
    1              0.000030 nnoremap <Leader>b :CtrlPBuffer<CR>           " Open buffer menu
    1              0.000031 nnoremap <Leader>u :CtrlPMRUFiles<CR>         " Open most recently used files
    1              0.000028 nnoremap <Leader>m :CtrlPMixed<CR>            " Open Mixed
                            "}}}
                            
                            " -----------------------------------------------------
                            " Startify Config {{{
                            " -----------------------------------------------------
                            "autocmd User Startified setlocal cursorline
    1              0.000028 autocmd User Startified setlocal buftype=
                            " let g:startify_disable_at_vimenter    = 0
    1              0.000006 let g:startify_enable_special         = 0
    1              0.000004 let g:startify_files_number           = 8
    1              0.000004 let g:startify_relative_path          = 1
    1              0.000004 let g:startify_change_to_dir          = 1
    1              0.000004 let g:startify_update_oldfiles        = 1
    1              0.000004 let g:startify_session_autoload       = 1
    1              0.000004 let g:startify_session_persistence    = 1
    1              0.000004 let g:startify_session_delete_buffers = 1
                            
    1              0.000013 let g:startify_skiplist = [
                                        \ 'COMMIT_EDITMSG',
                                        \ 'bundle/.*/doc',
                                        \ '/data/repo/neovim/runtime/doc',
                                        \ '/Users/mhi/local/vim/share/vim/vim74/doc',
                                        \ ]
                            
    1              0.000041 let g:startify_bookmarks = [
                                        \ { 'c': '~/dotfiles/neovim/init.vim' },
                                        \ { 'd': '~/dotfiles/neovim/plugins.vim'},
                                        \ { 'e': '~/dotfiles/neovim/autoload/utils.vim'},
                                        \ { 'f': '~/dotfiles/zsh/zshrc'},
                                        \ { 'g': '~/dotfiles/zsh/zshenv'},
                                        \ { 'h': '~/dotfiles/zsh/zsh_aliases'},
                                        \ { 'i': '~/dotfiles/install.conf.yaml'}
                                        \ ]
                            
    1              0.000016 let g:startify_list_order = [
                                        \ ['   Recent'],
                                        \ 'files',
                                        \ ['   Recent in current'],
                                        \ 'dir',
                                        \ ['   Sessions:'],
                                        \ 'sessions',
                                        \ ['   Bookmarks:'],
                                        \ 'bookmarks',
                                        \ ['   Commands:'],
                                        \ 'commands',
                                        \ ]
                            
                            
    1              0.000011 let g:startify_commands = [
                                \ ['Vim Reference', 'h ref']
                                \ ]
                            
                            
                            " let g:sk = ['Spiros Kabasakalis NeoVim']                                                                                                         ]
                            
                            " let g:startify_custom_header = g:sk
                            
    1              0.000007 let g:startify_custom_header = [' ',' ', '   Spiros Kabasakalis', '   Custom NeoVim Setup']
                            
                            
    1              0.000008 let g:startify_custom_footer =
                                  \ ['', "   Neither the past, the present nor the future mind can be found", '']
                            
    1              0.000068 hi StartifyBracket ctermfg=240
    1              0.000017 hi StartifyFile    ctermfg=147
    1              0.000016 hi StartifyFooter  ctermfg=240
    1              0.000016 hi StartifyHeader  ctermfg=114
    1              0.000016 hi StartifyNumber  ctermfg=215
    1              0.000016 hi StartifyPath    ctermfg=245
    1              0.000016 hi StartifySlash   ctermfg=240
    1              0.000016 hi StartifySpecial ctermfg=240
                            
    1              0.000005 let NERDTreeHijackNetrw = 0
    1              0.000005 let g:startify_session_dir = '~/.config/nvim/sessions'
    1              0.000008 let g:startify_session_before_save = [
                                    \ 'echo "Cleaning up before saving.."',
                                    \ 'silent! NERDTreeTabsClose'
                                    \ ]
                            
    1              0.000026 nnoremap <silent> ,z :Startify<CR>
                            "}}}
                            " -----------------------------------------------------
                            " tree Config {{{
                            " -----------------------------------------------------
    1              0.000008 autocmd StdinReadPre * let s:std_in=1
                            " autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
                            "autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
    1              0.000015 autocmd VimEnter *
                                        \   if !argc()
                                        \ |   Startify
                                        \ |   NERDTree
                                        \ |   wincmd w
                                        \ | endif
    1              0.000005 let g:NERDTreeMinimalUI=1
    1              0.000003 let g:NERDTreeWinSize=50
    1              0.000004 let g:NERDTreeAutoDeleteBuffer=1
    1              0.000003 let g:NERDTreeShowHidden=1
    1              0.000004 let g:NERDTreeHighlightCursorline=0
    1              0.000004 let g:NERDTreeRespectWildIgnore=1
    1              0.000004 let g:NERDTreeMapActivateNode='<right>'
                            " NERDTree File highlighting
    1              0.000009 function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)
                            exec 'autocmd FileType nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
                            exec 'autocmd FileType nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'
                            endfunction
    1   0.000076   0.000026 call NERDTreeHighlightFile('jade', 'green', 'none', 'green', '#151515')
    1   0.000045   0.000011 call NERDTreeHighlightFile('haml', 'green', 'none', 'green', '#151515')
    1   0.000044   0.000011 call NERDTreeHighlightFile('ini', 'yellow', 'none', 'yellow', '#151515')
    1   0.000042   0.000010 call NERDTreeHighlightFile('md', 'blue', 'none', '#3366FF', '#151515')
    1   0.000049   0.000011 call NERDTreeHighlightFile('yml', 'yellow', 'none', 'yellow', '#151515')
    1   0.000044   0.000011 call NERDTreeHighlightFile('config', 'yellow', 'none', 'yellow', '#151515')
    1   0.000045   0.000010 call NERDTreeHighlightFile('conf', 'yellow', 'none', 'yellow', '#151515')
    1   0.000043   0.000010 call NERDTreeHighlightFile('json', 'yellow', 'none', 'yellow', '#151515')
    1   0.000047   0.000010 call NERDTreeHighlightFile('html', 'yellow', 'none', 'yellow', '#151515')
    1   0.000045   0.000012 call NERDTreeHighlightFile('styl', 'cyan', 'none', 'cyan', '#151515')
    1   0.000048   0.000010 call NERDTreeHighlightFile('css', 'cyan', 'none', 'cyan', '#151515')
    1   0.000042   0.000010 call NERDTreeHighlightFile('scss', 'cyan', 'none', 'cyan', '#151515')
    1   0.000046   0.000010 call NERDTreeHighlightFile('coffee', 'Red', 'none', 'red', '#151515')
    1   0.000043   0.000010 call NERDTreeHighlightFile('rb', 'Cyan', 'none', 'red', '#151515')
    1   0.000046   0.000010 call NERDTreeHighlightFile('png', 'Cyan', 'none', 'red', '#151515')
    1   0.000043   0.000010 call NERDTreeHighlightFile('jpg', 'Cyan', 'none', 'red', '#151515')
    1   0.000045   0.000012 call NERDTreeHighlightFile('js', 'Red', 'none', '#ffa500', '#151515')
    1   0.000050   0.000016 call NERDTreeHighlightFile('php', 'Magenta', 'none', '#ff00ff', '#151515')
    1   0.000045   0.000010 call NERDTreeHighlightFile('ds_store', 'Gray', 'none', '#686868', '#151515')
    1   0.000046   0.000011 call NERDTreeHighlightFile('gitconfig', 'Gray', 'none', '#686868', '#151515')
    1   0.000045   0.000011 call NERDTreeHighlightFile('gitignore', 'Gray', 'none', '#686868', '#151515')
    1   0.000046   0.000010 call NERDTreeHighlightFile('zshrc', 'Gray', 'none', '#686868', '#151515')
    1   0.000045   0.000011 call NERDTreeHighlightFile('bashprofile', 'Gray', 'none', '#686868', '#151515')
                            
    1              0.000008 autocmd filetype nerdtree syn match haskell_icon ## containedin=NERDTreeFile
                            " if you are using another syn highlight for a given line (e.g.
                            " NERDTreeHighlightFile) need to give that name in the 'containedin' for this
                            " other highlight to work with it
    1              0.000007 autocmd filetype nerdtree syn match html_icon ## containedin=NERDTreeFile,html
    1              0.000007 autocmd filetype nerdtree syn match go_icon ## containedin=NERDTreeFile
                            
                            " nnoremap <silent> <Leader>h :call utils#nerdWrapper()<CR>
    1              0.000030 nnoremap <silent> <Leader>h :NERDTreeToggle<CR>
                            
                            " map <Leader>n :NERDTreeToggle<CR>
                            
                            "}}}
                            
                            
                            "  -------------------------------------------
                            "  w0rp/ale, Asynchronous maker and linter {{{
                            " https://github.com/w0rp/ale/blob/master/doc/ale.txt
                            " ----------------------------------------------------
    1              0.000005 let g:ale_enabled = 1
    1              0.000004 let g:ale_sign_column_always = 1
    1              0.000004 let g:ale_sign_error = '>>'
    1              0.000004 let g:ale_sign_warning = '--'
                            " highlight clear ALEErrorSign
                            " highlight clear ALEWarningSign
    1              0.000004 let g:airline#extensions#ale#enabled = 1
    1              0.000004 let g:ale_echo_msg_error_str = 'E'
    1              0.000004 let g:ale_echo_msg_warning_str = 'W'
    1              0.000004 let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
                            
                            " Don't run linters on changing text or opening a file.
                            " So effectively linters run only on file saved.
    1              0.000004 let g:ale_lint_on_text_changed = 'never'
    1              0.000004 let g:ale_lint_on_enter = 0
                            
    1              0.000005 let g:ale_completion_enabled = 0
                            " let g:ale_set_loclist = 0
                            " let g:ale_set_quickfix = 1
                            "}}}
                            
                            
                            " -----------------------------------------------------
                            " Sneak, s f https://github.com/justinmk/vim-sneak {{{
                            " -----------------------------------------------------
    1              0.000023 nmap f <Plug>Sneak_s
    1              0.000021 nmap F <Plug>Sneak_S
    1              0.000021 xmap f <Plug>Sneak_s
    1              0.000020 xmap F <Plug>Sneak_S
    1              0.000019 omap f <Plug>Sneak_s
    1              0.000019 omap F <Plug>Sneak_S
                            "}}}
                            
                            " -----------------------------------------------------
                            " Easy Motion {{{
                            " -----------------------------------------------------
    1              0.000005 let g:EasyMotion_do_mapping = 0 " Disable default mappings
    1              0.000004 let g:EasyMotion_smartcase = 1 " Turn on case insensitive feature
                            " Jump to anywhere you want with minimal keystrokes, with just one key binding.
                            " `m{char}{label}`
                            "nmap m <Plug>(tion-overwin-f)
                            " or
                            " `m{char}{char}{label}`
                            " Need one more keystroke, but on average, it may be more comfortable.
    1              0.000024 nmap s <Plug>(easymotion-overwin-f2)
                            
                            " JK motions: Line motions
    1              0.000030 map <Leader>j <Plug>(easymotion-j)
    1              0.000031 map <Leader>k <Plug>(easymotion-k)
                            
                            " Move to line
    1              0.000030 map <Leader>l <Plug>(easymotion-bd-jk)
    1              0.000029 nmap <Leader>l <Plug>(easymotion-overwin-line)
                            
                            " Move to word
    1              0.000030 map  <Leader>w <Plug>(easymotion-bd-w)
    1              0.000028 nmap <Leader>w <Plug>(easymotion-overwin-w)
                            "}}}
                            
                            " -----------------------------------------------------
                            " Clever F settings {{{
                            " -----------------------------------------------------
    1              0.000005 let g:clever_f_across_no_line=1
    1              0.000004 let g:clever_f_smart_case=1
    1              0.000004 let g:clever_f_show_prompt=1
    1              0.000004 let g:clever_f_chars_match_any_signs=';'
                            "}}}
                            
                            " -----------------------------------------------------
                            " Gitgutter {{{
                            " -----------------------------------------------------
    1              0.000004 let g:gitgutter_map_keys=0
    1              0.000004 let g:gitgutter_max_signs=9999
    1              0.000004 let g:gitgutter_sign_added='+'
    1              0.000004 let g:gitgutter_sign_modified='~'
    1              0.000004 let g:gitgutter_sign_removed='-'
    1              0.000004 let g:gitgutter_sign_modified_removed='~'
    1              0.000004 let g:gitgutter_sign_removed_first_line='-'
    1              0.000004 let g:gitgutter_override_sign_column_highlight = 0
    1   0.000013   0.000010 set signcolumn=yes
                            
    1              0.000022 highlight GitGutterAdd ctermfg=green ctermbg=NONE
    1              0.000018 highlight GitGutterChange ctermfg=yellow ctermbg=NONE
    1              0.000017 highlight GitGutterDelete ctermfg=red ctermbg=NONE
    1              0.000018 highlight GitGutterChangeDelete ctermfg=magenta ctermbg=NONE
                            "}}}
                            
                            " -----------------------------------------------------
                            " Airline {{{
                            " -----------------------------------------------------
    1              0.000005 let g:airline_powerline_fonts = 1
    1              0.000004 let g:airline_theme = 'powerlineish'
                            " Enable the list of ers
    1              0.000004 let g:airline#extensions#tabline#enabled = 1
                            " Show just the filename
    1              0.000005 let g:airline#extensions#tabline#fnamemod = ':t'
    1              0.000004 let g:airline_exclude_preview = 1
                            "}}}
                            
                            " -----------------------------------------------------
                            " Dev Icons {{{
                            " -----------------------------------------------------
    1              0.000003 let g:webdevicons_enable = 1
    1              0.000004 let g:webdevicons_enable_nerdtree = 1
    1              0.000004 let g:webdevicons_enable_airline_tabline = 1
    1              0.000004 let g:webdevicons_enable_airline_statusline = 1
                            " let g:webdevicons_enable_ctrlp = 1
    1              0.000007 if exists("g:loaded_webdevicons")
    1   0.078921   0.000020     call webdevicons#refresh()
    1              0.000003 endif
                            "}}}
                            
                            
                            " -----------------------------------------------------
                            " Pasta  Pasting in Vim with indentation adjusted to destination context.{{{
                            " -----------------------------------------------------
    1              0.000004 let g:pasta_paste_before_mapping = ',O'
    1              0.000003 let g:pasta_paste_after_mapping = ',o'
                            "}}}
                            
                            
                            " -----------------------------------------------------
                            " Completion  roxma/nvim-completion-manager {{{
                            " -----------------------------------------------------
    1              0.000003 let g:cm_smart_enable=1  "disable ncm
    1              0.000002 let g:cm_auto_popup = 0 "disable automatic popup
                            
                            "manually trigger autocompletion
    1              0.000047 imap <silent> <Tab> <Plug>(cm_force_refresh)
                            " imap <silent> <Tab> <c-r>=ManualCompletionTab()<cr>
                            
                            " Next two lines make it possible to expand a snippet (See Ultisnips config) from the pop up menu using ENTER
    1              0.000019 inoremap <silent> <expr> <CR>  (pumvisible() ?  "\<c-y>\<Plug>(expand_or_nl)" : "\<CR>")
    1              0.000019 inoremap <silent> <expr> <Plug>(expand_or_nl) (cm#completed_is_snippet() ? "\<C-t>" : "\<CR>")
                            
                            " override builtin completions
                            " let g:cm_sources_enable = 0
                            " let g:cm_sources_override = {
                            " \ 'cm-tags': {'enable':0}
                            " \ }
                            "
                            " increase for fast typing performance
                            " let g:cm_complete_start_delay = 0
                            " increase to minimize flickering of pop up menu
                            " let g:cm_complete_popup_delay = 50
                            
                            "}}}
                            "
                            
                            " -----------------------------------------------------
                            " Deoplete autocomplete {{{
                            " -----------------------------------------------------
    1              0.000004 let g:deoplete#enable_at_startup = 0 "stupid deoplete is super buggy, lags like crazy in INSERT MODE. Stupid Jap.
    1              0.000003 let g:deoplete#auto_completion_start_length = 1
    1              0.000003 let g:deoplete#enable_smart_case = 1
                            
                            " g:deoplete#disable_auto_complete = 1
                            
    1   0.000011   0.000009 set completeopt+=noinsert
    1   0.000007   0.000006 set completeopt-=preview
                            
    1              0.000005 let g:deoplete#omni#input_patterns={}
    1              0.000004 let g:deoplete#sources={}
                            
                            " let g:deoplete#sources._    = ['buffer', 'file', 'ultisnips']
                            " let g:deoplete#sources.vim  = ['buffer', 'member', 'file', 'ultisnips']
                            " let g:deoplete#sources.css  = ['buffer', 'member', 'file', 'omni', 'ultisnips']
                            " let g:deoplete#sources.scss = ['buffer', 'member', 'file', 'omni', 'ultisnips']
                            
                            " Insert <TAB> or select next match inoremap <silent> <expr> <Tab> utils#tabComplete() Manually trigger tag autocomplete
                            " inoremap <silent> <expr> <C-]> utils#manualTagComplete()
                            " " <C-h>, <BS>: close popup and delete backword char
                            " inoremap <expr><C-h> deoplete#mappings#smart_close_popup()."\<C-h>"
                            " inoremap <expr><BS> deoplete#mappings#smart_close_popup()."\<C-h>"
                            " Set async completion.
                            " set omnifunc=syntaxcomplete#Complete
                            
                            "ruby complete -------------------------------------------------------------
                            " au FileType ruby setl omnifunc=monster#omnifunc
                            " autocmd FileType ruby set omnifunc=monster#omnifunc
    1              0.000004 let g:deoplete#omni#input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
    1              0.000004 let g:deoplete#sources.ruby = ['buffer', 'member', 'file', 'ultisnips']
    1              0.000004 let g:monster#completion#rcodetools#backend = "async_rct_complete"
    1              0.000005 let g:deoplete#sources#omni#input_patterns = {
                            \   "ruby" : '[^. *\t]\.\w*\|\h\w*::',
                            \}
                            
                            "}}}
                            
                            " -----------------------------------------------------
                            " Smooth scroll vim-smooth-scroll {{{
                            " -----------------------------------------------------
                            "noremap <silent> <c-key> :call smooth_scroll#up(&scroll, 0, 2)<CR>
                            "noremap <silent> <c-key> :call smooth_scroll#down(&scroll, 0, 2)<CR>
    1              0.000031 noremap <silent> <c-u> :call smooth_scroll#up(&scroll*2, 0, 4)<CR>
    1              0.000018 noremap <silent> <c-o> :call smooth_scroll#down(&scroll*2, 0, 4)<CR>
                            "}}}
                            
                            " -----------------------------------------------------
                            " Fugitive git {{{
                            " -----------------------------------------------------
                            "
    1              0.000019 nnoremap <leader>gi :Git! init<CR>
    1              0.000026 nnoremap <leader>ga :Git! add %:p<CR><CR>
    1              0.000017 nnoremap <leader>gs :Gstatus<CR>
    1              0.000017 nnoremap <leader>gc :Gcommit -v -q<CR>
    1              0.000018 nnoremap <leader>gt :Gcommit -v -q %:p<CR>
    1              0.000017 nnoremap <leader>gd :Gdiff<CR>
    1              0.000017 nnoremap <leader>ge :Gedit<CR>
    1              0.000017 nnoremap <leader>gr :Gread<CR>
    1              0.000020 nnoremap <leader>gpu :Git push --set-upstream origin<Space>
    1              0.000019 nnoremap <leader>gsu :Git branch<Space>--set-upstrea<Space>
                            
    1              0.000018 nnoremap <leader>gbr :Git checkout<Space>-b<Space>
                            
    1              0.000017 nnoremap <leader>gw :Gwrite<CR><CR>
    1              0.000017 nnoremap <leader>gwq :Gwq<CR>
    1              0.000018 nnoremap <leader>gl :silent! Glog<CR>:bot copen<CR>
    1              0.000017 nnoremap <leader>gp :Ggrep<Space>
    1              0.000017 nnoremap <leader>gm :Gmove<Space>
    1              0.000017 nnoremap <leader>gb :Git! branch<Space>
    1              0.000017 nnoremap <leader>go :Git! checkout<Space>
                            
    1              0.000019 nnoremap <leader>gra :Git! remote add origin master<CR>
    1              0.000019 nnoremap <leader>gpf :Git! push --set-upstream origin master<CR>
    1              0.000017 nnoremap <leader>gps :Git! push<CR>
    1              0.000017 nnoremap <leader>gpl :Git! pull<CR>
    1              0.000018 nnoremap <leader>gbl :Gread<CR>
                            "}}}
                            
                            " -----------------------------------------------------
                            " Ctrl-SF {{{
                            "
                            " -----------------------------------------------------
    1              0.000003 let g:ctrlsf_ackprg = 'ag'
    1              0.000013 let g:ctrlsf_mapping = {
                                  \ "next"    : "n",
                                  \ "prev"    : "N",
                                  \ "quit"    : "q",
                                  \ "popen"   : "p",
                                  \ "pquit"   : "q",
                                  \ "split"   : "s",
                                  \ "openb"   : "",
                                  \ "tab"     : "",
                                  \ "tabb"    : "",
                                  \ "loclist" : "",
                                  \ }
                            
    1              0.000003 let g:ctrlsf_auto_close = 1
    1              0.000003 let g:ctrlsf_case_sensitive = 'no'
    1              0.000002 let g:ctrlsf_default_root = 'cwd'
    1              0.000003 let g:ctrlsf_confirm_save = 1
    1              0.000005 let g:ctrlsf_ignore_dir = ['bower_components', 'npm_modules', 'doc', 'log', 'public']
    1              0.000003 let g:ctrlsf_selected_line_hl = 'op'
    1              0.000003 let g:ctrlsf_populate_qflist=1
    1              0.000002 let g:ctrlsf_position='right'
    1              0.000002 let g:ctrlsf_winsize = '50%'
    1              0.000002 let g:ctrlsf_auto_close=0
    1              0.000002 let g:ctrlsf_regex_pattern=1
                            "let g:ctrlsf_context = '-C 3'
                            "
    1              0.000018 nnoremap <leader>gg :CtrlSF<Space>
    1              0.000017 nnoremap <leader>gG :CtrlSFToggle<Space>
                            
    1              0.000018 nnoremap <silent> ,g :call utils#searchCurrentWordWithAg()<CR>
                            
    1              0.000017 nmap     <C-S>f <Plug>CtrlSFPrompt
    1              0.000017 vmap     <C-S>f <Plug>CtrlSFVwordPath
    1              0.000016 vmap     <C-S>F <Plug>CtrlSFVwordExec
    1              0.000017 nmap     <C-S>n <Plug>CtrlSFCwordPath
    1              0.000017 nmap     <C-S>p <Plug>CtrlSFPwordPath
    1              0.000016 nnoremap <C-S>o :CtrlSFOpen<CR>
    1              0.000016 nnoremap <C-S>t :CtrlSFToggle<CR>
    1              0.000012 inoremap <C-S>t <Esc>:CtrlSFToggle<CR>
    1              0.000018 nmap     <C-S>l <Plug>CtrlSFQuickfixPrompt
    1              0.000017 vmap     <C-S>l <Plug>CtrlSFQuickfixVwordPath
    1              0.000017 vmap     <C-S>L <Plug>CtrlSFQuickfixVwordExec
                            
                            "}}}
                            
                            " -----------------------------------------------------
                            " Vim-Plug {{{
                            " -----------------------------------------------------
    1              0.000018 nnoremap <leader>pi :PlugInstall<CR>
    1              0.000017 nnoremap <leader>pu :PlugUpdate<CR>
    1              0.000017 nnoremap <leader>pU :PlugUpgrade<CR>
    1              0.000017 nnoremap <leader>pc :PlugClean<CR>
                            "}}}
                            
                            " -----------------------------------------------------
                            " Ultisnips for snippets {{{
                            " -----------------------------------------------------
                            " Disable built-in <C-x><C-k> to be able to go backward
    1              0.000011 inoremap <C-x><C-k> <NOP>
                            " Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
                            " let g:UltiSnipsExpandTrigger="<tab>"
    1              0.000003 let g:UltiSnipsExpandTrigger="<C-t>" " used to be tab, but reserved tab for completion manager
    1              0.000003 let g:UltiSnipsListSnippets='<C-l>'
    1              0.000003 let g:UltiSnipsEditSplit="vertical"
    1   0.000023   0.000021 set runtimepath+=~/.vimsnippets
                            " the following directories reside in .vimsnippets,
                            " note that there's also a snipmate folder which is not compatible with
                            " ultisnips, but some snippets work if a suffix is added with a  missing endsnippet.
                            " you have to manually do that and move them to the folders below.
    1              0.000005 let g:UltiSnipsSnippetDirectories=[ "ultisnips", "custom" ]
                            "user defined snippets
    1              0.000003 let g:UltiSnipsSnippetsDir= "~/.vimsnippets/custom"
    1              0.000003 let g:UltiSnipsUsePythonVersion=2
    1              0.000003 let g:UltiSnipsJumpForwardTrigger='<leader>n'
                            
                            " let g:UltiSnipsJumpBackwardTrigger='<leader>='
                            "}}}
                            
                            
                            " -----------------------------------------------------
                            " YouCompleteMe {{{
                            " -----------------------------------------------------
                            " let g:ycm_global_ycm_extra_conf = "~/.config/nvim/.ycm_extra_conf.py"
                            " let g:ycm_key_list_select_completion=[]
                            " let g:ycm_key_list_previous_completion=[]
                            "}}}
                            
                            " -----------------------------------------------------
                            " Vim Markdown settings {{{
                            " -----------------------------------------------------
    1              0.000004 let g:vim_markdown_no_default_key_mappings=1
    1              0.000003 let g:vim_markdown_folding_disabled=1
                            "}}}
                            
                            
                            " -----------------------------------------------------
                            " Localvimrc per project type configuration {{{
                            " -----------------------------------------------------
    1              0.000004 let g:localvimrc_name=[ ".cpp_init.vim" ]
                            
                            "}}}
                            
                            " -----------------------------------------------------
                            " Vim Markdown settings {{{
                            " -----------------------------------------------------
    1              0.000003 let g:vim_markdown_no_default_key_mappings=1
    1              0.000003 let g:vim_markdown_folding_disabled=1
                            "}}}
                            
                            
                            " -----------------------------------------------------
                            " Custom commands and functions {{{
                            " ======================================================================================================================
                            
                            "Delete current file
    1              0.000019 command! -complete=file -nargs=1 Remove :echo 'Remove: '.'<f-args>'.' '.(delete(<f-args>) == 0 ? 'Succeeded.' : 'Failed.')
                            
                            " Open Rails consoles in dedicated tab
    1              0.000007 command! -register RailsConsoles :call utils#RailsConsoles()
                            
                            " Open DefaultWorkspace
    1              0.000005 command! -register DW :call utils#DefaultWorkspace()
                            
                            " Generate tags definitions gem install --no-user-install starscope
    1              0.000005 command! GenerateTags :call utils#generateCtags()
                            
                            " Reformat whole or selection from file, format
                            " Needs: npm install js-beautify, gem install ruby-beautify, python
    1              0.000005 command! Format :call utils#formatFile()
    1              0.000016 nnoremap <silent> ,f :Format<CR>
                            
                            " Annotate file (show values in special # => comments)
                            " See gem install --no-user-install seeing_is_believing
    1              0.000004 command! Annotate :call utils#annotateFile()
    1              0.000016 nnoremap <silent> ,a :Annotate<CR>
                            
                            " Profile
    1              0.000005 command! Profile :call utils#profile()
                            
                            " Retab
    1              0.000006 command! Retab :call utils#retabToFourSpaces()
                            "}}}
                            
                            " -----------------------------------------------------
                            " Autocommands {{{
                            " ======================================================================================================================
                            
                            " Recognize python
    1              0.000071 au BufNewFile,BufRead *.py set filetype=python
                            
                            " Turn spellcheck on for markdown files
    1              0.000025 autocmd BufNewFile,BufRead *.md setlocal spell
                            
                            " Remove trailing whitespaces automatically before save
    1              0.000005 autocmd BufWritePre * call utils#stripTrailingWhitespaces()
                            
                            " Resize splits when the window is resized
    1              0.000006 autocmd VimResized * :wincmd =
                            
    1              0.000002 augroup vimrcEx
    1              0.000106   autocmd!
                              " When editing a file, always jump to the last known cursor position.
                              " Don't do it for commit messages, when the position is invalid, or when
                              " inside an event handler (happens when dropping a file on gvim).
    1              0.000016   autocmd BufReadPost *
                                \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
                                \   exe "normal g`\"" |
                                \ endif
                            
                              " Set syntax highlighting for specific file types
    1              0.000025   autocmd BufRead,BufNewFile Appraisals set filetype=ruby
    1              0.000023   autocmd BufRead,BufNewFile *.md set filetype=markdown
    1              0.000029   autocmd BufRead,BufNewFile .{jscs,jshint,eslint}rc set filetype=json
    1              0.000002 augroup END
                            
                            " Make sure Vim returns to the same line when you reopen a file. Thanks, Amit and Steve Losh.
    1              0.000002 augroup line_return
    1              0.000043   au!
    1              0.000016   au BufReadPost *
                                    \ if line("'\"") > 0 && line("'\"") <= line("$") |
                                    \     execute 'normal! g`"zvzz' |
                                    \ endif
    1              0.000002 augroup END
                            "}}}
                            
                            " -----------------------------------------------------
                            " Enable seeing-is-believing mappings only for Ruby {{{
                            " ======================================================================================================================
    1              0.000002 augroup seeingIsBelievingSettings
    1              0.000044   autocmd!
                            
    1              0.000007   autocmd FileType ruby nmap <buffer> ,b <Plug>(seeing-is-believing-mark-and-run)
    1              0.000005   autocmd FileType ruby xmap <buffer> ,b <Plug>(seeing-is-believing-mark-and-run)
                            
    1              0.000004   autocmd FileType ruby nmap <buffer> ,m <Plug>(seeing-is-believing-mark)
    1              0.000004   autocmd FileType ruby xmap <buffer> ,m <Plug>(seeing-is-believing-mark)
    1              0.000004   autocmd FileType ruby imap <buffer> ,m <Plug>(seeing-is-believing-mark)
                            
    1              0.000004   autocmd FileType ruby nmap <buffer> ,b <Plug>(seeing-is-believing-run)
    1              0.000004   autocmd FileType ruby imap <buffer> ,b <Plug>(seeing-is-believing-run)
    1              0.000001 augroup END
                            "}}}
                            
                            " -----------------------------------------------------
                            " F-key actions {{{
                            " =====================================================
                            
                            "F1 Cannot be assigned for some reason in Ubuntu 16.04
                            
                            "F2 Source (reload configuration)
    1              0.000019 nnoremap <silent> <F2> :so ~/.config/nvim/init.vim<CR>
                            
                            "F3 NeoTerm Toggle
    1              0.000016 nnoremap <silent> <F3> :Ttoggle<cr>
                            
                            "F4 Toggle white characters visibility
    1              0.000017 nnoremap <silent> <F4> :set list!<CR> :set list?<CR>
                            
                            
                            
                            "F12 Show F keys toggles
    1              0.000018 nnoremap <F12> :call utils#showToggles()<CR>

SCRIPT  /home/spiros/.config/nvim/plugins.vim
Sourced 1 time
Total time:   0.079280
 Self time:   0.011108

count  total (s)   self (s)
                            " ======================================================================================================================
                            "
                            " Plugin manager (Plug) settings.
                            " Author : Spiros Kabasakalis <Kabasakalis@gmail.com>
                            " ======================================================================================================================
                            
    1              0.000005 if &compatible
                              set nocompatible
                            end
    1              0.000021 if empty(glob('~/.config/nvim/autoload/plug.vim'))
                              silent !curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs
                                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                              autocmd VimEnter * PlugInstall | source ~/.config/nvim/init.vim
                            endif
                            
    1   0.000365   0.000022 call plug#begin('~/.config/nvim/plugins')
                            
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Color Themes {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000194 Plug 'whatyouhide/vim-gotham'
    1              0.000155 Plug 'jacoborus/tender'
    1              0.000157 Plug 'junegunn/seoul256.vim'
    1              0.000152 Plug 'morhetz/gruvbox'
    1              0.000189 Plug 'joshdick/onedark.vim'
                            "}}}
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Text insertion/manipulation {{{
                            " ---------------------------------------------------------------------------------------------------------------------
                            
    1              0.000153 Plug 'vim-scripts/tComment'
    1              0.000153 Plug 'justinmk/vim-sneak'
    1              0.000151 Plug 'matze/vim-move'
    1              0.000182 Plug 'terryma/vim-smooth-scroll'
    1              0.000153 Plug 'sickill/vim-pasta'
    1              0.000158 Plug 'AndrewRadev/splitjoin.vim'
    1              0.000155 Plug 'terryma/vim-multiple-cursors'
    1              0.000153 Plug 'bkad/CamelCaseMotion'  " CamelCase and snake_case motions
    1              0.000158 Plug 'kana/vim-textobj-user' " Custom text objects creation (dependency for the latter)
    1              0.000156 Plug 'nelstrom/vim-textobj-rubyblock' " Ruby block text object (vir-var)
    1              0.000153 Plug 'terryma/vim-expand-region' " Easily expand selected region
    1              0.000199 Plug 'godlygeek/tabular', { 'on':  'Tabularize' } " Easy alignment
    1              0.000155 Plug 'tpope/vim-repeat'
    1              0.000151 Plug 'tpope/vim-rhubarb'
    1              0.000152 Plug 'tpope/vim-surround'
    1              0.000153 Plug 'tpope/vim-unimpaired'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Search {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000153 Plug 'easymotion/vim-easymotion'
    1              0.000198 Plug 'dyng/ctrlsf.vim', { 'on': ['CtrlSF', 'CtrlSFToggle'] } " Ag wrapper (Unite grep alternative) search and edit
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Project Management {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000156 Plug 'ctrlpvim/ctrlp.vim'
    1              0.000158 Plug 'scrooloose/nerdTree'
    1              0.000154 Plug 'tpope/vim-vinegar'
    1              0.000157 Plug  'mhinz/vim-startify'
                            " Plug 'vim-ctrlspace/vim-ctrlspace'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Terminal {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000157 Plug 'kassio/neoterm'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Git {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000155 Plug 'airblade/vim-gitgutter'
    1              0.000168 Plug 'tpope/vim-fugitive'
    1              0.000157 Plug 'Xuyuanp/nerdtree-git-plugin'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Status Bar Theme vim-airline {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000154 Plug 'vim-airline/vim-airline'
    1              0.000157 Plug 'vim-airline/vim-airline-themes'
    1              0.000153 Plug 'ryanoasis/vim-devicons'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            "  Snippet ultisnips {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000155 Plug 'SirVer/ultisnips'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            "  Rails/Ruby {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000154 Plug 'vim-ruby/vim-ruby'
    1              0.000152 Plug 'tpope/vim-rails'
    1              0.000155 Plug 'tpope/vim-bundler'
    1              0.000155 Plug 'tpope/vim-rake'
    1              0.000179 Plug 'tpope/vim-haml'
    1              0.000157 Plug 'janko-m/vim-test'
    1              0.000156 Plug 'thoughtbot/vim-rspec'
    1              0.000158 Plug 'ecomba/vim-ruby-refactoring'
                            " Plug 'tpope/vim-endwise' " bug with ENTER, conflict with completion manager
    1              0.000167 Plug 'osyo-manga/vim-monster'
    1              0.000204 Plug 'Shougo/vimproc.vim', {'do' : 'make'}
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " deoplete autocomplete {{{
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
                            " Plug 'ervandew/supertab'
                            " Plug 'Valloric/YouCompleteMe'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " vim-tmux-navigator {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000163 Plug 'christoomey/vim-tmux-navigator'
                            "}}}
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Miscellaneous {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000158 Plug 'hwartig/vim-seeing-is-believing'
                            "}}}
                            "
                            " ---------------------------------------------------------------------------------------------------------------------
                            "  Asynchronous maker and linter w0rp/ale  {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000156 Plug 'w0rp/ale'
                            "}}}
                            "
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            "  AutoCompletion roxma/nvim-completion-manager {{{
                            " ---------------------------------------------------------------------------------------------------------------------
    1              0.000166 Plug 'roxma/nvim-completion-manager'
    1              0.000164 Plug 'roxma/ncm-rct-complete'
                            
                            "}}}
                            "
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " C++
                            " ---------------------------------------------------------------------------------------------------------------------
                            "  c-supportWolfgangMehner/c-support
                            " Plug 'WolfgangMehner/c-support', { 'for': 'cpp' }
                            "
                            "  Doxygen
    1              0.000203 Plug 'DoxygenToolkit.vim', { 'for': 'cpp' }
                            " Additional syntax highlighting that I use for C++11/14/17
    1              0.000197 Plug 'octol/vim-cpp-enhanced-highlight', { 'for': 'cpp' }
                            " This Vim plugin will help switching between companion files (e.g. .h and .cpp files)
    1              0.000193 Plug 'derekwyatt/vim-fswitch', { 'for': 'cpp' }
                            " Plug 'zchee/deoplete-clang', { 'for': 'cpp' }
                            "
                            " C++ autocomplete
                            " Plug 'Rip-Rip/clang_complete', {'for': 'cpp' }
                            
                            " C++ autocomplete with roxma/nvim-completion-manager
    1              0.000179 Plug 'roxma/clang_complete'
                            
                            " Style format with clang-format
    1              0.000196 Plug 'rhysd/vim-clang-format', {'for': 'cpp' }
                            
                            "}}}
                            "
                            
                            " ---------------------------------------------------------------------------------------------------------------------
                            " Languages {{{
                            " ---------------------------------------------------------------------------------------------------------------------
                            
                            " HTML5 syntax
    1              0.000154 Plug 'othree/html5.vim'
                            " SCSS syntax
    1              0.000156 Plug 'cakebaker/scss-syntax.vim'
                            " Color highlighter
    1              0.000199 Plug 'lilydjwg/colorizer', { 'for': ['css', 'sass', 'scss', 'less', 'html', 'xhtml', 'javascript', 'javascript.jsx'] }
                            " Elixir syntax
    1              0.000154 Plug 'elixir-lang/vim-elixir'
                            " Elm syntax
    1              0.000155 Plug 'lambdatoast/elm.vim'
                            " Yaml indentation
    1              0.000154 Plug 'martin-svk/vim-yaml'
                            " Markdown syntax
    1              0.000156 Plug 'tpope/vim-markdown'
                            " Git syntax
    1              0.000153 Plug 'tpope/vim-git'
                            " Tmux syntax
    1              0.000152 Plug 'tejr/vim-tmux'
                            " Dockerfile
    1              0.000155 Plug 'honza/dockerfile.vim'
    1              0.000156 Plug 'digitaltoad/vim-pug'
    1              0.000151 Plug 'slim-template/vim-slim'
                            
                            "}}}
                            
    1   0.067848   0.000020 call plug#end()

SCRIPT  /usr/share/nvim/runtime/filetype.vim
Sourced 3 times
Total time:   0.029357
 Self time:   0.026780

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jul 21
                            
                            " Listen very carefully, I will say this only once
    3              0.000016 if exists("did_load_filetypes")
    2              0.000003   finish
                            endif
    1              0.000003 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000012 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000002 augroup filetypedetect
                            
                            " Ignored extensions
    1              0.000005 if exists("*fnameescape")
    1              0.000069 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    1              0.000016 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    1              0.000014 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
    1              0.000004 elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    1              0.000004 if !exists("g:ft_ignore_pat")
                              let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
                            endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    1              0.000005 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Abaqus or Trasys
    1              0.000009 au BufNewFile,BufRead *.inp			call s:Check_inp()
                            
    1              0.000003 func! s:Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " A-A-P recipe
    1              0.000009 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    1              0.000027 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    1              0.000009 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    1              0.000008 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    1              0.000008 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    1              0.000008 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    1              0.000016 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    1              0.000009 au BufNewFile,BufRead *.gpr			setf ada
                            
                            " AHDL
    1              0.000009 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    1              0.000010 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    1              0.000010 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
    1              0.000014 au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache style config file
    1              0.000032 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    1              0.000017 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    1              0.000012 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    1              0.000013 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    1              0.000012 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    1              0.000026 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    1              0.000009 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    1              0.000011 au BufNewFile,BufRead apt.conf		       setf aptconf
    1              0.000011 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    1              0.000021 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    1              0.000019 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    1              0.000010 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    1              0.000016 au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
    1              0.000015 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    1              0.000013 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    1              0.000023 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    1              0.000025 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    1              0.000030 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    1              0.000004 func! s:FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call s:FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    1              0.000004 func! s:FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Macro (VAX)
    1              0.000010 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    1              0.000014 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    1              0.000011 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    1              0.000010 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    1              0.000020 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    1              0.000011 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    1              0.000013 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    1              0.000011 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    1              0.000022 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    1              0.000012 au BufNewFile,BufRead *.bas			call s:FTVB("basic")
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    1              0.000004 func! s:FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    1              0.000026 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    1              0.000020 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    1              0.000016 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    1              0.000018 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    1              0.000015 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    1              0.000011 au BufNewFile,BufRead *.btm			call s:FTbtm()
    1              0.000003 func! s:FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
                            " BC calculator
    1              0.000010 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    1              0.000012 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    1              0.000011 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    1              0.000010 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
    1              0.000020 au BufNewFile,BufRead named.conf,rndc.conf	setf named
                            
                            " BIND zone
    1              0.000013 au BufNewFile,BufRead named.root		setf bindzone
    1              0.000011 au BufNewFile,BufRead *.db			call s:BindzoneCheck('')
                            
    1              0.000004 func! s:BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            " Blank
    1              0.000011 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    1              0.000022 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " Bazel (http://bazel.io)
    1              0.000028 autocmd BufRead,BufNewFile *.bzl,BUILD,WORKSPACE setfiletype bzl
                            
                            " C or lpc
    1              0.000010 au BufNewFile,BufRead *.c			call s:FTlpc()
                            
    1              0.000003 func! s:FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
                            " Calendar
    1              0.000011 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    1              0.000010 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    1              0.000010 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    1              0.000010 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    1              0.000011 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    1              0.000037 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    1              0.000013 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    1              0.000011 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    1              0.000012 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    1              0.000011 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    1              0.000013 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    1              0.000012 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    1              0.000013 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    1              0.000014 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    1              0.000074 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    1              0.000005 if has("fname_case")
    1              0.000016   au BufNewFile,BufRead *.C,*.H setf cpp
    1              0.000002 endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    1              0.000010 au BufNewFile,BufRead *.h			call s:FTheader()
                            
    1              0.000003 func! s:FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " Ch (CHscript)
    1              0.000013 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    1              0.000013 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    1              0.000012 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    1              0.000014 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    1              0.000035 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    1              0.000018 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    1              0.000014 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    1              0.000012 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    1              0.000011 au BufNewFile,BufRead *.ch			call s:FTchange()
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" ir "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    1              0.000003 func! s:FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
                            " ChordPro
    1              0.000044 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    1              0.000020 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    1              0.000013 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    1              0.000012 au BufNewFile,BufRead *.ent			call s:FTent()
                            
    1              0.000003 func! s:FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
                            " Clipper (or FoxPro; could also be eviews)
    1              0.000019 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    1              0.000033 au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
    1              0.000030 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    1              0.000020 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    1              0.000016 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    1              0.000031 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    1              0.000019 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    1              0.000013 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    1              0.000030 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    1              0.000023 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    1              0.000011 au BufNewFile,BufRead *.cu			setf cuda
                            
                            " Dockerfile
    1              0.000020 au BufNewFile,BufRead Dockerfile,*.Dockerfile	setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
    1              0.000016 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    1              0.000014 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    1              0.000014 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Euphoria 3 or 4
    1              0.000045 au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
    1              0.000005 if has("fname_case")
    1              0.000044    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
    1              0.000002 endif
                            
    1              0.000003 func! s:EuphoriaCheck()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                setf euphoria3
                              endif
                            endfunc
                            
                            " Lynx config files
    1              0.000014 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    1              0.000023 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    1              0.000014 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    1              0.000011 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    1              0.000015 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    1              0.000012 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    1              0.000023 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    1              0.000014 au BufNewFile,BufRead *.pld			setf cupl
    1              0.000013 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    1              0.000016 au BufNewFile,BufRead */debian/control		setf debcontrol
    1              0.000016 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
    1              0.000015 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    1              0.000018 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    1              0.000014 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    1              0.000017 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    1              0.000012 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    1              0.000014 au BufNewFile,BufRead *.d			call s:DtraceCheck()
                            
    1              0.000003 func! s:DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
                            " Desktop files
    1              0.000022 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    1              0.000022 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    1              0.000013 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    1              0.000031 au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff
                            
                            " Dircolors
    1              0.000033 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    1              0.000020 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    1              0.000016 au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')
                            
                            " DOT
    1              0.000015 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    1              0.000016 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    1              0.000013 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    1              0.000012 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    1              0.000015 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    1              0.000038 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    1              0.000013 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    1              0.000015 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    1              0.000014 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    1              0.000024 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo)
    1              0.000016 au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif
                            
                            " Embedix Component Description
    1              0.000015 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
    1              0.000019 au BufNewFile,BufRead *.e,*.E			call s:FTe()
                            
                            " Elinks configuration
    1              0.000027 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
    1              0.000003 func! s:FTe()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                let n = 1
                                while n < 100 && n < line("$")
                                  if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                                    setf specman
                                    return
                                  endif
                                  let n = n + 1
                                endwhile
                                setf eiffel
                              endif
                            endfunc
                            
                            " ERicsson LANGuage; Yaws is erlang too
    1              0.000035 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    1              0.000014 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    1              0.000013 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    1              0.000026 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    1              0.000016 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    1              0.000016 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    1              0.000016 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    1              0.000017 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    1              0.000015 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    1              0.000017 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    1              0.000030 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    1              0.000014 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    1              0.000016 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    1              0.000025 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    1              0.000015 au BufNewFile,BufRead auto.master		setf conf
    1              0.000025 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    1              0.000023 au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
    1              0.000016 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    1              0.000004 if has("fname_case")
    1              0.000108   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
    1              0.000002 endif
    1              0.000119 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    1              0.000016 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    1              0.000027 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    1              0.000015 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    1              0.000023 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    1              0.000027 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    1              0.000015 au BufNewFile,BufRead COMMIT_EDITMSG		setf gitcommit
    1              0.000014 au BufNewFile,BufRead MERGE_MSG			setf gitcommit
    1              0.000035 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    1              0.000018 au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
    1              0.000017 au BufNewFile,BufRead */.config/git/config	setf gitconfig
    1              0.000008 if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config	setf gitconfig
                            endif
    1              0.000017 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    1              0.000018 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    1              0.000017 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    1              0.000026 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    1              0.000027 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    1              0.000016 au BufNewFile,BufRead */.gnupg/options		setf gpg
    1              0.000018 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    1              0.000020 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
                            
                            " gnash(1) configuration files
    1              0.000048 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    1              0.000015 au BufNewFile,BufRead gitolite.conf		setf gitolite
    1              0.000017 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    1              0.000030 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    1              0.000017 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
    1              0.000015 au BufNewFile,BufRead *.go			setf go
                            
                            " GrADS scripts
    1              0.000015 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    1              0.000014 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    1              0.000026 au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
    1              0.000017 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    1              0.000119 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    1              0.000031 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    1              0.000014 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    1              0.000030 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    1              0.000025 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    1              0.000017 au BufNewFile,BufRead *.lhs			setf lhaskell
    1              0.000017 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    1              0.000014 au BufNewFile,BufRead *.ht			setf haste
    1              0.000015 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    1              0.000061 au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    1              0.000031 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    1              0.000015 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    1              0.000052 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
                            
                            " Distinguish between HTML, XHTML and Django
    1              0.000004 func! s:FThtml()
                              let n = 1
                              while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\|load\)\>\|{#\s\+'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf html
                            endfunc
                            
                            " HTML with Ruby - eRuby
    1              0.000031 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    1              0.000017 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    1              0.000015 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    1              0.000018 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    1              0.000030 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    1              0.000015 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    1              0.000034 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    1              0.000018 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    1              0.000018 au BufNewFile,BufRead *.idl			call s:FTidl()
                            
                            " Distinguish between standard IDL and MS-IDL
    1              0.000003 func! s:FTidl()
                              let n = 1
                              while n < 50 && n < line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    1              0.000034 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    1              0.000016 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    1              0.000016 au BufNewFile,BufRead .indent.pro		setf indent
    1              0.000016 au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    1              0.000018 au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')
                            
                            " Distinguish between "default" and Cproto prototype file. */
    1              0.000004 func! s:ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            
                            " Indent RC
    1              0.000017 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    1              0.000034 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    1              0.000030 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    1              0.000045 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
    1              0.000041 au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c 	setf upstreamlog
    1              0.000047 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    1              0.000040 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
    1              0.000043 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
    1              0.000038 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    1              0.000046 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    1              0.000019 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    1              0.000015 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    1              0.000021 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    1              0.000019 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    1              0.000033 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    1              0.000034 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    1              0.000032 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    1              0.000030 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    1              0.000056 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript
                            
                            " Java Server Pages
    1              0.000020 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000043 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    1              0.000019 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    1              0.000019 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    1              0.000019 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    1              0.000047 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
    1              0.000041 au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json
                            
                            " Kixtart
    1              0.000019 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    1              0.000015 au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
    1              0.000015 au BufNewFile,BufRead *.kv			setf kivy
                            
                            " KDE script
    1              0.000016 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    1              0.000028 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    1              0.000035 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    1              0.000032 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    1              0.000046 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    1              0.000020 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    1              0.000015 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    1              0.000015 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
    1              0.000016 au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
    1              0.000062 au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
    1              0.000029 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    1              0.000032 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    1              0.000040 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    1              0.000017 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    1              0.000016 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    1              0.000005 if has("fname_case")
    1              0.000108   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
    1              0.000002 else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
                            endif
                            
                            " SBCL implementation of Common Lisp
    1              0.000028 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    1              0.000017 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    1              0.000030 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    1              0.000020 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    1              0.000018 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    1              0.000017 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    1              0.000021 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    1              0.000032 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    1              0.000033 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    1              0.000020 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
    1              0.000016 au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
    1              0.000020 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    1              0.000020 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    1              0.000020 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    1              0.000020 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn)
    1              0.000180 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    1              0.000032 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    1              0.000030 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    1              0.000064 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    1              0.000038 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    1              0.000017 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    1              0.000020 au BufNewFile,BufRead *.man			setf nroff
                            
                            " Man config
    1              0.000032 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    1              0.000051 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    1              0.000021 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    1              0.000085 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
    1              0.000044 au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Matlab or Objective C
    1              0.000015 au BufNewFile,BufRead *.m			call s:FTm()
                            
    1              0.000004 func! s:FTm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              if exists("g:filetype_m")
                                exe "setf " . g:filetype_m
                              else
                                setf matlab
                              endif
                            endfunc
                            
                            " Mathematica notebook
    1              0.000020 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    1              0.000023 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    1              0.000021 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    1              0.000035 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    1              0.000050 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    1              0.000018 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    1              0.000017 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    1              0.000021 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
    1              0.000036 au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
    1              0.000022 au BufNewFile,BufRead *.mms			call s:FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    1              0.000021 au BufNewFile,BufRead *.mmp			setf mmp
                            
    1              0.000003 func! s:FTmms()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            
                            " Modsim III (or LambdaProlog)
    1              0.000026 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2  (.md removed in favor of Markdown)
    1              0.000069 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    1              0.000018 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    1              0.000071 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    1              0.000022 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    1              0.000050 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    1              0.000035 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
    1              0.000102 au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
    1              0.000031 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    1              0.000017 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    1              0.000017 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    1              0.000021 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    1              0.000036 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    1              0.000018 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    1              0.000019 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    1              0.000020 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " Nano
    1              0.000032 au BufNewFile,BufRead */etc/nanorc,*.nanorc  	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    1              0.000019 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Netrc
    1              0.000018 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    1              0.000019 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    1              0.000022 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    1              0.000023 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    1              0.000079 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    1              0.000020 au BufNewFile,BufRead *.[1-9]			call s:FTnroff()
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    1              0.000004 func! s:FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Nroff or Objective C++
    1              0.000020 au BufNewFile,BufRead *.mm			call s:FTmm()
                            
    1              0.000003 func! s:FTmm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
                            " Not Quite C
    1              0.000023 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSIS
    1              0.000041 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
    1              0.000092 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    1              0.000023 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    1              0.000043 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    1              0.000019 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    1              0.000018 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    1              0.000023 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    1              0.000020 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    1              0.000019 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    1              0.000046 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    1              0.000127 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    1              0.000025 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    1              0.000023 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    1              0.000023 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " Perl
    1              0.000006 if has("fname_case")
    1              0.000035   au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
    1              0.000002 else
                              au BufNewFile,BufRead *.pl			call s:FTpl()
                            endif
    1              0.000038 au BufNewFile,BufRead *.plx,*.al		setf perl
    1              0.000059 au BufNewFile,BufRead *.p6,*.pm6,*.pl6	setf perl6
                            
    1              0.000003 func! s:FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
                            " Perl, XPM or XPM2
    1              0.000027 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    1              0.000023 au BufNewFile,BufRead *.pod			setf pod
    1              0.000018 au BufNewFile,BufRead *.pod6		setf pod6
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    1              0.000073 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
    1              0.000068 au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
    1              0.000033 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    1              0.000024 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    1              0.000063 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
    1              0.000044 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    1              0.000065 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    1              0.000039 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    1              0.000026 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    1              0.000041 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    1              0.000020 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    1              0.000130 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    1              0.000025 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    1              0.000024 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    1              0.000019 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    1              0.000025 au BufNewFile,BufRead *.inc			call s:FTinc()
                            
    1              0.000003 func! s:FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                else
                                  call s:FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
                            " Printcap and Termcap
    1              0.000024 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    1              0.000022 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    1              0.000018 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    1              0.000034 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    1              0.000025 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    1              0.000020 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    1              0.000019 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    1              0.000035 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    1              0.000018 au BufNewFile,BufRead *.w			call s:FTprogress_cweb()
                            
    1              0.000003 func! s:FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
                            " Progress or assembly
    1              0.000018 au BufNewFile,BufRead *.i			call s:FTprogress_asm()
                            
    1              0.000003 func! s:FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call s:FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            " Progress or Pascal
    1              0.000018 au BufNewFile,BufRead *.p			call s:FTprogress_pascal()
                            
    1              0.000003 func! s:FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
                            	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    1              0.000025 au BufNewFile,BufRead *.psf			setf psf
    1              0.000047 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    1              0.000025 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    1              0.000027 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
    1              0.000025 au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
    1              0.000021 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    1              0.000046 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python, Python Shell Startup Files
                            " Quixote (Python-based web framework)
    1              0.000098 au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python
                            
                            " Radiance
    1              0.000049 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    1              0.000034 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    1              0.000022 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    1              0.000036 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    1              0.000033 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    1              0.000025 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    1              0.000171 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
    1              0.000004 if has("fname_case")
    1              0.000032   au BufNewFile,BufRead *.s,*.S			setf r
    1              0.000002 else
                              au BufNewFile,BufRead *.s			setf r
                            endif
                            
                            " R Help file
    1              0.000003 if has("fname_case")
    1              0.000037   au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
    1              0.000002 else
                              au BufNewFile,BufRead *.rd			setf rhelp
                            endif
                            
                            " R noweb file
    1              0.000003 if has("fname_case")
    1              0.000093   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
    1              0.000002 else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
                            endif
                            
                            " R Markdown file
    1              0.000003 if has("fname_case")
    1              0.000094   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
    1              0.000002 else
                              au BufNewFile,BufRead *.rmd,*.smd			setf rmd
                            endif
                            
                            " R reStructuredText file
    1              0.000003 if has("fname_case")
    1              0.000069   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
    1              0.000002 else
                              au BufNewFile,BufRead *.rrst,*.srst			setf rrst
                            endif
                            
                            " Rexx, Rebol or R
    1              0.000032 au BufNewFile,BufRead *.r,*.R			call s:FTr()
                            
    1              0.000003 func! s:FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
                            " Remind
    1              0.000081 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    1              0.000020 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    1              0.000026 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    1              0.000028 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    1              0.000027 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    1              0.000022 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    1              0.000018 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    1              0.000026 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    1              0.000026 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    1              0.000044 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    1              0.000063 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    1              0.000020 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rackup
    1              0.000021 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    1              0.000020 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    1              0.000058 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    1              0.000070 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    1              0.000021 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    1              0.000021 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    1              0.000030 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    1              0.000020 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    1              0.000022 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scilab
    1              0.000051 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    1              0.000022 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    1              0.000021 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    1              0.000043 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    1              0.000028 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    1              0.000027 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    1              0.000024 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    1              0.000022 au BufNewFile,BufRead *.mc			call s:McSetf()
                            
    1              0.000004 func! s:McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Services
    1              0.000023 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    1              0.000021 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    1              0.000021 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    1              0.000021 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    1              0.000021 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    1              0.000057 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    1              0.000072 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    1              0.000021 au BufNewFile,BufRead catalog			setf catalog
    1              0.000021 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
    1              0.000203 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call SetFileTypeSH("bash")
    1              0.000047 au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
    1              0.000080 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
    1              0.000025 au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call SetFileTypeSH("bash") |
                            	\ endif
                            
                            " Also called from scripts.vim.
    1              0.000003 func! SetFileTypeSH(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    1              0.000003 func! SetFileTypeShell(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
                            " tcsh scripts
    1              0.000073 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    1              0.000131 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
                            
    1              0.000003 func! s:CSH()
                              if exists("g:filetype_csh")
                                call SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call SetFileTypeShell("tcsh")
                              else
                                call SetFileTypeShell("csh")
                              endif
                            endfunc
                            
                            " Z-Shell script
    1              0.000058 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    1              0.000064 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    1              0.000028 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    1              0.000069 au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
    1              0.000039 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    1              0.000030 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    1              0.000052 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    1              0.000113 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    1              0.000055 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    1              0.000073 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    1              0.000022 au BufNewFile,BufRead .slrnrc			setf slrnrc
    1              0.000022 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    1              0.000022 au BufNewFile,BufRead *.st			setf st
    1              0.000035 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    1              0.000028 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    1              0.000026 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    1              0.000034 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    1              0.000046 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    1              0.000054 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    1              0.000047 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    1              0.000066 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    1              0.000022 au BufNewFile,BufRead *.rules			call s:FTRules()
                            
    1              0.000007 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    1              0.000003 func! s:FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              if path =~ '^/\(etc\|usr/share\)/polkit-1/rules\.d'
                                setf javascript
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                                    setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
                            
                            " Spec (Linux RPM)
    1              0.000025 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    1              0.000065 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    1              0.000029 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    1              0.000041 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    1              0.000056 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    1              0.000021 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    1              0.000129 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    1              0.000030 au BufNewFile,BufRead *.sql			call s:SQL()
                            
    1              0.000003 func! s:SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " SQLJ
    1              0.000024 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    1              0.000055 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    1              0.000044 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    1              0.000022 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    1              0.000102 au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
                            
                            " SMCL
    1              0.000066 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    1              0.000029 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    1              0.000031 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    1              0.000023 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    1              0.000046 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
    1              0.000036 au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}	setf systemd
                            
                            " Synopsys Design Constraints
    1              0.000030 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    1              0.000040 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    1              0.000031 au BufNewFile,BufRead *.svg			setf svg
                            
                            " If the file has an extension of 't' and is in a directory 't' or 'xt' then
                            " it is almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    1              0.000004 func! s:FTperl()
                              let dirname = expand("%:p:h:t")
                              if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              if search('^use\s\s*\k', 'nc', 30)
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Tads (or Nroff or Perl test file)
    1              0.000024 au BufNewFile,BufRead *.t
                            	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif
                            
                            " Tags
    1              0.000025 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    1              0.000030 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    1              0.000028 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    1              0.000023 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    1              0.000114 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    1              0.000030 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    1              0.000040 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language
    1              0.000031 au BufRead,BufNewFile *.ttl			setf teraterm
                            
                            " Terminfo
    1              0.000023 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    1              0.000129 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    1              0.000031 au BufNewFile,BufRead *.tex			call s:FTtex()
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
    1              0.000003 func! s:FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'plain'
                                endif
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
                            " ConTeXt
    1              0.000067 au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
                            
                            " Texinfo
    1              0.000068 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    1              0.000023 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    1              0.000043 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    1              0.000070 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " TPP - Text Presentation Program
    1              0.000031 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    1              0.000022 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    1              0.000023 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    1              0.000023 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    1              0.000022 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    1              0.000022 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " Tutor mode
    1              0.000022 au BufNewFile,BufReadPost *.tutor		setf tutor
                            
                            " TWIG files
    1              0.000023 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
    1              0.000059 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    1              0.000025 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    1              0.000027 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    1              0.000029 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    1              0.000024 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    1              0.000024 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    1              0.000025 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    1              0.000025 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    1              0.000047 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    1              0.000046 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
    1              0.000029 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    1              0.000026 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    1              0.000078 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    1              0.000023 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    1              0.000045 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
    1              0.000052 au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
    1              0.000136 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    1              0.000023 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    1              0.000117 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    1              0.000042 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    1              0.000077 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    1              0.000032 au BufNewFile,BufRead *.frm			call s:FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    1              0.000032 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    1              0.000023 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    1              0.000031 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
    1              0.000023 au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Webmacro
    1              0.000024 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    1              0.000044 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    1              0.000032 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    1              0.000035 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    1              0.000024 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WvDial
    1              0.000043 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    1              0.000024 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    1              0.000024 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    1              0.000037 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    1              0.000023 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    1              0.000052 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    1              0.000011 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    1              0.000005 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    1              0.000030 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    1              0.000027 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    1              0.000045 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    1              0.000024 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    1              0.000026 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    1              0.000104 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    1              0.000062 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    1              0.000027 au BufNewFile,BufRead *.ms
                            	\ if !s:FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    1              0.000032 au BufNewFile,BufRead *.xml			call s:FTxml()
                            
    1              0.000004 func! s:FTxml()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
                            " XMI (holding UML models) is also XML
    1              0.000034 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    1              0.000042 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    1              0.000045 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    1              0.000034 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    1              0.000031 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    1              0.000024 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    1              0.000032 au BufNewFile,BufRead *.xlf			setf xml
    1              0.000025 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    1              0.000033 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    1              0.000023 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    1              0.000133 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    1              0.000033 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    1              0.000054 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    1              0.000085 au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
    1              0.000023 au BufNewFile,BufRead *.y			call s:FTy()
                            
    1              0.000003 func! s:FTy()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
                            
                            " Yaml
    1              0.000055 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
    1              0.000024 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    1              0.000025 au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
    1              0.000035 au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    1              0.000077 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
                            "   zsql (zope sql method)
    1              0.000026 au BufNewFile,BufRead *.zsql			call s:SQL()
                            
                            " Z80 assembler asz80
    1              0.000033 au BufNewFile,BufRead *.z8a			setf z8a
                            
    1              0.000002 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    1              0.000008 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    1              0.000002 augroup filetypedetect
    1              0.000026 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    1              0.000007 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
    1              0.000106 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    1              0.000131 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    1              0.000026 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    1              0.000028 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    1              0.000025 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " BIND zone
    1              0.000046 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    1              0.000072 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    1              0.000036 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    1              0.000068 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    1              0.000026 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    1              0.000048 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    1              0.000025 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    1              0.000047 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    1              0.000029 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    1              0.000024 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    1              0.000046 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    1              0.000048 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    1              0.000032 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    1              0.000025 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    1              0.000024 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    1              0.000027 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    1              0.000026 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    1              0.000024 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    1              0.000034 au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
                            " Modconf
    1              0.000030 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    1              0.000026 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    1              0.000049 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    1              0.000047 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Nroff macros
    1              0.000027 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " Pam conf
    1              0.000025 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    1              0.000028 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    1              0.000027 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    1              0.000035 au BufRead,BufNewFile *.rdf			call s:Redif()
    1              0.000004 func! s:Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            " Remind
    1              0.000026 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    1              0.000027 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    1              0.000027 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    1              0.000067 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    1              0.000028 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    1              0.000030 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    1              0.000025 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    1              0.000027 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    1              0.000025 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    1              0.000058 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    1              0.000079 au BufNewFile,BufRead *.txt,*.text,README	setf text
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    1              0.000407 runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    1              0.000002 augroup END
                            
                            " Generic configuration file (check this last, it's just guessing!)
    1              0.000033 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    1              0.000014 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    1              0.000004 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    1   0.000024   0.000023 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save

SCRIPT  /home/spiros/.config/nvim/plugins/neoterm/ftdetect/set_repl_cmd.vim
Sourced 1 time
Total time:   0.000293
 Self time:   0.000293

count  total (s)   self (s)
                            if has('nvim')
    1              0.000005   aug set_repl_cmd
    1              0.000081     au!
                                " Ruby and Rails
    1              0.000016     au FileType ruby,eruby
                                      \ if executable('bundle') && filereadable('config/application.rb') |
                                      \   call neoterm#repl#set('bundle exec rails console') |
                                      \ elseif executable(g:neoterm_repl_ruby) |
                                      \   call neoterm#repl#set(g:neoterm_repl_ruby) |
                                      \ end
                                " Python
    1              0.000015     au FileType python
                                      \ let s:argList = split(g:neoterm_repl_python) |
                                      \ if len(s:argList) > 0 && executable(s:argList[0]) |
                                      \   call neoterm#repl#set(g:neoterm_repl_python) |
                                      \ elseif executable('ipython') |
                                      \   call neoterm#repl#set('ipython --no-autoindent') |
                                      \ elseif executable('python') |
                                      \   call neoterm#repl#set('python') |
                                      \ end
                                " JavaScript
    1              0.000010     au FileType javascript
                                      \ if executable('node') |
                                      \   call neoterm#repl#set('node') |
                                      \ end
                                " Elixir
    1              0.000010     au FileType elixir
                                      \ if filereadable('config/config.exs') |
                                      \   call neoterm#repl#set('iex -S mix') |
                                      \ elseif &filetype == 'elixir' |
                                      \   call neoterm#repl#set('iex') |
                                      \ endif
                                " Julia
    1              0.000007     au FileType julia
                                      \ if executable('julia') |
                                      \   call neoterm#repl#set('julia') |
                                      \ end
                                " PARI/GP
    1              0.000007     au FileType gp
                                      \ if executable('gp') |
                                      \   call neoterm#repl#set('gp') |
                                      \ end
                                " R
    1              0.000008     au FileType r,rmd
                                      \ if executable('R') |
                                      \   call neoterm#repl#set('R') |
                                      \ end
                                " Octave
    1              0.000016     au FileType octave
                                      \ if executable('octave') |
                                      \   if executable('octave-cli') |
                                      \     if g:neoterm_repl_octave_qt |
                                      \       call neoterm#repl#set('octave --no-gui') |
                                      \     else |
                                      \       call neoterm#repl#set('octave-cli') |
                                      \     end |
                                      \   else |
                                      \     call neoterm#repl#set('octave') |
                                      \   end |
                                      \ end
                                " MATLAB
    1              0.000008     au FileType matlab
                                      \ if executable('matlab') |
                                      \   call neoterm#repl#set('matlab -nodesktop -nosplash') |
                                      \ end
                                " Idris
    1              0.000009     au FileType idris,lidris
                                      \ if executable('idris') |
                                      \   call neoterm#repl#set('idris') |
                                      \ end
                                " Haskell
    1              0.000010     au FileType haskell
                                      \ if executable('stack') |
                                      \ call neoterm#repl#set('stack ghci') |
                                      \ elseif executable('ghci') |
                                      \   call neoterm#repl#set('ghci') |
                                      \ end
    1              0.000014     au FileType php
                                      \ let s:argList = split(g:neoterm_repl_php) |
                                      \ if len(s:argList) > 0 && executable(s:argList[0]) |
                                      \   call neoterm#repl#set(g:neoterm_repl_php) |
                                      \ elseif executable('psysh') |
                                      \   call neoterm#repl#set('psysh') |
                                      \ elseif executable('php') |
                                      \   call neoterm#repl#set('php -a') |
                                      \ end
                                " Clojure
    1              0.000009     au FileType clojure
                                      \ if executable('lein') |
                                      \   call neoterm#repl#set('lein repl') |
                                      \ end
                                " Lua
    1              0.000013     au FileType lua
                                      \ if executable('luap') |
                                      \   let s:lua_repl='luap' |
                                      \ elseif executable('lua') |
                                      \   let s:lua_repl='lua' |
                                      \ endif |
                                      \ if executable('luarocks') && exists('s:lua_repl') |
                                      \   call neoterm#repl#set(s:lua_repl . ' -l"luarocks.require"') |
                                      \ endif
                                " TCL
    1              0.000008     au FileType tcl
                                      \ if executable('tclsh') |
                                      \   call neoterm#repl#set('tclsh') |
                                      \ endif
                                " Standard ML (SML)
    1              0.000010     au FileType sml
                                      \ if executable('sml') |
                                      \   if executable('rlwrap') |
                                      \     call neoterm#repl#set('rlwrap sml') |
                                      \   else |
                                      \     call neoterm#repl#set('sml') |
                                      \   endif |
                                      \ endif
    1              0.000002   aug END
    1              0.000003 end

SCRIPT  /home/spiros/.config/nvim/plugins/ultisnips/ftdetect/snippets.vim
Sourced 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                            " recognize .snippet files
    1              0.000005 if has("autocmd")
    1              0.000028     autocmd BufNewFile,BufRead *.snippets setf snippets
    1              0.000003 endif

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby/ftdetect/ruby.vim
Sourced 1 time
Total time:   0.000433
 Self time:   0.000433

count  total (s)   self (s)
                            " Officially distributed filetypes
                            
                            " Support functions {{{
    1              0.000006 function! s:setf(filetype) abort
                              if &filetype !~# '\<'.a:filetype.'\>'
                                let &filetype = a:filetype
                              endif
                            endfunction
                            
    1              0.000003 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            " }}}
                            
                            " HTML with Ruby - eRuby
    1              0.000044 au BufNewFile,BufRead *.erb,*.rhtml				call s:setf('eruby')
                            
                            " Interactive Ruby shell
    1              0.000043 au BufNewFile,BufRead .irbrc,irbrc				call s:setf('ruby')
                            
                            " Ruby
    1              0.000063 au BufNewFile,BufRead *.rb,*.rbw,*.gemspec			call s:setf('ruby')
                            
                            " Rackup
    1              0.000023 au BufNewFile,BufRead *.ru					call s:setf('ruby')
                            
                            " Bundler
    1              0.000023 au BufNewFile,BufRead Gemfile					call s:setf('ruby')
                            
                            " Ruby on Rails
    1              0.000080 au BufNewFile,BufRead *.builder,*.rxml,*.rjs,*.ruby		call s:setf('ruby')
                            
                            " Rakefile
    1              0.000045 au BufNewFile,BufRead [rR]akefile,*.rake			call s:setf('ruby')
    1              0.000024 au BufNewFile,BufRead [rR]akefile*				call s:StarSetf('ruby')
                            
                            " Rantfile
    1              0.000045 au BufNewFile,BufRead [rR]antfile,*.rant			call s:setf('ruby')
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby/ftdetect/ruby_extra.vim
Sourced 1 time
Total time:   0.000566
 Self time:   0.000566

count  total (s)   self (s)
                            " All other filetypes
                            
                            " Support functions {{{
    1              0.000004 function! s:setf(filetype) abort
                              if &filetype !=# a:filetype
                                let &filetype = a:filetype
                              endif
                            endfunction
                            " }}}
                            
                            " Appraisal
    1              0.000026 au BufNewFile,BufRead Appraisals		call s:setf('ruby')
                            
                            " Autotest
    1              0.000024 au BufNewFile,BufRead .autotest			call s:setf('ruby')
                            
                            " Buildr Buildfile
    1              0.000024 au BufNewFile,BufRead [Bb]uildfile		call s:setf('ruby')
                            
                            " Capistrano
    1              0.000043 au BufNewFile,BufRead Capfile,*.cap		call s:setf('ruby')
                            
                            " Chef
    1              0.000023 au BufNewFile,BufRead Cheffile			call s:setf('ruby')
    1              0.000024 au BufNewFile,BufRead Berksfile			call s:setf('ruby')
                            
                            " CocoaPods
    1              0.000045 au BufNewFile,BufRead Podfile,*.podspec		call s:setf('ruby')
                            
                            " Guard
    1              0.000044 au BufNewFile,BufRead Guardfile,.Guardfile	call s:setf('ruby')
                            
                            " Jbuilder
    1              0.000025 au BufNewFile,BufRead *.jbuilder		call s:setf('ruby')
                            
                            " Kitchen Sink
    1              0.000024 au BufNewFile,BufRead KitchenSink		call s:setf('ruby')
                            
                            " Opal
    1              0.000024 au BufNewFile,BufRead *.opal			call s:setf('ruby')
                            
                            " Pry config
    1              0.000025 au BufNewFile,BufRead .pryrc			call s:setf('ruby')
                            
                            " Puppet librarian
    1              0.000026 au BufNewFile,BufRead Puppetfile		call s:setf('ruby')
                            
                            " Rabl
    1              0.000025 au BufNewFile,BufRead *.rabl			call s:setf('ruby')
                            
                            " Routefile
    1              0.000024 au BufNewFile,BufRead [rR]outefile		call s:setf('ruby')
                            
                            " SimpleCov
    1              0.000024 au BufNewFile,BufRead .simplecov		call s:setf('ruby')
                            
                            " Thor
    1              0.000046 au BufNewFile,BufRead [tT]horfile,*.thor	call s:setf('ruby')
                            
                            " Vagrant
    1              0.000027 au BufNewFile,BufRead [vV]agrantfile		call s:setf('ruby')
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /home/spiros/.config/nvim/plugins/vim-haml/ftdetect/haml.vim
Sourced 1 time
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
                            autocmd BufNewFile,BufRead *.haml,*.hamlbars,*.hamlc setf haml
    1              0.000025 autocmd BufNewFile,BufRead *.sass setf sass
    1              0.000027 autocmd BufNewFile,BufRead *.scss setf scss

SCRIPT  /home/spiros/.config/nvim/plugins/scss-syntax.vim/ftdetect/scss.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            au BufRead,BufNewFile *.scss setfiletype scss
    1              0.000008 au BufEnter *.scss :syntax sync fromstart

SCRIPT  /home/spiros/.config/nvim/plugins/vim-elixir/ftdetect/elixir.vim
Sourced 1 time
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
                            au BufRead,BufNewFile *.ex,*.exs call s:setf('elixir')
    1              0.000025 au BufRead,BufNewFile *.eex call s:setf('eelixir')
    1              0.000023 au BufRead,BufNewFile * call s:DetectElixir()
                            
    1              0.000005 function! s:setf(filetype) abort
                              let &filetype = a:filetype
                            endfunction
                            
    1              0.000003 function! s:DetectElixir()
                              if getline(1) =~ '^#!.*\<elixir\>'
                                call s:setf('elixir')
                              endif
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/elm.vim/ftdetect/elm.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)

SCRIPT  /home/spiros/.config/nvim/plugins/vim-markdown/ftdetect/markdown.vim
Sourced 1 time
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)

SCRIPT  /home/spiros/.config/nvim/plugins/vim-git/ftdetect/git.vim
Sourced 1 time
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
                            " Git
    1              0.000043 autocmd BufNewFile,BufRead *.git/{,modules/**/,worktrees/*/}{COMMIT_EDIT,TAG_EDIT,MERGE_,}MSG set ft=gitcommit
    1              0.000092 autocmd BufNewFile,BufRead *.git/config,.gitconfig,gitconfig,.gitmodules set ft=gitconfig
    1              0.000027 autocmd BufNewFile,BufRead */.config/git/config                          set ft=gitconfig
    1              0.000027 autocmd BufNewFile,BufRead *.git/modules/**/config                       set ft=gitconfig
    1              0.000026 autocmd BufNewFile,BufRead git-rebase-todo                               set ft=gitrebase
    1              0.000025 autocmd BufNewFile,BufRead .gitsendemail.*                               set ft=gitsendemail
    1              0.000028 autocmd BufNewFile,BufRead *.git/**
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   set ft=git |
                                  \ endif
                            
                            " This logic really belongs in scripts.vim
    1              0.000029 autocmd BufNewFile,BufRead,StdinReadPost *
                                  \ if getline(1) =~ '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$' |
                                  \   set ft=git |
                                  \ endif
    1              0.000027 autocmd BufNewFile,BufRead *

SCRIPT  /home/spiros/.config/nvim/plugins/dockerfile.vim/ftdetect/dockerfile.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)

SCRIPT  /home/spiros/.config/nvim/plugins/vim-pug/ftdetect/pug.vim
Sourced 1 time
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
                            " Pug
    1              0.000041 autocmd BufNewFile,BufReadPost *.pug set filetype=pug
                            
                            " Jade
    1              0.000041 autocmd BufNewFile,BufReadPost *.jade set filetype=pug

SCRIPT  /home/spiros/.config/nvim/plugins/vim-slim/ftdetect/slim.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)

SCRIPT  /usr/share/nvim/runtime/ftplugin.vim
Sourced 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    2              0.000012 if exists("did_load_ftplugin")
    2              0.000004   finish

SCRIPT  /usr/share/nvim/runtime/indent.vim
Sourced 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    2              0.000010 if exists("did_indent_on")
    2              0.000003   finish

SCRIPT  /usr/share/nvim/runtime/syntax/syncolor.vim
Sourced 2 times
Total time:   0.001706
 Self time:   0.001706

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    2              0.000015 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    1              0.000015   command -nargs=* SynColor hi <args>
    1              0.000007   command -nargs=* SynLink hi link <args>
    1              0.000001 else
    1              0.000003   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
                                command -nargs=* SynColor hi def <args>
                                command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    1              0.000008     command -nargs=* SynColor hi <args>
    1              0.000007     command -nargs=* SynLink hi! link <args>
    1              0.000001   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    1              0.000001 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    2              0.000006 if &background == "dark"
    2              0.000046   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    2              0.000038   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    2              0.000053   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    2              0.000035   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    2              0.000035   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    2              0.000035   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    2              0.000035   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    2              0.000033   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    2              0.000034   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    2              0.000004 else
                              SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
                              SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            endif
    2              0.000076 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    2              0.000060 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    2              0.000044 SynLink String		Constant
    2              0.000044 SynLink Character	Constant
    2              0.000044 SynLink Number		Constant
    2              0.000043 SynLink Boolean		Constant
    2              0.000043 SynLink Float		Number
    2              0.000044 SynLink Function	Identifier
    2              0.000043 SynLink Conditional	Statement
    2              0.000043 SynLink Repeat		Statement
    2              0.000043 SynLink Label		Statement
    2              0.000043 SynLink Operator	Statement
    2              0.000043 SynLink Keyword		Statement
    2              0.000043 SynLink Exception	Statement
    2              0.000043 SynLink Include		PreProc
    2              0.000043 SynLink Define		PreProc
    2              0.000043 SynLink Macro		PreProc
    2              0.000043 SynLink PreCondit	PreProc
    2              0.000044 SynLink StorageClass	Type
    2              0.000043 SynLink Structure	Type
    2              0.000043 SynLink Typedef		Type
    2              0.000043 SynLink Tag		Special
    2              0.000043 SynLink SpecialChar	Special
    2              0.000043 SynLink Delimiter	Special
    2              0.000044 SynLink SpecialComment	Special
    2              0.000043 SynLink Debug		Special
                            
    2              0.000007 delcommand SynColor
    2              0.000008 delcommand SynLink

SCRIPT  /home/spiros/dotfiles/neovim/colors/Tomorrow-Night.vim
Sourced 1 time
Total time:   0.056929
 Self time:   0.004319

count  total (s)   self (s)
                            " Tomorrow Night - Full Colour and 256 Colour
                            " http://chriskempson.com
                            "
                            " Hex colour conversion functions borrowed from the theme "Desert256""
                            
                            " Default GUI Colours
    1              0.000005 let s:foreground = "c5c8c6"
    1              0.000003 let s:background = "1d1f21"
    1              0.000002 let s:selection = "373b41"
    1              0.000002 let s:line = "282a2e"
    1              0.000002 let s:comment = "969896"
    1              0.000002 let s:red = "cc6666"
    1              0.000002 let s:orange = "de935f"
    1              0.000002 let s:yellow = "f0c674"
    1              0.000002 let s:green = "b5bd68"
    1              0.000002 let s:aqua = "8abeb7"
    1              0.000002 let s:blue = "81a2be"
    1              0.000002 let s:purple = "b294bb"
    1              0.000002 let s:window = "4d5057"
                            
                            " Console 256 Colours
    1              0.000007 if !has("gui_running")
    1              0.000003 	let s:background = "303030"
    1              0.000002 	let s:window = "5e5e5e"
    1              0.000002 	let s:line = "3a3a3a"
    1              0.000002 	let s:selection = "585858"
    1              0.000001 end
                            
    1   0.000009   0.000006 set background=dark
    1              0.001323 hi clear
    1              0.000491 syntax reset
                            
    1              0.000005 let g:colors_name = "Tomorrow-Night"
                            
    1              0.000008 if has("gui_running") || &t_Co == 88 || &t_Co == 256
                            	" Returns an approximate grey index for the given grey level
    1              0.000005 	fun <SID>grey_number(x)
                            		if &t_Co == 88
                            			if a:x < 23
                            				return 0
                            			elseif a:x < 69
                            				return 1
                            			elseif a:x < 103
                            				return 2
                            			elseif a:x < 127
                            				return 3
                            			elseif a:x < 150
                            				return 4
                            			elseif a:x < 173
                            				return 5
                            			elseif a:x < 196
                            				return 6
                            			elseif a:x < 219
                            				return 7
                            			elseif a:x < 243
                            				return 8
                            			else
                            				return 9
                            			endif
                            		else
                            			if a:x < 14
                            				return 0
                            			else
                            				let l:n = (a:x - 8) / 10
                            				let l:m = (a:x - 8) % 10
                            				if l:m < 5
                            					return l:n
                            				else
                            					return l:n + 1
                            				endif
                            			endif
                            		endif
                            	endfun
                            
                            	" Returns the actual grey level represented by the grey index
    1              0.000004 	fun <SID>grey_level(n)
                            		if &t_Co == 88
                            			if a:n == 0
                            				return 0
                            			elseif a:n == 1
                            				return 46
                            			elseif a:n == 2
                            				return 92
                            			elseif a:n == 3
                            				return 115
                            			elseif a:n == 4
                            				return 139
                            			elseif a:n == 5
                            				return 162
                            			elseif a:n == 6
                            				return 185
                            			elseif a:n == 7
                            				return 208
                            			elseif a:n == 8
                            				return 231
                            			else
                            				return 255
                            			endif
                            		else
                            			if a:n == 0
                            				return 0
                            			else
                            				return 8 + (a:n * 10)
                            			endif
                            		endif
                            	endfun
                            
                            	" Returns the palette index for the given grey index
    1              0.000003 	fun <SID>grey_colour(n)
                            		if &t_Co == 88
                            			if a:n == 0
                            				return 16
                            			elseif a:n == 9
                            				return 79
                            			else
                            				return 79 + a:n
                            			endif
                            		else
                            			if a:n == 0
                            				return 16
                            			elseif a:n == 25
                            				return 231
                            			else
                            				return 231 + a:n
                            			endif
                            		endif
                            	endfun
                            
                            	" Returns an approximate colour index for the given colour level
    1              0.000003 	fun <SID>rgb_number(x)
                            		if &t_Co == 88
                            			if a:x < 69
                            				return 0
                            			elseif a:x < 172
                            				return 1
                            			elseif a:x < 230
                            				return 2
                            			else
                            				return 3
                            			endif
                            		else
                            			if a:x < 75
                            				return 0
                            			else
                            				let l:n = (a:x - 55) / 40
                            				let l:m = (a:x - 55) % 40
                            				if l:m < 20
                            					return l:n
                            				else
                            					return l:n + 1
                            				endif
                            			endif
                            		endif
                            	endfun
                            
                            	" Returns the actual colour level for the given colour index
    1              0.000003 	fun <SID>rgb_level(n)
                            		if &t_Co == 88
                            			if a:n == 0
                            				return 0
                            			elseif a:n == 1
                            				return 139
                            			elseif a:n == 2
                            				return 205
                            			else
                            				return 255
                            			endif
                            		else
                            			if a:n == 0
                            				return 0
                            			else
                            				return 55 + (a:n * 40)
                            			endif
                            		endif
                            	endfun
                            
                            	" Returns the palette index for the given R/G/B colour indices
    1              0.000003 	fun <SID>rgb_colour(x, y, z)
                            		if &t_Co == 88
                            			return 16 + (a:x * 16) + (a:y * 4) + a:z
                            		else
                            			return 16 + (a:x * 36) + (a:y * 6) + a:z
                            		endif
                            	endfun
                            
                            	" Returns the palette index to approximate the given R/G/B colour levels
    1              0.000004 	fun <SID>colour(r, g, b)
                            		" Get the closest grey
                            		let l:gx = <SID>grey_number(a:r)
                            		let l:gy = <SID>grey_number(a:g)
                            		let l:gz = <SID>grey_number(a:b)
                            
                            		" Get the closest colour
                            		let l:x = <SID>rgb_number(a:r)
                            		let l:y = <SID>rgb_number(a:g)
                            		let l:z = <SID>rgb_number(a:b)
                            
                            		if l:gx == l:gy && l:gy == l:gz
                            			" There are two possibilities
                            			let l:dgr = <SID>grey_level(l:gx) - a:r
                            			let l:dgg = <SID>grey_level(l:gy) - a:g
                            			let l:dgb = <SID>grey_level(l:gz) - a:b
                            			let l:dgrey = (l:dgr * l:dgr) + (l:dgg * l:dgg) + (l:dgb * l:dgb)
                            			let l:dr = <SID>rgb_level(l:gx) - a:r
                            			let l:dg = <SID>rgb_level(l:gy) - a:g
                            			let l:db = <SID>rgb_level(l:gz) - a:b
                            			let l:drgb = (l:dr * l:dr) + (l:dg * l:dg) + (l:db * l:db)
                            			if l:dgrey < l:drgb
                            				" Use the grey
                            				return <SID>grey_colour(l:gx)
                            			else
                            				" Use the colour
                            				return <SID>rgb_colour(l:x, l:y, l:z)
                            			endif
                            		else
                            			" Only one possibility
                            			return <SID>rgb_colour(l:x, l:y, l:z)
                            		endif
                            	endfun
                            
                            	" Returns the palette index to approximate the 'rrggbb' hex string
    1              0.000003 	fun <SID>rgb(rgb)
                            		let l:r = ("0x" . strpart(a:rgb, 0, 2)) + 0
                            		let l:g = ("0x" . strpart(a:rgb, 2, 2)) + 0
                            		let l:b = ("0x" . strpart(a:rgb, 4, 2)) + 0
                            
                            		return <SID>colour(l:r, l:g, l:b)
                            	endfun
                            
                            	" Sets the highlighting for the given group
    1              0.000003 	fun <SID>X(group, fg, bg, attr)
                            		if a:fg != ""
                            			exec "hi " . a:group . " guifg=#" . a:fg . " ctermfg=" . <SID>rgb(a:fg)
                            		endif
                            		if a:bg != ""
                            			exec "hi " . a:group . " guibg=#" . a:bg . " ctermbg=" . <SID>rgb(a:bg)
                            		endif
                            		if a:attr != ""
                            			exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
                            		endif
                            	endfun
                            
                            	" Vim Highlighting
    1   0.001952   0.000014 	call <SID>X("Normal", s:foreground, s:background, "")
    1   0.000559   0.000010 	call <SID>X("LineNr", s:selection, "", "")
    1   0.000566   0.000018 	call <SID>X("NonText", s:selection, "", "")
    1   0.000552   0.000008 	call <SID>X("SpecialKey", s:selection, "", "")
    1   0.000863   0.000008 	call <SID>X("Search", s:background, s:yellow, "")
    1   0.001050   0.000009 	call <SID>X("TabLine", s:foreground, s:background, "reverse")
    1   0.000913   0.000009 	call <SID>X("StatusLine", s:window, s:yellow, "reverse")
    1   0.001150   0.000010 	call <SID>X("StatusLineNC", s:window, s:foreground, "reverse")
    1   0.001109   0.000010 	call <SID>X("VertSplit", s:window, s:window, "none")
    1   0.000551   0.000009 	call <SID>X("Visual", "", s:selection, "")
    1   0.000363   0.000008 	call <SID>X("Directory", s:blue, "", "")
    1   0.000362   0.000008 	call <SID>X("ModeMsg", s:green, "", "")
    1   0.000373   0.000008 	call <SID>X("MoreMsg", s:green, "", "")
    1   0.000382   0.000008 	call <SID>X("Question", s:green, "", "")
    1   0.000363   0.000008 	call <SID>X("WarningMsg", s:red, "", "")
    1   0.000545   0.000008 	call <SID>X("MatchParen", "", s:selection, "")
    1   0.001016   0.000008 	call <SID>X("Folded", s:comment, s:background, "")
    1   0.000503   0.000008 	call <SID>X("FoldColumn", "", s:background, "")
    1              0.000003 	if version >= 700
    1   0.000515   0.000008 		call <SID>X("CursorLine", "", s:line, "none")
    1   0.000521   0.000009 		call <SID>X("CursorColumn", "", s:line, "none")
    1   0.001139   0.000010 		call <SID>X("PMenu", s:foreground, s:selection, "none")
    1   0.001074   0.000010 		call <SID>X("PMenuSel", s:foreground, s:selection, "reverse")
    1   0.000519   0.000008 		call <SID>X("SignColumn", "", s:background, "none")
    1              0.000002 	end
    1              0.000002 	if version >= 703
    1   0.000523   0.000009 		call <SID>X("ColorColumn", "", s:line, "none")
    1              0.000002 	end
                            
                            	" Standard Highlighting
    1   0.000541   0.000007 	call <SID>X("Comment", s:comment, "", "")
    1   0.001032   0.000008 	call <SID>X("Todo", s:comment, s:background, "")
    1   0.000539   0.000009 	call <SID>X("Title", s:comment, "", "")
    1   0.000382   0.000008 	call <SID>X("Identifier", s:red, "", "none")
    1   0.000575   0.000009 	call <SID>X("Statement", s:foreground, "", "")
    1   0.000551   0.000008 	call <SID>X("Conditional", s:foreground, "", "")
    1   0.000552   0.000008 	call <SID>X("Repeat", s:foreground, "", "")
    1   0.000362   0.000008 	call <SID>X("Structure", s:purple, "", "")
    1   0.000365   0.000008 	call <SID>X("Function", s:blue, "", "")
    1   0.000387   0.000008 	call <SID>X("Constant", s:orange, "", "")
    1   0.000371   0.000008 	call <SID>X("String", s:green, "", "")
    1   0.000552   0.000009 	call <SID>X("Special", s:foreground, "", "")
    1   0.000358   0.000008 	call <SID>X("PreProc", s:purple, "", "")
    1   0.000379   0.000008 	call <SID>X("Operator", s:aqua, "", "none")
    1   0.000389   0.000008 	call <SID>X("Type", s:blue, "", "none")
    1   0.000380   0.000008 	call <SID>X("Define", s:purple, "", "none")
    1   0.000370   0.000008 	call <SID>X("Include", s:blue, "", "")
                            	"call <SID>X("Ignore", "666666", "", "")
                            
                            	" Vim Highlighting
    1   0.000381   0.000008 	call <SID>X("vimCommand", s:red, "", "none")
                            
                            	" C Highlighting
    1   0.000380   0.000008 	call <SID>X("cType", s:yellow, "", "")
    1   0.000393   0.000008 	call <SID>X("cStorageClass", s:purple, "", "")
    1   0.000363   0.000008 	call <SID>X("cConditional", s:purple, "", "")
    1   0.000368   0.000008 	call <SID>X("cRepeat", s:purple, "", "")
                            
                            	" PHP Highlighting
    1   0.000382   0.000011 	call <SID>X("phpVarSelector", s:red, "", "")
    1   0.000363   0.000008 	call <SID>X("phpKeyword", s:purple, "", "")
    1   0.000368   0.000008 	call <SID>X("phpRepeat", s:purple, "", "")
    1   0.000364   0.000008 	call <SID>X("phpConditional", s:purple, "", "")
    1   0.000359   0.000008 	call <SID>X("phpStatement", s:purple, "", "")
    1   0.000567   0.000008 	call <SID>X("phpMemberSelector", s:foreground, "", "")
                            
                            	" Ruby Highlighting
    1   0.000387   0.000008 	call <SID>X("rubySymbol", s:green, "", "")
    1   0.000395   0.000008 	call <SID>X("rubyConstant", s:yellow, "", "")
    1   0.000366   0.000008 	call <SID>X("rubyAttribute", s:blue, "", "")
    1   0.000366   0.000008 	call <SID>X("rubyInclude", s:blue, "", "")
    1   0.000371   0.000008 	call <SID>X("rubyLocalVariableOrMethod", s:orange, "", "")
    1   0.000378   0.000008 	call <SID>X("rubyCurlyBlock", s:orange, "", "")
    1   0.000392   0.000010 	call <SID>X("rubyStringDelimiter", s:green, "", "")
    1   0.000401   0.000011 	call <SID>X("rubyInterpolationDelimiter", s:orange, "", "")
    1   0.000397   0.000011 	call <SID>X("rubyConditional", s:purple, "", "")
    1   0.000419   0.000011 	call <SID>X("rubyRepeat", s:purple, "", "")
                            
                            	" Python Highlighting
    1   0.000465   0.000053 	call <SID>X("pythonInclude", s:purple, "", "")
    1   0.000516   0.000012 	call <SID>X("pythonStatement", s:purple, "", "")
    1   0.000508   0.000014 	call <SID>X("pythonConditional", s:purple, "", "")
    1   0.000454   0.000032 	call <SID>X("pythonRepeat", s:purple, "", "")
    1   0.000397   0.000012 	call <SID>X("pythonException", s:purple, "", "")
    1   0.000407   0.000011 	call <SID>X("pythonFunction", s:blue, "", "")
                            
                            	" Go Highlighting
    1   0.000397   0.000011 	call <SID>X("goStatement", s:purple, "", "")
    1   0.000423   0.000010 	call <SID>X("goConditional", s:purple, "", "")
    1   0.000417   0.000012 	call <SID>X("goRepeat", s:purple, "", "")
    1   0.000403   0.000012 	call <SID>X("goException", s:purple, "", "")
    1   0.000471   0.000012 	call <SID>X("goDeclaration", s:blue, "", "")
    1   0.000427   0.000013 	call <SID>X("goConstants", s:yellow, "", "")
    1   0.000412   0.000012 	call <SID>X("goBuiltins", s:orange, "", "")
                            
                            	" CoffeeScript Highlighting
    1   0.000420   0.000011 	call <SID>X("coffeeKeyword", s:purple, "", "")
    1   0.000415   0.000015 	call <SID>X("coffeeConditional", s:purple, "", "")
                            
                            	" JavaScript Highlighting
    1   0.000651   0.000013 	call <SID>X("javaScriptBraces", s:foreground, "", "")
    1   0.000433   0.000016 	call <SID>X("javaScriptFunction", s:purple, "", "")
    1   0.000411   0.000012 	call <SID>X("javaScriptConditional", s:purple, "", "")
    1   0.000539   0.000013 	call <SID>X("javaScriptRepeat", s:purple, "", "")
    1   0.000414   0.000011 	call <SID>X("javaScriptNumber", s:orange, "", "")
    1   0.000469   0.000009 	call <SID>X("javaScriptMember", s:orange, "", "")
                            
                            	" HTML Highlighting
    1   0.000368   0.000009 	call <SID>X("htmlTag", s:red, "", "")
    1   0.000371   0.000011 	call <SID>X("htmlTagName", s:red, "", "")
    1   0.000363   0.000008 	call <SID>X("htmlArg", s:red, "", "")
    1   0.000376   0.000008 	call <SID>X("htmlScriptTag", s:red, "", "")
                            
                            	" Diff Highlighting
    1              0.000005   let s:diffbackground = "494e56"
                            
    1   0.000378   0.000009 	call <SID>X("diffAdded", s:green, "", "")
    1   0.000457   0.000009 	call <SID>X("diffRemoved", s:red, "", "")
    1   0.000696   0.000009   call <SID>X("DiffAdd", s:green, s:diffbackground, "")
    1   0.000742   0.000009   call <SID>X("DiffDelete", s:red, s:diffbackground, "")
    1   0.000698   0.000009   call <SID>X("DiffChange", s:yellow, s:diffbackground, "")
    1   0.000717   0.000009   call <SID>X("DiffText", s:diffbackground, s:orange, "")
                            
                                " ShowMarks Highlighting
    1   0.000892   0.000011     call <SID>X("ShowMarksHLl", s:orange, s:background, "none")
    1   0.000914   0.000012     call <SID>X("ShowMarksHLo", s:purple, s:background, "none")
    1   0.000895   0.000016     call <SID>X("ShowMarksHLu", s:yellow, s:background, "none")
    1   0.000852   0.000009     call <SID>X("ShowMarksHLm", s:aqua, s:background, "none")
                            
                            	" Delete Functions
    1              0.000004 	delf <SID>X
    1              0.000003 	delf <SID>rgb
    1              0.000004 	delf <SID>colour
    1              0.000003 	delf <SID>rgb_colour
    1              0.000003 	delf <SID>rgb_level
    1              0.000004 	delf <SID>rgb_number
    1              0.000003 	delf <SID>grey_colour
    1              0.000003 	delf <SID>grey_level
    1              0.000004 	delf <SID>grey_number
    1              0.000008 endif

SCRIPT  /home/spiros/.config/nvim/plugins/tComment/plugin/tcomment.vim
Sourced 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            " tComment.vim -- An easily extensible & universal comment plugin 
                            " @Author:      Tom Link (micathom AT gmail com)
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Created:     27-Dez-2004.
                            " @Last Change: 2015-04-26.
                            " @Revision:    964
                            " GetLatestVimScripts: 1173 1 tcomment.vim
                            
    1              0.000012 if &cp || exists('loaded_tcomment')
    1              0.000002     finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-sneak/plugin/sneak.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            " sneak.vim - The missing motion
                            " Author:       Justin M. Keyes
                            " Version:      1.8
                            " License:      MIT
                            
    1              0.000007 if exists('g:loaded_sneak_plugin') || &compatible || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-move/plugin/move.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            " =============================================================================
                            " File: plugin/move.vim
                            " Description: Move lines and selections up and even down.
                            " Author: Matthias Vogelgesang <github.com/matze>
                            " =============================================================================
                            
    1              0.000006 if exists('loaded_move') || &cp
    1              0.000003     finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-pasta/plugin/pasta.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " pasta.vim - Pasting with indentation adjusted to paste destination"
                            " Author:     Marcin Kulik <http://ku1ik.com/>
                            " Version:    0.2
                            
    1              0.000007 if exists("g:loaded_pasta") || &cp || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/splitjoin.vim/plugin/splitjoin.vim
Sourced 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
                            if exists("g:loaded_splitjoin") || &cp
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-multiple-cursors/plugin/multiple_cursors.vim
Sourced 1 time
Total time:   0.000596
 Self time:   0.000313

count  total (s)   self (s)
                            "===============================================================================
                            " File: multiple_cursors.vim
                            " Author: Terry Ma
                            " Description: Emulate Sublime Text's multi selection feature
                            " Potential Features:
                            " - Create a blinking cursor effect? Good place to do it would be instead of
                            "   waiting for user input, cycle through the highlight
                            " - Integrate with the status line? Maybe show a special multicursor mode?
                            " - Support mouse? Ctrl/Cmd click to set cursor?
                            "===============================================================================
    1              0.000012 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000006 function! s:init_settings(settings)
                              for [key, value] in items(a:settings)
                                let sub = ''
                                if type(value) == 0
                                  let sub = '%d'
                                elseif type(value) == 1
                                  let sub = '"%s"'
                                endif
                                let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)",
                                      \ sub)
                                exec printf(fmt, key, key, value)
                              endfor
                            endfunction
                            
                            " Settings
    1              0.000013 let s:settings = {
                                  \ 'exit_from_visual_mode': 1,
                                  \ 'exit_from_insert_mode': 1,
                                  \ 'use_default_mapping': 1,
                                  \ 'debug_latency': 0,
                                  \ }
                            
    1              0.000008 let s:settings_if_default = {
                                  \ 'quit_key': '<Esc>',
                                  \ 'next_key': '<C-n>',
                                  \ 'prev_key': '<C-p>',
                                  \ 'skip_key': '<C-x>',
                                  \ }
                            
    1              0.000004 let s:default_insert_maps = {}
    1              0.000014 let s:default_normal_maps = {'!':1, '@':1, '=':1, 'q':1, 'r':1, 't':1, 'T':1, 'y':1, '[':1, ']':1, '\':1, 'd':1, 'f':1, 'F':1, 'g':1, '"':1, 'z':1, 'c':1, 'm':1, '<':1, '>':1}
    1              0.000006 let s:default_visual_maps = {'i':1, 'a':1, 'f':1, 'F':1, 't':1, 'T':1}
                            
    1              0.000008 let g:multi_cursor_insert_maps =
                                  \ get(g:, 'multi_cursor_insert_maps', s:default_insert_maps)
    1              0.000006 let g:multi_cursor_normal_maps =
                                  \ get(g:, 'multi_cursor_normal_maps', s:default_normal_maps)
    1              0.000006 let g:multi_cursor_visual_maps =
                                  \ get(g:, 'multi_cursor_visual_maps', s:default_visual_maps)
                            
    1   0.000160   0.000012 call s:init_settings(s:settings)
                            
    1              0.000003 if g:multi_cursor_use_default_mapping
    1   0.000142   0.000007   call s:init_settings(s:settings_if_default)
    1              0.000002 endif
                            
    1              0.000005 if !exists('g:multi_cursor_start_word_key')
                              if exists('g:multi_cursor_start_key')
                                let g:multi_cursor_start_word_key = g:multi_cursor_start_key
                              elseif exists('g:multi_cursor_next_key')
                                let g:multi_cursor_start_word_key = g:multi_cursor_next_key
                              endif
                            endif
                            
                            " External mappings
    1              0.000004 if exists('g:multi_cursor_start_key')
                              exec 'nnoremap <silent> '.g:multi_cursor_start_key.
                                    \' :call multiple_cursors#new("n", 0)<CR>'
                              exec 'xnoremap <silent> '.g:multi_cursor_start_key.
                                    \' :<C-u>call multiple_cursors#new("v", 0)<CR>'
                            endif
                            
    1              0.000004 if exists('g:multi_cursor_start_word_key')
    1              0.000063   exec 'nnoremap <silent> '.g:multi_cursor_start_word_key.
                                    \' :call multiple_cursors#new("n", 1)<CR>'
                              " In Visual mode word boundary is not used
    1              0.000026   exec 'xnoremap <silent> '.g:multi_cursor_start_word_key.
                                    \' :<C-u>call multiple_cursors#new("v", 0)<CR>'
    1              0.000002 endif
                            
                            " Commands
    1              0.000019 command! -nargs=1 -range=% MultipleCursorsFind
                                  \ call multiple_cursors#find(<line1>, <line2>, <q-args>)
                            
    1   0.000014   0.000013 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/spiros/.config/nvim/plugins/CamelCaseMotion/plugin/camelcasemotion.vim
Sourced 1 time
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
                            " camelcasemotion.vim: Motion through CamelCaseWords and underscore_notation.
                            "
                            " DEPENDENCIES:
                            "   - Requires Vim 7.0 or higher.
                            "
                            " Copyright: (C) 2007-2009 by Ingo Karkat
                            "   The VIM LICENSE applies to this script; see ':help copyright'.
                            "
                            " Source: Based on vimtip #1016 by Anthony Van Ham.
                            " Maintainer:  Ingo Karkat <ingo@karkat.de>
                            " REVISION  DATE    REMARKS
                            "   1.50.019  05-May-2009  Do not create mappings for select mode;
                            "        according to|Select-mode|, printable character
                            "        commands should delete the selection and insert
                            "        the typed characters.
                            "           Moved functions from plugin to separate autoload
                            "        script.
                            "           Split off documentation into separate help file.
                            "           Now cleaning up Create...Mappings functions.
                            "   1.40.018  30-Jun-2008  Minor: Removed unnecessary <script> from
                            "        mappings.
                            "   1.40.017  19-May-2008  BF: Now using :normal! to be independent from
                            "        any user mappings. Thanks to Neil Walker for the
                            "        patch.
                            "   1.40.016  28-Apr-2008  BF: Wrong forward motion stop at the second
                            "        digit if a word starts with multiple numbers
                            "        (e.g. 1234.56789). Thanks to Wasim Ahmed for
                            "        reporting this.
                            "   1.40.015  24-Apr-2008  ENH: Added inner "word" text objects 'i,w' etc.
                            "        that work analogous to the built-in 'iw' text
                            "        object. Thanks to David Kotchan for this
                            "        suggestion.
                            "   1.30.014  20-Apr-2008  The motions now also stop at non-keyword
                            "        boundaries, just like the regular motions. This
                            "        has no effect inside a CamelCaseWord or inside
                            "        underscore_notation, but it makes the motions
                            "        behave like the regular motions (which is
                            "        important if you replace the default motions).
                            "        Thanks to Mun Johl for reporting this.
                            "        Now using non-capturing parentheses \%() in the
                            "        patterns.
                            "   1.30.013  09-Apr-2008  Refactored away s:VisualCamelCaseMotion().
                            "        Allowing users to use mappings different than
                            "        ,w ,b ,e by defining <Plug>CamelCaseMotion_?
                            "        target mappings. This can even be used to
                            "        replace the default 'w', 'b' and 'e' mappings,
                            "        as suggested by Mun Johl.
                            "        Mappings are now created in a generic function.
                            "        Now requires Vim 7.0 or higher.
                            "   1.20.012  02-Jun-2007  BF: Corrected motions through mixed
                            "        CamelCase_and_UnderScore words by re-ordering
                            "        and narrowing the search patterns.
                            "   1.20.011  02-Jun-2007  Thanks again to Joseph Barker for discussing the
                            "        complicated visual mode mapping on the vim-dev
                            "        mailing list and coming up with a great
                            "        simplification:
                            "        Removed s:CheckForChangesToTheSelectionSetting().
                            "        Introduced s:VisualCamelCaseMotion(), which
                            "        handles the differences depending on the
                            "        'selection' setting.
                            "        Visual mode mappings now directly map to the
                            "        s:VisualCamelCaseMotion() function; no mark is
                            "        clobbered, the complex mapping with the inline
                            "        expression has been retired.
                            "   1.20.010  29-May-2007  BF: The operator-pending and visual mode ,e
                            "        mapping doesn't work properly when it reaches
                            "        the end of line; the final character of the
                            "        moved-over "word" remains. Fixed this problem
                            "        unless the "word" is at the very end of the
                            "        buffer.
                            "        ENH: The visual mode motions now also (mostly)
                            "        work with the (default) setting
                            "        'set selection=inclusive', instead of selecting
                            "        one character too much.
                            "        ENH: All mappings will check for changes to the
                            "        'selection' setting and remap the visual mode
                            "        mappings via function
                            "        s:SetupVisualModeMappings(). We cannot rely on
                            "        the setting while sourcing camelcasemotion.vim
                            "        because the mswin.vim script may be sourced
                            "        afterwards, and its 'behave mswin' changes
                            "        'selection'.
                            "        Refactored the arguments of function
                            "        s:CamelCaseMotion(...).
                            "   1.10.009  28-May-2007  BF: Degenerate CamelCaseWords that consist of
                            "        only a single uppercase letter (e.g. "P" in
                            "        "MapPRoblem") are skipped by all motions. Thanks
                            "        to Joseph Barker for reporting this.
                            "        BF: In CamelCaseWords that consist of uppercase
                            "        letters followed by decimals (e.g.
                            "        "MyUPPER123Problem", the uppercase "word" is
                            "        skipped by all motions.
                            "   1.10.008  28-May-2007  Incorporated major improvements and
                            "        simplifications done by Joseph Barker:
                            "        Operator-pending and visual mode motions now
                            "        accept [count] of more than 9.
                            "        Visual selections can now be extended from
                            "        either end.
                            "        Instead of misusing the :[range], the special
                            "        variable v:count1 is used. Custom commands are
                            "        not needed anymore.
                            "        Operator-pending and visual mode mappings are
                            "        now generic: There's only a single mapping for
                            "        ,w that can be repeated, rather than having a
                            "        separate mapping for 1,w 2,w 3,w ...
                            "   1.00.007  22-May-2007  Added documentation for publication.
                            "  006  20-May-2007  BF: visual mode [1,2,3],e on pure CamelCase
                            "        mistakenly marks [2,4,6] words. If the cursor is
                            "        on a uppercase letter, the search pattern
                            "        '\u\l\+' doesn't match at the cursor position,
                            "        so another match won. Changed search pattern
                            "        from '\l\+',
                            "  005  16-May-2007  Added support for underscore notation.
                            "        Added support for "forward to end of word"
                            "        (',e') motion.
                            "  004  16-May-2007  Improved search pattern so that
                            "        UppercaseWORDSInBetween and digits are handled,
                            "        too.
                            "  003  15-May-2007  Changed mappings from <Leader>w to ,w;
                            "        other \w mappings interfere here, because it's
                            "        irritating when the cursor jump doesn't happen
                            "        immediately, because Vim waits whether the
                            "        mapping is complete. ,w is faster to type that
                            "        \w (and, because of the left-right touch,
                            "        preferred over gw).
                            "        Added visual mode mappings.
                            "  0.02  15-Feb-2006  BF: missing <SID> for omaps.
                            "  0.01  11-Oct-2005  file creation
                            
                            " Avoid installing twice or when in compatible mode
    1              0.000007 if exists('g:loaded_camelcasemotion') || (v:version < 700)
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-textobj-rubyblock/plugin/textobj/rubyblock.vim
Sourced 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
                            if exists('g:loaded_textobj_rubyblock')  "{{{1
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-expand-region/plugin/expand_region.vim
Sourced 1 time
Total time:   0.000237
 Self time:   0.000216

count  total (s)   self (s)
                            " ==============================================================================
                            " File: expand_region.vim
                            " Author: Terry Ma
                            " Description: Incrementally select larger regions of text in visual mode by
                            " repeating the same key combination
                            " Last Modified: March 30, 2013
                            " ==============================================================================
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
                            " Init global vars
    1   0.000021   0.000012 call expand_region#init()
                            
                            " ==============================================================================
                            " Mappings
                            " ==============================================================================
    1              0.000020 if !hasmapto('<Plug>(expand_region_expand)')
                              nmap + <Plug>(expand_region_expand)
                              vmap + <Plug>(expand_region_expand)
                            endif
    1              0.000034 if !hasmapto('<Plug>(expand_region_shrink)')
                              vmap _ <Plug>(expand_region_shrink)
                              nmap _ <Plug>(expand_region_shrink)
                            endif
                            
    1              0.000026 nnoremap <silent> <Plug>(expand_region_expand)
                                  \ :<C-U>call expand_region#next('n', '+')<CR>
                            " Map keys differently depending on which mode is desired
    1   0.000025   0.000014 if expand_region#use_select_mode()
                              snoremap <silent> <Plug>(expand_region_expand)
                                    \ :<C-U>call expand_region#next('v', '+')<CR>
                              snoremap <silent> <Plug>(expand_region_shrink)
                                    \ :<C-U>call expand_region#next('v', '-')<CR>
                            else
    1              0.000022   xnoremap <silent> <Plug>(expand_region_expand)
                                    \ :<C-U>call expand_region#next('v', '+')<CR>
    1              0.000020   xnoremap <silent> <Plug>(expand_region_shrink)
                                    \ :<C-U>call expand_region#next('v', '-')<CR>
    1              0.000001 endif
                            
    1   0.000013   0.000012 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo

SCRIPT  /home/spiros/.config/nvim/plugins/vim-rhubarb/plugin/rhubarb.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " rhubarb.vim - fugitive.vim extension for GitHub
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
    1              0.000006 if exists("g:loaded_rhubarb") || v:version < 700 || &cp
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-surround/plugin/surround.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " surround.vim - Surroundings
                            " Author:       Tim Pope <http://tpo.pe/>
                            " Version:      2.1
                            " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
                            
    1              0.000006 if exists("g:loaded_surround") || &cp || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-unimpaired/plugin/unimpaired.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            " unimpaired.vim - Pairs of handy bracket mappings
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      1.2
                            " GetLatestVimScripts: 1590 1 :AutoInstall: unimpaired.vim
                            
    1              0.000006 if exists("g:loaded_unimpaired") || &cp || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-easymotion/plugin/EasyMotion.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            scriptencoding utf-8
                            " EasyMotion - Vim motions on speed!
                            "
                            " Author: Kim Silkebækken <kim.silkebaekken+vim@gmail.com>
                            "         haya14busa <hayabusa1419@gmail.com>
                            " Source: https://github.com/easymotion/vim-easymotion
                            " == Script initialization {{{
    1              0.000013 if expand("%:p") ==# expand("<sfile>:p")
                              unlet! g:EasyMotion_loaded
                            endif
    1              0.000005 if exists('g:EasyMotion_loaded') || &compatible || version < 703
    1              0.000002     finish

SCRIPT  /home/spiros/.config/nvim/plugins/ctrlp.vim/plugin/ctrlp.vim
Sourced 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                            " =============================================================================
                            " File:          plugin/ctrlp.vim
                            " Description:   Fuzzy file, buffer, mru, tag, etc finder.
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            " GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip
                            
    1              0.000007 if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
    1              0.000002 	fini

SCRIPT  /home/spiros/.config/nvim/plugins/nerdTree/plugin/NERD_tree.vim
Sourced 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                            " ============================================================================
                            " File:        NERD_tree.vim
                            " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            " License:     This program is free software. It comes without any warranty,
                            "              to the extent permitted by applicable law. You can redistribute
                            "              it and/or modify it under the terms of the Do What The Fuck You
                            "              Want To Public License, Version 2, as published by Sam Hocevar.
                            "              See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            " ============================================================================
                            "
                            " SECTION: Script init stuff {{{1
                            "============================================================
    1              0.000005 if exists("loaded_nerd_tree")
    1              0.000002     finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-vinegar/plugin/vinegar.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " vinegar.vim - combine with netrw to create a delicious salad dressing
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
    1              0.000006 if exists("g:loaded_vinegar") || v:version < 700 || &cp
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-startify/plugin/startify.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
                            " Plugin:      https://github.com/mhinz/vim-startify
                            " Description: A fancy start screen for Vim.
                            " Maintainer:  Marco Hinz <http://github.com/mhinz>
                            
    1              0.000005 if exists('g:loaded_startify') || &cp
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/neoterm/plugin/neoterm.vim
Sourced 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
                            if !has('nvim') || get(g:, 'neoterm_loaded', 0)
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-gitgutter/plugin/gitgutter.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            scriptencoding utf-8
                            
    1              0.000006 if exists('g:loaded_gitgutter') || !has('signs') || &cp
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-fugitive/plugin/fugitive.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " fugitive.vim - A Git wrapper so awesome, it should be illegal
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      2.2
                            " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
                            
    1              0.000006 if exists('g:loaded_fugitive') || &cp
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-airline/plugin/airline.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 scriptencoding utf-8
                            
    1              0.000014 if &cp || v:version < 702 || (exists('g:loaded_airline') && g:loaded_airline)
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-airline-themes/plugin/airline-themes.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2016 Bailey Ling & Contributors.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000007 if (exists('g:loaded_airline_themes') && g:loaded_airline_themes)
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-devicons/plugin/webdevicons.vim
Sourced 1 time
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
                            " Version: 0.9.2
                            " Webpage: https://github.com/ryanoasis/vim-devicons
                            " Maintainer: Ryan McIntyre <ryanoasis@gmail.com>
                            " License: see LICENSE
                            
    1              0.000005 let s:version = '0.9.2'
    1              0.000010 let s:plugin_home = expand('<sfile>:p:h:h')
                            
                            " set scriptencoding after 'encoding' and when using multibyte chars
    1              0.000003 scriptencoding utf-8
                            
                            " standard fix/safety: line continuation (avoiding side effects) {{{1
                            "========================================================================
    1              0.000010 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
                            " standard loading / not loading {{{1
                            "========================================================================
                            
    1              0.000004 if exists('g:loaded_webdevicons')
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/ultisnips/plugin/UltiSnips.vim
Sourced 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
                            if exists('did_plugin_ultisnips') || &cp
    1              0.000002     finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-rails/plugin/rails.vim
Sourced 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
                            " rails.vim - Detect a rails application
                            " Author:       Tim Pope <http://tpo.pe/>
                            " GetLatestVimScripts: 1567 1 :AutoInstall: rails.vim
                            
                            " Install this file as plugin/rails.vim.
                            
    1              0.000006 if exists('g:loaded_rails') || &cp || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-bundler/plugin/bundler.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " bundler.vim - Support for Ruby's Bundler
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      2.0
                            
    1              0.000006 if exists('g:loaded_bundler') || &cp || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-rake/plugin/rake.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            " rake.vim - It's like rails.vim without the rails
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      2.0
                            " GetLatestVimScripts: 3669 1 :AutoInstall: rake.vim
                            
    1              0.000006 if exists('g:loaded_rake') || &cp || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-test/plugin/test.vim
Sourced 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
                            if exists('g:loaded_test')
    1              0.000003   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-rspec/plugin/rspec.vim
Sourced 1 time
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
                            let s:plugin_path = expand("<sfile>:p:h:h")
    1              0.000004 let s:default_command = "rspec {spec}"
    1              0.000003 let s:force_gui = 0
                            
    1              0.000004 if !exists("g:rspec_runner")
                              let g:rspec_runner = "os_x_terminal"
                            endif
                            
    1              0.000003 function! RunAllSpecs()
                              let s:last_spec = ""
                              call s:RunSpecs(s:last_spec)
                            endfunction
                            
    1              0.000002 function! RunCurrentSpecFile()
                              if s:InSpecFile()
                                let s:last_spec_file = s:CurrentFilePath()
                                let s:last_spec = s:last_spec_file
                                call s:RunSpecs(s:last_spec_file)
                              elseif exists("s:last_spec_file")
                                call s:RunSpecs(s:last_spec_file)
                              endif
                            endfunction
                            
    1              0.000002 function! RunNearestSpec()
                              if s:InSpecFile()
                                let s:last_spec_file = s:CurrentFilePath()
                                let s:last_spec_file_with_line = s:last_spec_file . ":" . line(".")
                                let s:last_spec = s:last_spec_file_with_line
                                call s:RunSpecs(s:last_spec_file_with_line)
                              elseif exists("s:last_spec_file_with_line")
                                call s:RunSpecs(s:last_spec_file_with_line)
                              endif
                            endfunction
                            
    1              0.000002 function! RunLastSpec()
                              if exists("s:last_spec")
                                call s:RunSpecs(s:last_spec)
                              endif
                            endfunction
                            
                            " === local functions ===
                            
    1              0.000003 function! s:RunSpecs(spec_location)
                              let s:rspec_command = substitute(s:RspecCommand(), "{spec}", a:spec_location, "g")
                            
                              execute s:rspec_command
                            endfunction
                            
    1              0.000002 function! s:InSpecFile()
                              return match(expand("%"), "_spec.rb$") != -1
                            endfunction
                            
    1              0.000002 function! s:RspecCommand()
                              if s:RspecCommandProvided() && s:IsMacGui()
                                let l:command = s:GuiCommand(g:rspec_command)
                              elseif s:RspecCommandProvided()
                                let l:command = g:rspec_command
                              elseif s:IsMacGui()
                                let l:command = s:GuiCommand(s:default_command)
                              else
                                let l:command = s:DefaultTerminalCommand()
                              endif
                            
                              return l:command
                            endfunction
                            
    1              0.000003 function! s:RspecCommandProvided()
                              return exists("g:rspec_command")
                            endfunction
                            
    1              0.000003 function! s:DefaultTerminalCommand()
                              return "!" . s:ClearCommand() . " && echo " . s:default_command . " && " . s:default_command
                            endfunction
                            
    1              0.000003 function! s:CurrentFilePath()
                              return @%
                            endfunction
                            
    1              0.000003 function! s:GuiCommand(command)
                              return "silent ! '" . s:plugin_path . "/bin/" . g:rspec_runner . "' '" . a:command . "'"
                            endfunction
                            
    1              0.000002 function! s:ClearCommand()
                              if s:IsWindows()
                                return "cls"
                              else
                                return "clear"
                              endif
                            endfunction
                            
    1              0.000002 function! s:IsMacGui()
                              return s:force_gui || (has("gui_running") && has("gui_macvim"))
                            endfunction
                            
    1              0.000002 function! s:IsWindows()
                              return has("win32") && fnamemodify(&shell, ':t') ==? "cmd.exe"
                            endfunction
                            
                            " begin vspec config
    1              0.000003 function! rspec#scope()
                              return s:
                            endfunction
                            
    1              0.000003 function! rspec#sid()
                                return maparg('<SID>', 'n')
                            endfunction
    1              0.000020 nnoremap <SID> <SID>
                            " end vspec config

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/addparameter.vim
Sourced 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            
                            " Synopsis:
                            "   Adds a parameter (or many separated with commas) to a method
    1              0.000003 function! AddParameter()
                              try
                                let name = common#get_input("Parameter name: ", "No parameter name given!")
                              catch
                                echo v:exception
                                return
                              endtry
                            
                              " Save current position
                              let cursor_position = getpos(".")
                            
                              " Move backwards to the method definiton if you are not already on the
                              " correct line
                              if empty(matchstr(getline("."), '\<def\>'))
                                exec "?\\<def\\>"
                              endif
                            
                              let closing_bracket_index = stridx(getline("."), ")")
                              let opening_bracket_index = stridx(getline("."), "(")
                            
                              if closing_bracket_index == -1
                                execute "normal A(" . name . ")\<Esc>"
                                " there is an open & close paren but no parameters
                              elseif opening_bracket_index != -1 && opening_bracket_index == closing_bracket_index - 1
                                exec ':s/)/' . name . ')/'
                              else
                                exec ':.s/)/, ' . name . ')/'
                              endif
                            
                              " Restore caret position
                              call setpos(".", cursor_position)
                            endfunction
                            

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/addparameternb.vim
Sourced 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
                            
                            " Synopsis:
                            "   Adds a parameter (or many separated with commas) to a method with no
                            "   brackets
    1              0.000003 function! AddParameterNB()
                              try
                                let name = common#get_input("Parameter name: ", "No parameter name given!")
                              catch
                                echo v:exception
                                return
                              endtry
                            
                              " Save current position
                              let cursor_position = getpos(".")
                            
                              " Move backwards to the method definiton if you are not already on the
                              " correct line
                              if empty(matchstr(getline("."), '\<def\>'))
                                exec "?\\<def\\>"
                              endif
                            
                              execute "normal A " . name . "\<Esc>"
                            
                              " Restore caret position
                              call setpos(".", cursor_position)
                            endfunction
                            

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/extractconstant.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            " Synopsis:
                            "   Extracts the selected scope into a constant at the top of the current
                            "   module or class
    1              0.000003 function! ExtractConstant()
                              try
                                let name = toupper(common#get_input("Constant name: ", "No constant name given!"))
                              catch
                                echo v:exception
                                return
                              endtry
                            
                              " Save the scope to register a and then reselect the scope in visual mode
                              normal! gv
                              " Replace selected text with the constant's name
                              exec "normal c" . name
                              " Find the enclosing class or module
                              exec "?^\\<class\\|module\\>"
                              " Define the constant inside the class or module
                              exec "normal! o" . name . " = " 
                              normal! $p
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/extractmethod.vim
Sourced 1 time
Total time:   0.000270
 Self time:   0.000270

count  total (s)   self (s)
                            " Synopsis:
                            "   Extracts the selected scope into a method above the scope of the
                            "   current method
    1              0.000003 function! ExtractMethod() range
                              try
                                let name = common#get_input("Method name: ", "No method name given!")
                              catch
                                echo v:exception
                                return
                              endtry
                              
                              let [block_start, block_end] = common#get_range_for_block('\<def\|it\>','Wb')
                            
                              let pre_selection = join( getline(block_start+1,a:firstline-1), "\n" )
                              let pre_selection_variables = s:ruby_determine_variables(pre_selection)
                            
                              let post_selection = join( getline(a:lastline+1,block_end), "\n" )
                              let post_selection_variables = s:ruby_determine_variables(post_selection)
                            
                              let selection = common#cut_visual_selection()
                              let selection_variables = s:ruby_determine_variables(selection)
                            
                              let parameters = []
                              let retvals = []
                            
                              " determine parameters
                              for var in selection_variables[1]
                                call insert(parameters,var)
                              endfor
                            
                              let parameters = s:sort_parameters_by_declaration(parameters)
                            
                              for var in selection_variables[0]
                                if index(post_selection_variables[1], var) != -1
                                  call insert(retvals, var)
                                endif
                              endfor
                            
                              call s:em_insert_new_method(name, selection, parameters, retvals, block_end)
                            endfunction
                            
    1              0.000004 function! s:sort_parameters_by_declaration(parameters)
                              if (len(a:parameters) <= 1)
                                return a:parameters
                              endif
                              let pairs = s:build_parameter_declaration_position_pairs(a:parameters)
                              call sort(pairs, "s:sort_parameter_declaration_position_pairs")
                              return s:parameter_names_of(pairs)
                            endfunction
                            
    1              0.000004 function! s:build_parameter_declaration_position_pairs(parameters)
                              let cursor_position = getpos(".")
                              let pairs = []
                            
                              for parm in a:parameters
                                if (searchdecl(parm) == 0) " could find and position cursor at parameter declaration
                                  call insert(pairs, [parm, getpos(".")])
                                else
                                  call insert(pairs, [parm, getpos("$")]) " use end of file to sink to bottom
                                endif
                                call setpos(".",cursor_position) 
                              endfor
                            
                              return pairs
                            endfunction
                            
    1              0.000004 function! s:sort_parameter_declaration_position_pairs(pair1, pair2)
                              let lineIndex = 1
                              let colIndex = 2
                              if (a:pair1[1][lineIndex] == a:pair2[1][lineIndex])
                                return a:pair1[1][colIndex] - a:pair2[1][colIndex]
                              else
                                return a:pair1[1][lineIndex] - a:pair2[1][lineIndex]
                              endif
                            endfunction
                            
    1              0.000003 function! s:parameter_names_of(pairs)
                              let sorted_parameters = []
                              for pair in a:pairs
                                call extend(sorted_parameters, [pair[0]])
                              endfor
                              return sorted_parameters
                            endfunction
                            
    1              0.000003 function! s:ruby_determine_variables(block) 
                              let tokens = s:ruby_tokenize(a:block)
                              let statements = s:ruby_identify_tokens(tokens)
                            
                              let assigned = []
                              let referenced = []
                            
                              for statement in statements 
                                call s:ruby_identify_methods( statement )
                                let results = s:ruby_identify_variables( statement )
                                call extend(assigned,results[0])
                                call extend(referenced,results[1])
                              endfor
                            
                              call common#dedupe_list(assigned)
                              call common#dedupe_list(referenced)
                            
                              return [assigned,referenced]
                            endfunction
                            
                            " Synopsis:
                            " Splits a block of code into individual statements, then splits said
                            " statements into individual tokens (variables, operators, symbols, etc)
    1              0.000003 function! s:ruby_tokenize( block )
                              let stripped_block = tr( a:block, "\n\r\t", ";  " )
                              let tokens = []
                            
                              let ofs = 0
                              while 1
                                let a = matchstr( stripped_block, '\v^(#|;|,|\(|\)|\d+\.\d+|(\:|\@)?\w+|\s+|\''[^\'']*\''|\"[^\"]*\"|\=|\S+)', ofs )
                                if a == ""
                                  break
                                endif
                                let ofs = ofs + len(a)
                                call add(tokens,a)
                              endwhile
                            
                              return tokens
                            endfunction
                            
                            " Synopsis:
                            " Determines what each of a list of strings is with respect to the ruby
                            " language.  E.g. keywords, operators, variables, methods
                            "
                            " TODO: Improve this with ref to http://www.zenspider.com/Languages/Ruby/QuickRef.html#4 
    1              0.000003 function! s:ruby_identify_tokens( tokenlist )
                              let symbols = []
                              let statements = []
                              let reserved = [ "alias", "and", "BEGIN", "begin", "break", "case", "class", "def", "defined?", "do", "else", "elsif", "END", "end", "ensure", "false", "for", "if", "in", "module", "next", "nil", "not", "or", "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless", "until", "when", "while", "yield" ]
                            
                              let ignore_to_eos = 0
                            
                              for token in a:tokenlist
                                if index(reserved,token) != -1
                                  let sym = "KEYWORD"
                                elseif match(token, '\v^\s+$') != -1
                                  let sym = "WS"
                                elseif match(token, '\v^\:\w+$') != -1
                                  let sym = "SYMBOL"
                                elseif match(token, '\v^\I\i*$') != -1
                                  let sym = "VAR"
                                elseif match(token, '\v^\@\I\i*$') != -1
                                  let sym = "IVAR"
                                elseif match(token, '\v^\d+(\.\d+)?$') != -1
                                  let sym = "CONST"
                                elseif token[0] == "'" || token[0] == '"'
                                  let sym = "STR"
                                elseif token == '#' 
                                  let ignore_to_eos = 1
                                elseif token == '=' 
                                  let sym = 'ASSIGN'
                                elseif token == ',' 
                                  let sym = 'COMMA'
                                elseif token == '"' 
                                  let sym = 'DQUOTE'
                                elseif token == "'" 
                                  let sym = 'SQUOTE'
                                elseif token == '(' 
                                  let sym = 'LPAREN'
                                elseif token == ')' 
                                  let sym = 'RPAREN'
                                elseif token == ';' 
                                  let sym = "EOS"
                                  if len(symbols) > 0 
                                    call add(statements, symbols)
                                    let symbols = []
                                    let ignore_to_eos = 0
                                    continue
                                  endif
                                else
                                  let sym = "OPER"
                                endif
                            
                                if ignore_to_eos == 1
                                  let sym = "COMMENT"
                                endif
                            
                                if sym != "WS" 
                                  call add(symbols,[sym,token])
                                endif
                              endfor
                            
                              if len(symbols) > 1
                                call add(statements,symbols)
                              endif
                            
                              return statements
                            endfunction
                            
                            " Synopsis:
                            " Has a stab (badly) at working out if a string is a method or a variable
                            " TODO: Improve this by searching through the current file for the name
                            " preceded by 'def'
    1              0.000004 function! s:ruby_identify_methods( tuples )
                              let lasttuple = []
                              for tuple in a:tuples 
                                let lastsym = get(lasttuple,0,"")
                                let sym = tuple[0]
                                if ((sym == "LPAREN") && (lastsym == "VAR")) || ((sym == "VAR") && (lastsym == "VAR")) || ((sym == "STR" && lastsym == "VAR"))
                                  let lasttuple[0] = "METHOD"
                                endif
                                let lasttuple = tuple
                              endfor
                            endfunction
                            
                            " Synopsis:
                            " Takes a list of variables and tries to work out if the variable has been
                            " assigned to OR used in a comparison.  This determines which variables need
                            " to be passed into the new method, and which need to be returned.
                            " TODO: Change the name of this, it's misleading
    1              0.000003 function! s:ruby_identify_variables( tuples )
                              let assigned = []
                              let referenced = []
                            
                              for tuple in a:tuples
                                if tuple[0] == "ASSIGN"
                                  let assigned = deepcopy(referenced)
                                  let referenced = []
                                elseif tuple[0] == "VAR" && !s:is_target_of_rspec_let(tuple[1])
                                  call add(referenced,tuple[1])
                                endif
                              endfor
                            
                              return [assigned, referenced]
                            endfunction
                            
    1              0.000003 function! s:is_target_of_rspec_let(name)
                              return search('^\s*let\s*[(]\s*[:]' . a:name . '\s*[)]', 'Wbn') > 0
                            endfunction
                            
                            " Synopsis:
                            " Do the vim bit of creating the new method, and the call to it.
    1              0.000004 function! s:em_insert_new_method(name, selection, parameters, retvals, block_end)
                              " Remove last \n if it exists, as we're adding one on prior to the 'end'
                              let has_trailing_newline = strridx(a:selection,"\n") == (strlen(a:selection) - 1) ? 1 : 0
                            
                              " Build new method text, split into a list for easy insertion
                              let method_params = ""
                              if len(a:parameters) > 0 
                                let method_params = "(" . join(a:parameters, ", ") . ")"
                              endif
                            
                              let method_retvals = ""
                              if len(a:retvals) > 0 
                                let method_retvals = join(a:retvals,", ")
                              endif
                            
                              let method_lines = split( "\ndef " . a:name . method_params . "\n" . a:selection . (has_trailing_newline ? "" : "\n") . (len(a:retvals) > 0 ? "return " . method_retvals . "\n" : "") . "end", "\n", 1)
                            
                              let start_line_number = a:block_end - len(split(a:selection, "\n", 1)) + 1 
                            
                              " Insert new method
                              call append(start_line_number, method_lines) 
                            
                              " Insert call to new method, and fix up the source so it makes sense
                              if has_trailing_newline
                                exec "normal i" . (len(a:retvals) > 0 ? method_retvals . " = " : "") . a:name . method_params . "\n"
                                normal k
                              else
                                exec "normal i" . a:name 
                              end
                            
                              " Reset cursor position
                              let cursor_position = getpos(".")
                            
                              " Fix indent on call to method in case we corrupted it
                              normal V=
                              
                              " Indent new codeblock
                              exec "normal " . (start_line_number+1) . "GV" . len(method_lines) . "j="
                            
                              " Jump back again, 
                              call setpos(".", cursor_position)
                            
                              " Visual mode normally moves the caret, go back
                              if has_trailing_newline 
                                normal $
                              endif
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/extractvariable.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " Synopsis:
                            "   Extracts the selected scope to a variable
    1              0.000003 function! ExtractLocalVariable()
                              try
                                let name = common#get_input("Variable name: ", "No variable name given!")
                              catch
                                echo v:exception
                                return
                              endtry
                              
                              call s:select_variable_contents()
                            
                              " Replace selected text with the variable name
                              exec "normal c" . name
                            
                              " Define the variable on the line above
                              exec "normal! O" . name . " = "
                            
                              " Paste the original selected text to be the variable value
                              normal! $p
                            endfunction
                            
    1              0.000004 function! s:select_variable_contents()
                              " select current word or re-establish selection
                              " (not sure why we need to re-select)
                              if (visualmode() == "")
                                normal! viw
                              else
                                normal! gv
                              endif
                            endfunction
                            

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/inlinetemp.vim
Sourced 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
                            " Synopsis:
                            "   Inlines a variable
    1              0.000003 function! InlineTemp()
                              " Copy the variable under the cursor into the 'a' register
                              " XXX: How do I copy into a variable so I don't pollute the registers?
                              let original_a = @a
                              normal "ayiw
                            
                              " It takes 4 diws to get the variable, equal sign, and surrounding
                              " whitespace. I'm not sure why. diw is different from dw in this
                              " respect.
                              normal 4diw
                              " Delete the expression into the 'b' register
                              let original_b = @b
                              normal "bd$
                            
                              " Delete the remnants of the line
                              normal dd
                            
                              " Store current line, that's where we will start searching from
                              let current_line = line(".")
                            
                              " Find the start and end of the current block
                              " TODO: tidy up if no matching 'def' found (start would be 0 atm)
                              let [block_start, block_end] = common#get_range_for_block('\<def\|it\>','Wb')
                            
                              " Rename the variable within the range of the block
                              call common#gsub_all_in_range(current_line, block_end, '\<' . @a . '\>', @b)
                            
                              " Put back original register contents
                              let @a = original_a
                              let @b = original_b
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/introducevariable.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            "Synopsis:
                            "  Introduce variable from class or method name
    1              0.000004 function! IntroduceVariable()
                              let original_a = @a
                            
                              normal ^
                            
                              call search('\.*(\|{\|\n', 'p')
                              normal hh"ayiw
                            
                              let line = @a
                            
                              if line == "new"
                                normal ^"ayiw
                                let line = @a
                              endif
                            
                              let @a = original_a
                              let var = s:snakecase(line)
                              exec "normal I" . var . " = "
                            
                            endfunction
                            
    1              0.000004 function! s:snakecase(word)
                              let word = substitute(a:word,'::','/','g')
                              let word = substitute(word,'\(\u\+\)\(\u\l\)','\1_\2','g')
                              let word = substitute(word,'\(\l\|\d\)\(\u\)','\1_\2','g')
                              let word = substitute(word,'-','_','g')
                              let word = tolower(word)
                              return word
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/postconditional.vim
Sourced 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                            " Synopsis: 
                            "   converts a post-conditional expression to a conditional expression
                            "   note: will convert both types of conditional expression
    1              0.000003 function! ConvertPostConditional()
                              " pattern to match
                              let conditional_operators = '\<if\|unless\|while\|until\>'
                              " save the current line
                              let current_line = line('.')
                              " go to end of current line
                              normal $
                              " find the first match for a conditional operator
                              let first_match = search(conditional_operators, 'bnW')
                            
                              " if the first match isn't on the current line, exit.
                              if current_line != first_match
                                "echo "no match"
                                return
                              endif
                            
                              " move the cursor *backward* to the first found conditional operator
                              call search(conditional_operators, 'bW')
                              let conditional_pos = col(".")
                            
                              " move the cursor to the first word char on the line
                              normal ^
                              let line_start_pos = col(".")
                            
                              " move the cursor *forward* to the first found conditional operator
                              call search(conditional_operators, 'cW')
                            
                              " if conditional starts line (pre-conditional), convert *to* post-conditional
                              let is_pre_conditional = line_start_pos == conditional_pos
                              if is_pre_conditional
                                " convert to post-conditional (e.g. do_stuff() if condition)
                            
                                " assert conditional statement takes exactly three lines
                                let first_line = line('.')
                                let last_line = search('^\s*end\s*$', 'nW')
                                let is_three_lines = (last_line - first_line) == 2
                                if is_three_lines
                                  " delete third line, cut first, paste after second, join, indent properly
                                  normal jjddkkddpkJ==
                                else
                                  "echo "multi-line conditional contains 2+ statements, aborting"
                                endif
                              else
                                " convert to pre-conditional (e.g. if condition \n do_stuff() \n end)
                            
                                " save original value of buffer a into temp variable
                                let original_value = @a
                                " delete to the end of the line into buffer a
                                normal "ad$
                                " insert new line above
                                normal O
                                " and paste buffer a
                                normal "ap
                                " indent conditional properly
                                normal ==
                                " restore original value back to register a
                                let @a = original_value
                                " move one line down and add 'end'
                                exec "normal jo" . "end"
                                " move back to the line that you started at
                                normal k
                                " indent the conditional body
                                normal >>
                                " remove trailing whitespace from paste operation
                            	  s/\s*$//g
                              endif
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/renameinstancevariable.vim
Sourced 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                            
                            " Synopsis:
                            "   Rename the selected instance variable
    1              0.000003 function! RenameInstanceVariable()
                              try
                                let selection = common#get_visual_selection()
                            
                                " If no @ at the start of selection, then abort
                                if match( selection, "^@" ) == -1
                                  let left_of_selection = getline(".")[col(".")-2]
                                  if left_of_selection == "@"
                                    let selection = "@".selection
                                  else
                                    throw "Selection '" . selection . "' is not an instance variable"
                                  end
                                endif
                            
                                let name = common#get_input("Rename to: @", "No variable name given!" )
                              catch
                                echo v:exception
                                return
                              endtry
                            
                              " Assume no prefix given
                              let name_no_prefix = name
                            
                              " Add leading @ if none provided
                              if( match( name, "^@" ) == -1 )
                                let name = "@" . name
                              else
                                " Remove the @ from the no_prefix version
                                let name_no_prefix = matchstr(name,'^@\zs.*')
                              endif
                            
                              " Find the start and end of the current block
                              " TODO: tidy up if no matching 'def' found (start would be 0 atm)
                              let [block_start, block_end] = common#get_range_for_block('\<class\>','Wb')
                            
                              " Rename the variable within the range of the block
                              call common#gsub_all_in_range(block_start, block_end, selection.'\>\ze\([^\(]\|$\)', name)
                            
                              " copy with no prefix for the attr_* match
                              let selection_no_prefix = matchstr( selection, '^@\zs.*' )
                            
                              " Rename attr_* symbols
                              call common#gsub_all_in_range(block_start, block_end, '^\s*attr_\(reader\|writer\|accessor\).*\:\zs'.selection_no_prefix, name_no_prefix)
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/renamelocalvariable.vim
Sourced 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
                            " Synopsis:
                            "   Rename the selected local variable 
    1              0.000003 function! RenameLocalVariable()
                              try
                                let selection = common#get_visual_selection()
                            
                                " If @ at the start of selection, then abort
                                if match( selection, "@" ) != -1
                                  throw "Selection '" . selection . "' is not a local variable"
                                endif
                            
                                let name = common#get_input("Rename to: ", "No variable name given!" )
                              catch
                                echo v:exception
                                return
                              endtry
                            
                              " Find the start and end of the current block
                              " TODO: tidy up if no matching 'def' found (start would be 0 atm)
                              let [block_start, block_end] = common#get_range_for_block('\<def\>','Wb')
                            
                              " Rename the variable within the range of the block
                              call common#gsub_all_in_range(block_start, block_end, '[^@]\<\zs'.selection.'\>\ze\([^\(]\|$\)', name)
                            endfunction
                            

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/refactorings/general/rspec_extractlet.vim
Sourced 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                            " Synopsis:
                            "   Extracts into an Rspec let declaration
                            "   Special thanks to ReinH (#vim room at irc.freenode.net)
    1              0.000003 function! ExtractIntoRspecLet()
                              normal 0
                              if empty(matchstr(getline("."), "=")) == 1
                                echo "Can't find an assignment"
                                return
                              end
                              normal! dd
                              exec "?^\\s*\\<\\(describe\\|context\\)\\>"
                              normal! $p
                              exec 's/\v([a-z_][a-zA-Z0-9_]*) \= (.+)/let(:\1) { \2 }'
                              normal V=
                            
                            endfunction

SCRIPT  /home/spiros/.config/nvim/plugins/vim-ruby-refactoring/plugin/ruby-refactoring.vim
Sourced 1 time
Total time:   0.001890
 Self time:   0.001890

count  total (s)   self (s)
                            "
                            " Author: Enrique Comba Riepenhausen (@ecomba) & Paul King (@nrocy)
                            " Email: enrique@edendevelopment.co.uk
                            " Email: somecrocodile@gmail.com
                            "
                            " Acknowledgements:
                            " Thanks to Gary Bernhardt for the inspiration for this tool and the original
                            " ExtractVariable() and InlineTemp() functions.
                            "
                            " Contributions from Stuart Gale (@bishboria)
                            "
                            " Some support functions borrowed from Luc Hermitte's lh-vim library
                            " Also borrowed snake case function from tim popes vim-abloish plugin
                            
                            " Load all refactoring recipes
    1              0.001573 exec 'runtime ' . expand('<sfile>:p:h') . '/refactorings/general/*.vim'
                            
                            " Commands:
                            "
                            " Using a simple 'R' prefix for now
                            " TODO: Do we even need this prefix? How likely is it that we'll conflict?
                            
    1              0.000010 command! RAddParameter                  call AddParameter()
    1              0.000006 command! RAddParameterNB                call AddParameterNB()
    1              0.000005 command! RInlineTemp                    call InlineTemp()
    1              0.000007 command! RExtractLet                    call ExtractIntoRspecLet()
    1              0.000007 command! RConvertPostConditional        call ConvertPostConditional()
    1              0.000006 command! RIntroduceVariable             call IntroduceVariable()
                            
    1              0.000006 command! -range RExtractConstant        call ExtractConstant()
    1              0.000007 command! -range RExtractLocalVariable   call ExtractLocalVariable()
    1              0.000007 command! -range RRenameLocalVariable    call RenameLocalVariable()
    1              0.000007 command! -range RRenameInstanceVariable call RenameInstanceVariable()
    1              0.000006 command! -range RExtractMethod          call ExtractMethod()
                            
                            " Mappings:
                            "
                            " Default mappings are <leader>r followed by an acronym of the pattern's name
                            " E.g. Extract Method is mapped to <leader>rem
                            
    1              0.000006 if !exists('g:ruby_refactoring_map_keys')
                              let g:ruby_refactoring_map_keys = 1
                            endif
                            
    1              0.000002 if g:ruby_refactoring_map_keys
    1              0.000028   nnoremap <leader>rap  :RAddParameter<cr>
    1              0.000018   nnoremap <leader>rapn :RAddParameterNB<cr>
    1              0.000018   nnoremap <leader>rit  :RInlineTemp<cr>
    1              0.000018   nnoremap <leader>rel  :RExtractLet<cr>
    1              0.000018   nnoremap <leader>rcpc :RConvertPostConditional<cr>
    1              0.000018   nnoremap <leader>riv  :RIntroduceVariable<cr>
                            
    1              0.000019   vnoremap <leader>rec  :RExtractConstant<cr>
    1              0.000017   vnoremap <leader>relv :RExtractLocalVariable<cr>
    1              0.000017   vnoremap <leader>rrlv :RRenameLocalVariable<cr>
    1              0.000018   vnoremap <leader>rriv :RRenameInstanceVariable<cr>
    1              0.000017   vnoremap <leader>rem  :RExtractMethod<cr>
    1              0.000003 endif

SCRIPT  /home/spiros/.config/nvim/plugins/vim-monster/plugin/monster.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            scriptencoding utf-8
    1              0.000005 if exists('g:loaded_monster')
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vimproc.vim/plugin/vimproc.vim
Sourced 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: vimproc.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000005 if exists('g:loaded_vimproc')
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-tmux-navigator/plugin/tmux_navigator.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
                            " no more windows in that direction, forwards the operation to tmux.
                            " Additionally, <C-\> toggles between last active vim splits/tmux panes.
                            
    1              0.000007 if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/vim-seeing-is-believing/plugin/seeing_is_believing.vim
Sourced 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                            "=============================================================================
                            " File: xmpfilter.vim
                            " Author: t9md <taqumd@gmail.com>
                            " WebPage: http://github.com/t9md/vim-ruby-xmpfilter
                            " License: BSD
                            " Version: 0.1
                            
                            " GUARD: {{{
                            "============================================================
                            
    1              0.000006 if exists('g:loaded_seeing_is_believing')
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/ale/plugin/ale.vim
Sourced 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Main entry point for the plugin: sets up prefs and autocommands
                            "   Preferences can be set in vimrc files and so on to configure ale
                            
                            " Sanity Checks
                            
    1              0.000007 if exists('g:loaded_ale_dont_use_this_in_other_plugins_please')
    1              0.000003     finish

SCRIPT  /home/spiros/.config/nvim/plugins/nvim-completion-manager/plugin/cm.vim
Sourced 1 time
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
                            
    1              0.000009 if !has('nvim') && v:version<800
                            	finish
                            endif
                            
                            " simply ignore files larger than 1M, for performance
    1              0.000006 let g:cm_buffer_size_limit = get(g:,'cm_buffer_size_limit',1000000)
                            
                            " multithreadig, saves more memory, enabled by default
    1              0.000004 if !exists('g:cm_multi_threading')
                            	if $NVIM_NCM_MULTI_THREAD == ''
                            		let g:cm_multi_threading = 1
                            	else
                            		let g:cm_multi_threading = $NVIM_NCM_MULTI_THREAD
                            	endif
                            endif
                            
    1              0.000007 let g:cm_matcher = get(g:,'cm_matcher',{'module': 'cm_matchers.prefix_matcher', 'case': 'smartcase'})
                            
    1              0.000004 if !exists('g:cm_completekeys')
                            	if g:cm_matcher['module'] == 'cm_matchers.prefix_matcher'
                            		" <Plug>(cm_complete) has no flickering issue with prefix_matcher. But
                            		" it has terrible popup flickering issue with fuzzy_matcher.
                            		let g:cm_completekeys = "\<Plug>(cm_complete)"
                            	else
                            		" <Plug>(cm_completefunc) has no popup flickering with fuzzy matcher.
                            		" But it has cursor flickering issue
                            		let g:cm_completekeys = "\<Plug>(cm_completefunc)"
                            	endif
                            endif
                            
    1              0.000004 let g:cm_auto_popup = get(g:,'cm_auto_popup',1)
                            
                            " Wait for an interval before candidate calculation, to improve editor
                            " performance for fast typing.
    1              0.000005 let g:cm_complete_start_delay = get(g:,'cm_complete_start_delay', 0)
                            
                            " Wait for an interval before popping up, in milliseconds, this would reduce
                            " the popup menu flickering when multiple sources are updating the popup menu
                            " in a short interval, use an interval long enough for computer and short
                            " enough for human
                            " The name cm_complete_delay is deprecated
    1              0.000006 let g:cm_complete_popup_delay = get(g:, 'cm_complete_popup_delay', get(g:, 'cm_complete_delay', 50))
                            
                            " Automatically enable all registered sources by default. Set it to 0 if you
                            " want to manually enable the registered sources you want by
                            " g:cm_sources_override.
    1              0.000004 let g:cm_sources_enable = get(g:,'cm_sources_enable',1)
                            
                            " used to override default options of sources
    1              0.000005 let g:cm_sources_override = get(g:,'cm_sources_override',{})
                            
                            " format: [ (minimal priority, min length), ()]
                            " the name cm_refresh_default_min_word_len is deprecated, it will be removed
                            " in the future
    1              0.000009 let g:cm_refresh_length = get(g:, 'cm_refresh_length', get(g:, 'cm_refresh_default_min_word_len', [[1, 4], [7, 3]]))
                            
    1              0.000005 let g:cm_completeopt=get(g:,'cm_completeopt','menu,menuone,noinsert,noselect')
                            
                            " use did_plugin_ultisnips to detect the installation of ultisnips
                            " https://github.com/SirVer/ultisnips/blob/76ebfec3cf7340a1edd90ea052b16910733c96b0/autoload/UltiSnips.vim#L1
    1              0.000024 au User CmSetup if exists('g:did_plugin_ultisnips') | call cm#register_source({'name' : 'cm-ultisnips',
                            		\ 'priority': 7, 
                            		\ 'abbreviation': 'Snip',
                            		\ 'word_pattern': '\S+',
                            		\ 'cm_refresh': 'cm#sources#ultisnips#cm_refresh',
                            		\ }) | endif
                            
    1              0.000011 au User CmSetup if exists('g:loaded_neosnippet') | call cm#register_source({'name' : 'cm-neosnippet',
                            		\ 'priority': 7, 
                            		\ 'abbreviation': 'Snip',
                            		\ 'word_pattern': '\S+',
                            		\ 'cm_refresh': 'cm#sources#neosnippet#cm_refresh',
                            		\ }) | endif
                            
    1              0.000010 au User CmSetup if exists('g:snipMateSources') | call cm#register_source({'name' : 'cm-snipmate',
                            		\ 'priority': 7,
                            		\ 'abbreviation': 'Snip',
                            		\ 'word_pattern': '\S+',
                            		\ 'cm_refresh': 'cm#sources#snipmate#cm_refresh',
                            		\ }) | endif
                            
                            " css
                            " the omnifunc pattern is PCRE
    1              0.000013 au User CmSetup call cm#register_source({'name' : 'cm-css',
                                    \ 'priority': 9, 
                                    \ 'scoping': 1,
                                    \ 'scopes': ['css','scss'],
                                    \ 'abbreviation': 'css',
                                    \ 'word_pattern': '[\w\-]+',
                                    \ 'cm_refresh_patterns':['[\w\-]+\s*:\s+'],
                                    \ 'cm_refresh': {'omnifunc': 'csscomplete#CompleteCSS'},
                                    \ })
                            
    1              0.000004 func! s:startup(...)
                                if get(g:,'cm_smart_enable',1)
                                    call cm#_auto_enable_check()
                                    augroup cm_smart_enable
                                        au!
                                        au BufEnter * call cm#_auto_enable_check()
                                        au OptionSet buftype call cm#_auto_enable_check()
                                    augroup end
                                endif
                            endfunc
                            
    1              0.000016 call timer_start(get(g:, 'cm_startup_delay', 100), function('s:startup'))

SCRIPT  /home/spiros/.config/nvim/plugins/clang_complete/plugin/clang_complete.vim
Sourced 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
                            "
                            " File: clang_complete.vim
                            " Author: Xavier Deguillard <deguilx@gmail.com>
                            "
                            " Description: Use of clang to complete in C/C++.
                            "
                            " Help: Use :help clang_complete
                            "
                            
    1              0.000006 if exists('g:clang_complete_loaded')
    1              0.000002   finish

SCRIPT  /home/spiros/.config/nvim/plugins/dockerfile.vim/plugin/init.vim
Sourced 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                            let s:dockerfileDelimiters = { "dockerfile": { "left": "#" } }
                            
    1              0.000005 if exists("g:NERDCustomDelimiters")
    1              0.000007   call extend(g:NERDCustomDelimiters, s:dockerfileDelimiters)
    1              0.000002 else
                              let g:NERDCustomDelimiters = s:dockerfileDelimiters
                            endif

SCRIPT  /home/spiros/.config/nvim/plugins/ultisnips/after/plugin/UltiSnips_after.vim
Sourced 1 time
Total time:   0.000218
 Self time:   0.000036

count  total (s)   self (s)
                            " Called after everything else to reclaim keys (Needed for Supertab)
                            
    1              0.000009 if exists("b:did_after_plugin_ultisnips_after") || !exists("g:_uspy")
                               finish
                            endif
    1              0.000005 let b:did_after_plugin_ultisnips_after = 1
                            
    1   0.000197   0.000015 call UltiSnips#map_keys#MapKeys()

SCRIPT  /home/spiros/.config/nvim/plugins/ale/after/plugin/ale.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Follow-up checks for the plugin: warn about conflicting plugins.
                            
                            " A flag for ensuring that this is not run more than one time.
    1              0.000006 if exists('g:loaded_ale_after')
    1              0.000002     finish

SCRIPT  /home/spiros/.config/nvim/plugins/nerdTree/syntax/nerdtree.vim
Sourced 1 time
Total time:   0.001517
 Self time:   0.001517

count  total (s)   self (s)
                            let s:tree_up_dir_line = '.. (up a dir)'
    1              0.000031 syn match NERDTreeIgnore #\~#
    1              0.000018 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    1              0.000018 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
                            
                            "quickhelp syntax elements
    1              0.000015 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
    1              0.000013 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
    1              0.000013 syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
    1              0.000012 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
    1              0.000012 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
    1              0.000013 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    1              0.000107 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
    1              0.000046 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
    1              0.000028 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
    1              0.000028 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighing for directory nodes and file nodes
    1              0.000027 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
    1              0.000055 exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    1              0.000051 exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
                            
    1              0.000008 let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
    1              0.000018 exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
    1              0.000046 syn match NERDTreeExecFile  #^ .*\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark
    1              0.000085 exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
                            
                            "highlighting for readonly files
    1              0.000094 exec 'syn match NERDTreeRO # *\zs.*\ze \['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
                            
    1              0.000047 syn match NERDTreeFlags #^ *\zs\[.\]# containedin=NERDTreeFile,NERDTreeExecFile
    1              0.000029 syn match NERDTreeFlags #\[.\]# containedin=NERDTreeDir
                            
    1              0.000013 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    1              0.000012 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
    1              0.000012 syn match NERDTreeBookmarksLeader #^>#
    1              0.000030 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    1              0.000029 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    1              0.000059 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    1              0.000024 hi def link NERDTreePart Special
    1              0.000018 hi def link NERDTreePartFile Type
    1              0.000019 hi def link NERDTreeExecFile Title
    1              0.000018 hi def link NERDTreeDirSlash Identifier
                            
    1              0.000018 hi def link NERDTreeBookmarksHeader statement
    1              0.000018 hi def link NERDTreeBookmarksLeader ignore
    1              0.000018 hi def link NERDTreeBookmarkName Identifier
    1              0.000018 hi def link NERDTreeBookmark normal
                            
    1              0.000018 hi def link NERDTreeHelp String
    1              0.000018 hi def link NERDTreeHelpKey Identifier
    1              0.000019 hi def link NERDTreeHelpCommand Identifier
    1              0.000018 hi def link NERDTreeHelpTitle Macro
    1              0.000018 hi def link NERDTreeToggleOn Question
    1              0.000018 hi def link NERDTreeToggleOff WarningMsg
                            
    1              0.000018 hi def link NERDTreeLinkTarget Type
    1              0.000018 hi def link NERDTreeLinkFile Macro
    1              0.000018 hi def link NERDTreeLinkDir Macro
                            
    1              0.000018 hi def link NERDTreeDir Directory
    1              0.000018 hi def link NERDTreeUp Directory
    1              0.000018 hi def link NERDTreeFile Normal
    1              0.000018 hi def link NERDTreeCWD Statement
    1              0.000018 hi def link NERDTreeOpenable Directory
    1              0.000018 hi def link NERDTreeClosable Directory
    1              0.000018 hi def link NERDTreeIgnore ignore
    1              0.000018 hi def link NERDTreeRO WarningMsg
    1              0.000018 hi def link NERDTreeBookmark Statement
    1              0.000018 hi def link NERDTreeFlags Number
                            
    1              0.000020 hi def link NERDTreeCurrentNode Search

SCRIPT  /home/spiros/.config/nvim/plugins/splitjoin.vim/ftplugin/vim/splitjoin.vim
Sourced 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            if !exists('b:splitjoin_split_callbacks')
    1              0.000009   let b:splitjoin_split_callbacks = [
                                    \ 'sj#vim#Split',
                                    \ ]
    1              0.000002 endif
                            
    1              0.000004 if !exists('b:splitjoin_join_callbacks')
    1              0.000005   let b:splitjoin_join_callbacks = [
                                    \ 'sj#vim#Join',
                                    \ ]
    1              0.000003 endif

SCRIPT  /usr/share/nvim/runtime/ftplugin/vim.vim
Sourced 1 time
Total time:   0.000657
 Self time:   0.000657

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2014 Sep 07
                            
                            " Only do this when not done yet for this buffer
    1              0.000009 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    1              0.000005 let b:did_ftplugin = 1
                            
    1              0.000014 let s:cpo_save = &cpo
    1              0.000022 set cpo-=C
                            
    1              0.000010 let b:undo_ftplugin = "setl fo< isk< com< tw< commentstring<"
                            	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000024 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000068 setlocal isk+=#
                            
                            " Set 'comments' to format dashed lists in comments
    1              0.000018 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    1              0.000006 if &tw == 0
                              setlocal tw=78
                            endif
                            
                            " Comments start with a double quote
    1              0.000006 setlocal commentstring=\"%s
                            
                            " Move around functions.
    1              0.000062 nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000029 vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000024 nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000027 vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000025 nnoremap <silent><buffer> [] m':call search('^\s*endf*\%[unction]\>', "bW")<CR>
    1              0.000027 vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "bW")<CR>
    1              0.000025 nnoremap <silent><buffer> ][ m':call search('^\s*endf*\%[unction]\>', "W")<CR>
    1              0.000027 vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "W")<CR>
                            
                            " Move around comments
    1              0.000025 nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000027 vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000028 nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000028 vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000007 if exists("loaded_matchit")
    1              0.000005   let b:match_ignorecase = 0
    1              0.000023   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
                            	\ '(:)'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
    1              0.000007   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    1              0.000002 endif
                            
    1              0.000017 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/share/nvim/runtime/indent/vim.vim
Sourced 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    1              0.000007 if exists("b:did_indent")
                              finish
                            endif
    1              0.000005 let b:did_indent = 1
                            
    1              0.000008 setlocal indentexpr=GetVimIndent()
    1              0.000007 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\
                            
    1              0.000005 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000006 if exists("*GetVimIndent")
    1              0.000003   finish

SCRIPT  /usr/share/nvim/runtime/syntax/vim.vim
Sourced 1 time
Total time:   0.059274
 Self time:   0.023656

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua (result is installed
                            "       to: $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000009 if exists("b:current_syntax")
                              finish
                            endif
    1              0.000037 let s:keepcpo= &cpo
    1              0.000015 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000061 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000033 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000035 syn match   vimCommand contained	"\<z[-+^.=]\="
    1              0.000025 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000019 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000062 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000028 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000026 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000295 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000022 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    1              0.000020 syn match   vimTermOption contained	"t_%1"
    1              0.000018 syn match   vimTermOption contained	"t_#2"
    1              0.000020 syn match   vimTermOption contained	"t_#4"
    1              0.000018 syn match   vimTermOption contained	"t_@7"
    1              0.000018 syn match   vimTermOption contained	"t_*7"
    1              0.000020 syn match   vimTermOption contained	"t_&8"
    1              0.000018 syn match   vimTermOption contained	"t_%i"
    1              0.000017 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000017 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    1              0.000004 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000042 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    1              0.000068 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu
    1              0.000024 syn match vimHLGroup contained	"Conceal"
    1              0.000017 syn keyword vimOnlyHLGroup contained	VisualNOS
    1              0.000020 syn keyword nvimHLGroup contained	EndOfBuffer Substitute TermCursor TermCursorNC QuickFixLine
                            "}}}2
    1              0.000004 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    1              0.000008 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a' 
                              com! -nargs=* VimFolda <args> fold 
                             else 
                              com! -nargs=* VimFolda <args> 
                             endif
                             if g:vimsyn_folding =~# 'f' 
                              com! -nargs=* VimFoldf <args> fold 
                             else 
                              com! -nargs=* VimFoldf <args> 
                             endif
                             if g:vimsyn_folding =~# 'l' 
                              com! -nargs=* VimFoldl <args> fold 
                             else 
                              com! -nargs=* VimFoldl <args> 
                             endif
                             if g:vimsyn_folding =~# 'm' 
                              com! -nargs=* VimFoldm <args> fold 
                             else 
                              com! -nargs=* VimFoldm <args> 
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P' 
                              com! -nargs=* VimFoldP <args> fold 
                             else 
                              com! -nargs=* VimFoldP <args> 
                             endif
                             if g:vimsyn_folding =~# 'r' 
                              com! -nargs=* VimFoldr <args> fold 
                             else 
                              com! -nargs=* VimFoldr <args> 
                             endif
                             if g:vimsyn_folding =~# 't' 
                              com! -nargs=* VimFoldt <args> fold 
                             else 
                              com! -nargs=* VimFoldt <args> 
                             endif
                            else
    1              0.000022  com! -nargs=*	VimFolda	<args>
    1              0.000012  com! -nargs=*	VimFoldf	<args>
    1              0.000011  com! -nargs=*	VimFoldl	<args>
    1              0.000011  com! -nargs=*	VimFoldm	<args>
    1              0.000011  com! -nargs=*	VimFoldp	<args>
    1              0.000011  com! -nargs=*	VimFoldP	<args>
    1              0.000011  com! -nargs=*	VimFoldr	<args>
    1              0.000011  com! -nargs=*	VimFoldt	<args>
    1              0.000002 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    1              0.000020 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    1              0.000006 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
                            endif
    1              0.000004 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
                            endif
    1              0.000036 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
                            endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000104 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    1              0.000093 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    1              0.000020 syn match vimNumber	"\<0[xX]\x\+"
    1              0.000024 syn match vimNumber	"\%(^\|[^a-zA-Z]\)\zs#\x\{6}"
                            
                            " All vimCommands are contained by vimIsCommands. {{{2
    1              0.000258 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000046 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000024 syn match vimVar        contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000026 syn match vimVar		"\<[bwglsav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000022 syn match vimFBVar      contained   "\<[bwglsav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000019 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    1              0.000062 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"	matchgroup=vimCommand end="^\.$""
    1              0.000056 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"	matchgroup=vimCommand end="^\.$""
    1              0.000056 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    1              0.000062 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000016 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000019  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000003 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000085 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000009 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000018  syn match   vimFTError  contained	"\I\i*"
    1              0.000003 endif
    1              0.000017 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000017 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000729 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue
    1              0.000009 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
                            else
    1              0.000067  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000003 endif
    1              0.000040 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000024  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000003 endif
    1              0.000016 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000190 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    1              0.000065 syn match	vimOper	"\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000060 syn match	vimOper	"||\|&&\|[-+.]"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000033 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    1              0.000073 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000009 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000023  syn match	vimOperError	")"
    1              0.000003 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000124 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000864 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIf,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand,nvimUnmap,nvimMap
    1              0.000069 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000008 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
                            else
    1              0.000040  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    1              0.000003 endif
    1              0.000020 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000019 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000017 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000017 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000016 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000062 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000062 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000060 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000066 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000059 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000060 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000022 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000622 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFilter,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000021 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000082 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    1              0.000019 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000060 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000098 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000081 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000082 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000105 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000059 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000057 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000060 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000018  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000003 endif
    1              0.000004 syn case ignore
    1              0.000030 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000033 syn keyword	vimUserAttrbCmplt contained	augroup buffer color command compiler cscope dir environment event expression file file_in_path filetype function help highlight locale mapping menu option shellcmd sign syntax tag tag_listfiles var
    1              0.000056 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000051 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000004 syn case match
    1              0.000020 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000047 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000042 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000040 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000029 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000018 syn match	vimEnvvar	"\$\I\i*"
    1              0.000020 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000028 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000018 syn match	vimPatSepErr	contained	"\\)"
    1              0.000017 syn match	vimPatSep	contained	"\\|"
    1              0.000039 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\]['"]"	contains=@vimStringGroup
    1              0.000034 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000019 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000104 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000032 syn region	vimString	oneline keepend	start=+[^:a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ end=+"+	contains=@vimStringGroup
    1              0.000026 syn region	vimString	oneline keepend	start=+[^:a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000028 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000027 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    1              0.000037 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    1              0.000039 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000020 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000123 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000063 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000026 syn cluster	vimSubstList	add=vimCollection
    1              0.000051 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    1              0.000051 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000041 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000049 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000039 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000061 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000074 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000045 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000020 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000032 syn match	vimCollClass    contained transparent	"\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000018 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000017 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000039 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000020 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    1              0.000020 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000082 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000080 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000082 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000097 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000083 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000060 syn match	vimMarkNumber	"[-+]\d\+"		nextgroup=vimSubst contained contains=vimOper
    1              0.000017 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
                            
    1              0.000026 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000020 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000020 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000016 syn match	vimRegister	'@"'
    1              0.000021 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000040 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000060 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000041 syn match	vimFilter contained	"^!.\{-}\(|\|$\)"		contains=vimSpecFile
    1              0.000102 syn match	vimFilter contained	"\A!.\{-}\(|\|$\)"ms=s+1	contains=vimSpecFile,vimFunction,vimFuncName,vimOperParen
                            
                            " Complex repeats (:h complex-repeat) {{{2
    1              0.000020 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000025 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000183 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    1              0.000123 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1 contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    1              0.000045 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    1              0.000044 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    1              0.000020 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    1              0.000058 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    1              0.000069 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    1              0.000111 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000038 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000018 syn match	vimAutoCmdSfxList	contained	"\S*"
    1              0.000041 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    1              0.000136 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000186 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000142 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000005 syn case ignore
    1              0.000014 syn keyword	vimEchoHLNone	none
    1              0.000003 syn case match
                            
                            " Maps {{{2
                            " ====
    1              0.000060 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000104 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000075 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000018 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000086 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000072 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000078 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000055 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000117 syn match	vimMapMod	contained	"\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000077 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000039 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000004 syn case ignore
    1              0.000020 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000003 syn case match
                            
                            " Menus {{{2
                            " =====
    1              0.000081 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000049 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000060 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000037 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000078 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000059 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000034 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000078 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    1              0.000036 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000005 syn case ignore
    1              0.000076 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000051 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000044 syn match	vimNotation	"\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"		contains=vimBracket
    1              0.000043 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1			contains=vimBracket
    1              0.000046 syn match	vimNotation	'\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|f-args\|lt\)>'	contains=vimBracket
    1              0.000044 syn match	vimNotation	"\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000017 syn match	vimBracket contained	"[\\<>]"
    1              0.000004 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000094 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    1              0.000051 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    1              0.000025 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000013 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000064  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
                            " syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)[0-9]\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000018  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000019  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000003 endif
                            
                            " Norm {{{2
                            " ====
    1              0.000037 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000019 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    1              0.000056 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000073 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000016 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000009 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000017  syn match	vimSynError	contained	"\i\+"
    1              0.000034  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000003 endif
    1              0.000037 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000036 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000035 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000086 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000083 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000036 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000051 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000017  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000002 endif
    1              0.000014 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000033 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000032 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000115 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000035 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000053 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000065 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000032 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000034 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000017 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000032 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000027 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000061 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000032 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000047 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000027 syn match	vimSynKeyOpt	contained	"\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000028 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000135 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    1              0.000032 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000041 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000027 syn match	vimSynMtchOpt	contained	"\<\(conceal\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000007 if has("conceal")
    1              0.000037  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000017  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000003 endif
    1              0.000027 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000017 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000158 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000299 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000034 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000039 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000036 syn match	vimSynRegOpt	contained	"\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000038 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000106 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000069 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000025 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000039 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000018 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000034 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000021 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000017 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000018 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000029 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000137 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000016  syn match	vimSyncError	contained	"\i\+"
    1              0.000003 endif
    1              0.000015 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000032 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000031 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000038 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000034 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000041 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000033 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000039 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000051 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000013 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    1              0.000068 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    1              0.000078 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    1              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000016  syn match	vimHiCtermError	contained	"[^0-9]\i*"
    1              0.000003 endif
    1              0.000039 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000017 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000015 syn match	vimHiGroup	contained	"\i\+"
    1              0.000004 syn case ignore
    1              0.000020 syn keyword	vimHiAttrib	contained	none bold inverse italic reverse standout underline undercurl
    1              0.000019 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000004 syn case match
    1              0.000033 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000050 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000006 syn case ignore
    1              0.000175 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    1              0.000022 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000004 syn case match
    1              0.000020 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000024 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000017 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000201 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000057 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000017  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000003 endif
    1              0.000035 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000055 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000035 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000279 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000042 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000034 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000090 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000038 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000015 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000032 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
    1              0.000177 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation,vimOnlyHLGroup,nvimHLGroup
    1              0.000029 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    1              0.000018 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000061 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000065 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000018 syn match	vimContinue	"^\s*\\"
    1              0.000049 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000017 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000063 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000021 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000065 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000061 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000010 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed= "lpPr"
                            endif
                            
                            " [-- lua --] {{{3
    1              0.000040 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000017 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
                            endif
    1              0.000019 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
    1              0.000006  unlet! b:current_syntax
    1              0.000070  exe "syn include @vimLuaScript ".s:luapath
    1              0.000044  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
    1              0.000034  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+		contains=@vimLuaScript
    1              0.000028  syn cluster vimFuncBodyList	add=vimLuaRegion
    1              0.000002 else
                             syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
                            endif
    1              0.000006 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000043 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000016 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
                            endif
    1              0.000017 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
    1              0.000005  unlet! b:current_syntax
    1              0.000006  let s:foldmethod = &l:foldmethod
    1              0.000057  exe "syn include @vimPerlScript ".s:perlpath
    1              0.000010  let &l:foldmethod = s:foldmethod
    1              0.000048  VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPerlScript
    1              0.000037  VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+	contains=@vimPerlScript
    1              0.000025  syn cluster vimFuncBodyList	add=vimPerlRegion
    1              0.000002 else
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
                            endif
    1              0.000004 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000031 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000016 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
                            endif
    1              0.000017 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
    1              0.000004  unlet! b:current_syntax
    1              0.000006  let s:foldmethod = &l:foldmethod
    1              0.000051  exe "syn include @vimRubyScript ".s:rubypath
    1              0.000013  let &l:foldmethod = s:foldmethod
    1              0.000041  VimFoldr syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimRubyScript
    1              0.000030  syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+		contains=@vimRubyScript
    1              0.000022  syn cluster vimFuncBodyList	add=vimRubyRegion
    1              0.000002 else
                             syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
                            endif
    1              0.000004 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000032 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000015 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
                            endif
    1              0.000016 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
    1              0.000005  unlet! b:current_syntax
    1              0.000053  exe "syn include @vimPythonScript ".s:pythonpath
    1              0.000039  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPythonScript
    1              0.000033  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
    1              0.000036  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(.*\)$+ end=+^\z1$+		contains=@vimPythonScript
    1              0.000037  VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
    1              0.000023  syn cluster vimFuncBodyList	add=vimPythonRegion
    1              0.000002 else
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
                            endif
    1              0.000004 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000022 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
    1              0.000004  let s:trytcl= 1
    1              0.000002 endif
    1              0.000003 if s:trytcl
    1              0.000027  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000014  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
                             endif
    1              0.000009  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
                             else
    1              0.000025   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000019   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000003  endif
    1              0.000003  unlet s:tclpath
    1              0.000002 else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
                            endif
    1              0.000003 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000027 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000013 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
                            endif
    1              0.000008 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let iskKeep= &isk
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                            else
    1              0.000019  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000025  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000003 endif
    1              0.000003 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000006 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
                            endif
    1              0.000007 if exists("g:vimsyn_maxlines")
                             exe "syn sync maxlines=".g:vimsyn_maxlines
                            else
    1              0.000005  syn sync maxlines=60
    1              0.000002 endif
    1              0.000008 syn sync linecont	"^\s\+\\"
    1              0.000018 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000006 if !exists("g:vimsyn_noerror")
    1              0.000019  hi def link vimBehaveError	vimError
    1              0.000017  hi def link vimCollClassErr	vimError
    1              0.000018  hi def link vimErrSetting	vimError
    1              0.000012  hi def link vimEmbedError	vimError
    1              0.000017  hi def link vimFTError	vimError
    1              0.000017  hi def link vimFunctionError	vimError
    1              0.000017  hi def link vimFunc         	vimError
    1              0.000015  hi def link vimHiAttribList	vimError
    1              0.000015  hi def link vimHiCtermError	vimError
    1              0.000015  hi def link vimHiKeyError	vimError
    1              0.000011  hi def link vimKeyCodeError	vimError
    1              0.000016  hi def link vimMapModErr	vimError
    1              0.000016  hi def link vimSubstFlagErr	vimError
    1              0.000016  hi def link vimSynCaseError	vimError
    1              0.000016  hi def link vimBufnrWarn	vimWarn
    1              0.000002 endif
                            
    1              0.000025 hi def link vimAbb	vimCommand
    1              0.000023 hi def link vimAddress	vimMark
    1              0.000019 hi def link vimAugroupError	vimError
    1              0.000025 hi def link vimAugroupKey	vimCommand
    1              0.000017 hi def link vimAuHighlight	vimHighlight
    1              0.000016 hi def link vimAutoCmdOpt	vimOption
    1              0.000025 hi def link vimAutoCmd	vimCommand
    1              0.000024 hi def link vimAutoEvent	Type
    1              0.000022 hi def link nvimAutoEvent	vimAutoEvent
    1              0.000020 hi def link vimAutoSet	vimCommand
    1              0.000022 hi def link vimBehaveModel	vimBehave
    1              0.000025 hi def link vimBehave	vimCommand
    1              0.000024 hi def link vimBracket	Delimiter
    1              0.000025 hi def link vimCmplxRepeat	SpecialChar
    1              0.000028 hi def link vimCommand	Statement
    1              0.000025 hi def link vimComment	Comment
    1              0.000022 hi def link vimCommentString	vimString
    1              0.000024 hi def link vimCommentTitle	PreProc
    1              0.000020 hi def link vimCondHL	vimCommand
    1              0.000025 hi def link vimContinue	Special
    1              0.000025 hi def link vimCtrlChar	SpecialChar
    1              0.000021 hi def link vimEchoHLNone	vimGroup
    1              0.000025 hi def link vimEchoHL	vimCommand
    1              0.000024 hi def link vimElseIfErr	Error
    1              0.000011 hi def link vimElseif	vimCondHL
    1              0.000025 hi def link vimEnvvar	PreProc
    1              0.000020 hi def link vimError	Error
    1              0.000022 hi def link vimFBVar	vimVar
    1              0.000019 hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000021 hi def link vimFold	Folded
    1              0.000025 hi def link vimFTCmd	vimCommand
    1              0.000021 hi def link vimFTOption	vimSynType
    1              0.000025 hi def link vimFuncKey	vimCommand
    1              0.000025 hi def link vimFuncName	Function
    1              0.000027 hi def link vimFuncSID	Special
    1              0.000025 hi def link vimFuncVar	Identifier
    1              0.000016 hi def link vimGroupAdd	vimSynOption
    1              0.000021 hi def link vimGroupName	vimGroup
    1              0.000015 hi def link vimGroupRem	vimSynOption
    1              0.000024 hi def link vimGroupSpecial	Special
    1              0.000026 hi def link vimGroup	Type
    1              0.000024 hi def link vimHiAttrib	PreProc
    1              0.000020 hi def link vimHiClear	vimHighlight
    1              0.000018 hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000018 hi def link vimHiCTerm	vimHiTerm
    1              0.000025 hi def link vimHighlight	vimCommand
    1              0.000019 hi def link vimHiGroup	vimGroupName
    1              0.000018 hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000018 hi def link vimHiGuiFont	vimHiTerm
    1              0.000021 hi def link vimHiGuiRgb	vimNumber
    1              0.000018 hi def link vimHiGui	vimHiTerm
    1              0.000023 hi def link vimHiNmbr	Number
    1              0.000018 hi def link vimHiStartStop	vimHiTerm
    1              0.000023 hi def link vimHiTerm	Type
    1              0.000023 hi def link vimHLGroup	vimGroup
    1              0.000028 hi def link nvimHLGroup	vimHLGroup
    1              0.000020 hi def link vimHLMod	PreProc
    1              0.000022 hi def link vimInsert	vimString
    1              0.000024 hi def link vimIskSep	Delimiter
    1              0.000017 hi def link vimKeyCode	vimSpecFile
    1              0.000020 hi def link vimKeyword	Statement
    1              0.000025 hi def link vimLet	vimCommand
    1              0.000022 hi def link vimLineComment	vimComment
    1              0.000024 hi def link vimMapBang	vimCommand
    1              0.000021 hi def link vimMapModKey	vimFuncSID
    1              0.000020 hi def link vimMapMod	vimBracket
    1              0.000027 hi def link vimMap	vimCommand
    1              0.000022 hi def link nvimMap	vimMap
    1              0.000025 hi def link vimMark	Number
    1              0.000022 hi def link vimMarkNumber	vimNumber
    1              0.000020 hi def link vimMenuMod	vimMapMod
    1              0.000020 hi def link vimMenuNameMore	vimMenuName
    1              0.000024 hi def link vimMenuName	PreProc
    1              0.000021 hi def link vimMtchComment	vimComment
    1              0.000025 hi def link vimNorm	vimCommand
    1              0.000025 hi def link vimNotation	Special
    1              0.000025 hi def link vimNotFunc	vimCommand
    1              0.000021 hi def link vimNotPatSep	vimString
    1              0.000026 hi def link vimNumber	Number
    1              0.000025 hi def link vimOperError	Error
    1              0.000025 hi def link vimOper	Operator
    1              0.000024 hi def link vimOption	PreProc
    1              0.000025 hi def link vimParenSep	Delimiter
    1              0.000021 hi def link vimPatSepErr	vimPatSep
    1              0.000021 hi def link vimPatSepR	vimPatSep
    1              0.000024 hi def link vimPatSep	SpecialChar
    1              0.000021 hi def link vimPatSepZone	vimString
    1              0.000021 hi def link vimPatSepZ	vimPatSep
    1              0.000025 hi def link vimPattern	Type
    1              0.000022 hi def link vimPlainMark	vimMark
    1              0.000021 hi def link vimPlainRegister	vimRegister
    1              0.000025 hi def link vimRegister	SpecialChar
    1              0.000023 hi def link vimScriptDelim	Comment
    1              0.000023 hi def link vimSearchDelim	Statement
    1              0.000020 hi def link vimSearch	vimString
    1              0.000025 hi def link vimSep	Delimiter
    1              0.000020 hi def link vimSetMod	vimOption
    1              0.000024 hi def link vimSetSep	Statement
    1              0.000023 hi def link vimSetString	vimString
    1              0.000026 hi def link vimSpecFile	Identifier
    1              0.000022 hi def link vimSpecFileMod	vimSpecFile
    1              0.000020 hi def link vimSpecial	Type
    1              0.000020 hi def link vimStatement	Statement
    1              0.000021 hi def link vimStringCont	vimString
    1              0.000025 hi def link vimString	String
    1              0.000022 hi def link vimSubst1	vimSubst
    1              0.000024 hi def link vimSubstDelim	Delimiter
    1              0.000025 hi def link vimSubstFlags	Special
    1              0.000025 hi def link vimSubstSubstr	SpecialChar
    1              0.000021 hi def link vimSubstTwoBS	vimString
    1              0.000025 hi def link vimSubst	vimCommand
    1              0.000024 hi def link vimSynCaseError	Error
    1              0.000024 hi def link vimSynCase	Type
    1              0.000024 hi def link vimSyncC	Type
    1              0.000024 hi def link vimSyncError	Error
    1              0.000019 hi def link vimSyncGroupName	vimGroupName
    1              0.000019 hi def link vimSyncGroup	vimGroupName
    1              0.000024 hi def link vimSyncKey	Type
    1              0.000036 hi def link vimSyncNone	Type
    1              0.000017 hi def link vimSynContains	vimSynOption
    1              0.000024 hi def link vimSynError	Error
    1              0.000020 hi def link vimSynKeyContainedin	vimSynContains
    1              0.000016 hi def link vimSynKeyOpt	vimSynOption
    1              0.000015 hi def link vimSynMtchGrp	vimSynOption
    1              0.000015 hi def link vimSynMtchOpt	vimSynOption
    1              0.000016 hi def link vimSynNextgroup	vimSynOption
    1              0.000019 hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000020 hi def link vimSynOption	Special
    1              0.000021 hi def link vimSynPatRange	vimString
    1              0.000015 hi def link vimSynRegOpt	vimSynOption
    1              0.000022 hi def link vimSynRegPat	vimString
    1              0.000024 hi def link vimSynReg	Type
    1              0.000025 hi def link vimSyntax	vimCommand
    1              0.000016 hi def link vimSynType	vimSpecial
    1              0.000026 hi def link vimTodo	Todo
    1              0.000022 hi def link vimUnmap	vimMap
    1              0.000022 hi def link nvimUnmap	vimMap
    1              0.000025 hi def link vimUserAttrbCmpltFunc	Special
    1              0.000017 hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000021 hi def link vimUserAttrbKey	vimOption
    1              0.000016 hi def link vimUserAttrb	vimSpecial
    1              0.000025 hi def link vimUserAttrbError	Error
    1              0.000025 hi def link vimUserCmdError	Error
    1              0.000025 hi def link vimUserCommand	vimCommand
    1              0.000024 hi def link vimUserFunc	Normal
    1              0.000026 hi def link vimVar	Identifier
    1              0.000021 hi def link vimWarn	WarningMsg
                            
                            " Current Syntax Variable: {{{2
    1              0.000006 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000005 delc VimFolda
    1              0.000004 delc VimFoldf
    1              0.000004 delc VimFoldl
    1              0.000004 delc VimFoldm
    1              0.000004 delc VimFoldp
    1              0.000003 delc VimFoldP
    1              0.000004 delc VimFoldr
    1              0.000004 delc VimFoldt
    1              0.000017 let &cpo = s:keepcpo
    1              0.000005 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.006151
 Self time:   0.006151

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Lua 4.0, Lua 5.0, Lua 5.1 and Lua 5.2
                            " Maintainer:	Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author:	Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:	2012 Aug 12
                            " Options:	lua_version = 4 or 5
                            "		lua_subversion = 0 (4.0, 5.0) or 1 (5.1) or 2 (5.2)
                            "		default 5.2
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
    1              0.000006 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000023 let s:cpo_save = &cpo
    1              0.000017 set cpo&vim
                            
    1              0.000006 if !exists("lua_version")
                              " Default is lua 5.2
                              let lua_version = 5
                              let lua_subversion = 2
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. So, set it to 0
                              let lua_subversion = 0
                            endif
                            
    1              0.000004 syn case match
                            
                            " syncing method
    1              0.000006 syn sync minlines=100
                            
                            " Comments
    1              0.000021 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000037 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000022 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaComment start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
                            elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000051   syn region luaComment        matchgroup=luaComment start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000003 endif
                            
                            " First line may start with #!
    1              0.000021 syn match luaComment "\%^#!.*"
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
    1              0.000205 syn region luaParen      transparent                     start='(' end=')' contains=ALLBUT,luaParenError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
    1              0.000222 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=ALLBUT,luaBraceError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
                            
    1              0.000020 syn match  luaParenError ")"
    1              0.000016 syn match  luaBraceError "}"
    1              0.000025 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " function ... end
    1              0.000131 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " if ... then
    1              0.000134 syn region luaIfThen transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4           contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaIn nextgroup=luaThenEnd skipwhite skipempty
                            
                            " then ... end
    1              0.000097 syn region luaThenEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaThenEnd,luaIn
                            
                            " elseif ... then
    1              0.000132 syn region luaElseifThen contained transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " else
    1              0.000015 syn keyword luaElse contained else
                            
                            " do ... end
    1              0.000130 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>"          contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " repeat ... until
    1              0.000138 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>"   contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " while ... do
    1              0.000168 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaIn nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000152 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2   contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000014 syn keyword luaIn contained in
                            
                            " other keywords
    1              0.000017 syn keyword luaStatement return local break
    1              0.000011 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000016   syn keyword luaStatement goto
    1              0.000019   syn match luaLabel "::\I\i*::"
    1              0.000011 endif
    1              0.000016 syn keyword luaOperator and or not
    1              0.000014 syn keyword luaConstant nil
    1              0.000004 if lua_version > 4
    1              0.000015   syn keyword luaConstant true false
    1              0.000002 endif
                            
                            " Strings
    1              0.000003 if lua_version < 5
                              syn match  luaSpecial contained "\\[\\abfnrtv\'\"]\|\\[[:digit:]]\{,3}"
                            elseif lua_version == 5
    1              0.000004   if lua_subversion == 0
                                syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
                                syn region luaString2 matchgroup=luaString start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
                              else
    1              0.000005     if lua_subversion == 1
                                  syn match  luaSpecial contained #\\[\\abfnrtv'"]\|\\[[:digit:]]\{,3}#
                                else " Lua 5.2
    1              0.000030       syn match  luaSpecial contained #\\[\\abfnrtvz'"]\|\\x[[:xdigit:]]\{2}\|\\[[:digit:]]\{,3}#
    1              0.000003     endif
    1              0.000033     syn region luaString2 matchgroup=luaString start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000003   endif
    1              0.000002 endif
    1              0.000041 syn region luaString  start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000047 syn region luaString  start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000021 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000023 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, starting with a dot, optional exponent
    1              0.000020 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000019 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000005 if lua_version >= 5
    1              0.000003   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
                              elseif lua_subversion >= 2
    1              0.000024     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000003   endif
    1              0.000002 endif
                            
    1              0.000018 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000022 syn keyword luaFunc print rawget rawset tonumber tostring type _VERSION
                            
    1              0.000004 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
                            elseif lua_version == 5
    1              0.000016   syn keyword luaFunc getmetatable setmetatable
    1              0.000015   syn keyword luaFunc ipairs pairs
    1              0.000014   syn keyword luaFunc pcall xpcall
    1              0.000015   syn keyword luaFunc _G loadfile rawequal require
    1              0.000004   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
                              else
    1              0.000015     syn keyword luaFunc load select
    1              0.000019     syn match   luaFunc /\<package\.cpath\>/
    1              0.000018     syn match   luaFunc /\<package\.loaded\>/
    1              0.000022     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000018     syn match   luaFunc /\<package\.path\>/
    1              0.000004     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.preload\>/
                                  syn match   luaFunc /\<package\.seeall\>/
                                elseif lua_subversion == 2
    1              0.000015       syn keyword luaFunc _ENV rawlen
    1              0.000020       syn match   luaFunc /\<package\.config\>/
    1              0.000018       syn match   luaFunc /\<package\.preload\>/
    1              0.000019       syn match   luaFunc /\<package\.searchers\>/
    1              0.000018       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000017       syn match   luaFunc /\<bit32\.arshift\>/
    1              0.000017       syn match   luaFunc /\<bit32\.band\>/
    1              0.000017       syn match   luaFunc /\<bit32\.bnot\>/
    1              0.000017       syn match   luaFunc /\<bit32\.bor\>/
    1              0.000026       syn match   luaFunc /\<bit32\.btest\>/
    1              0.000020       syn match   luaFunc /\<bit32\.bxor\>/
    1              0.000021       syn match   luaFunc /\<bit32\.extract\>/
    1              0.000021       syn match   luaFunc /\<bit32\.lrotate\>/
    1              0.000019       syn match   luaFunc /\<bit32\.lshift\>/
    1              0.000018       syn match   luaFunc /\<bit32\.replace\>/
    1              0.000018       syn match   luaFunc /\<bit32\.rrotate\>/
    1              0.000018       syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000002     endif
    1              0.000022     syn match luaFunc /\<coroutine\.running\>/
    1              0.000003   endif
    1              0.000019   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000020   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000019   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000018   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000020   syn match   luaFunc /\<coroutine\.yield\>/
    1              0.000018   syn match   luaFunc /\<string\.byte\>/
    1              0.000018   syn match   luaFunc /\<string\.char\>/
    1              0.000018   syn match   luaFunc /\<string\.dump\>/
    1              0.000020   syn match   luaFunc /\<string\.find\>/
    1              0.000018   syn match   luaFunc /\<string\.format\>/
    1              0.000018   syn match   luaFunc /\<string\.gsub\>/
    1              0.000063   syn match   luaFunc /\<string\.len\>/
    1              0.000020   syn match   luaFunc /\<string\.lower\>/
    1              0.000019   syn match   luaFunc /\<string\.rep\>/
    1              0.000019   syn match   luaFunc /\<string\.sub\>/
    1              0.000018   syn match   luaFunc /\<string\.upper\>/
    1              0.000005   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
                              else
    1              0.000017     syn match luaFunc /\<string\.gmatch\>/
    1              0.000018     syn match luaFunc /\<string\.match\>/
    1              0.000018     syn match luaFunc /\<string\.reverse\>/
    1              0.000003   endif
    1              0.000004   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
                              elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
                              elseif lua_subversion == 2
    1              0.000017     syn match luaFunc /\<table\.pack\>/
    1              0.000017     syn match luaFunc /\<table\.unpack\>/
    1              0.000002   endif
    1              0.000022   syn match   luaFunc /\<table\.concat\>/
    1              0.000018   syn match   luaFunc /\<table\.sort\>/
    1              0.000018   syn match   luaFunc /\<table\.insert\>/
    1              0.000017   syn match   luaFunc /\<table\.remove\>/
    1              0.000019   syn match   luaFunc /\<math\.abs\>/
    1              0.000018   syn match   luaFunc /\<math\.acos\>/
    1              0.000019   syn match   luaFunc /\<math\.asin\>/
    1              0.000017   syn match   luaFunc /\<math\.atan\>/
    1              0.000017   syn match   luaFunc /\<math\.atan2\>/
    1              0.000017   syn match   luaFunc /\<math\.ceil\>/
    1              0.000034   syn match   luaFunc /\<math\.sin\>/
    1              0.000023   syn match   luaFunc /\<math\.cos\>/
    1              0.000017   syn match   luaFunc /\<math\.tan\>/
    1              0.000017   syn match   luaFunc /\<math\.deg\>/
    1              0.000017   syn match   luaFunc /\<math\.exp\>/
    1              0.000019   syn match   luaFunc /\<math\.floor\>/
    1              0.000017   syn match   luaFunc /\<math\.log\>/
    1              0.000017   syn match   luaFunc /\<math\.max\>/
    1              0.000016   syn match   luaFunc /\<math\.min\>/
    1              0.000005   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
                              else
    1              0.000004     if lua_subversion == 1
                                  syn match luaFunc /\<math\.log10\>/
                                endif
    1              0.000017     syn match luaFunc /\<math\.huge\>/
    1              0.000018     syn match luaFunc /\<math\.fmod\>/
    1              0.000017     syn match luaFunc /\<math\.modf\>/
    1              0.000017     syn match luaFunc /\<math\.cosh\>/
    1              0.000017     syn match luaFunc /\<math\.sinh\>/
    1              0.000019     syn match luaFunc /\<math\.tanh\>/
    1              0.000003   endif
    1              0.000016   syn match   luaFunc /\<math\.pow\>/
    1              0.000017   syn match   luaFunc /\<math\.rad\>/
    1              0.000017   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000017   syn match   luaFunc /\<math\.frexp\>/
    1              0.000017   syn match   luaFunc /\<math\.ldexp\>/
    1              0.000020   syn match   luaFunc /\<math\.random\>/
    1              0.000019   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000017   syn match   luaFunc /\<math\.pi\>/
    1              0.000016   syn match   luaFunc /\<io\.close\>/
    1              0.000018   syn match   luaFunc /\<io\.flush\>/
    1              0.000021   syn match   luaFunc /\<io\.input\>/
    1              0.000019   syn match   luaFunc /\<io\.lines\>/
    1              0.000017   syn match   luaFunc /\<io\.open\>/
    1              0.000017   syn match   luaFunc /\<io\.output\>/
    1              0.000017   syn match   luaFunc /\<io\.popen\>/
    1              0.000038   syn match   luaFunc /\<io\.read\>/
    1              0.000018   syn match   luaFunc /\<io\.stderr\>/
    1              0.000017   syn match   luaFunc /\<io\.stdin\>/
    1              0.000017   syn match   luaFunc /\<io\.stdout\>/
    1              0.000017   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000017   syn match   luaFunc /\<io\.type\>/
    1              0.000017   syn match   luaFunc /\<io\.write\>/
    1              0.000017   syn match   luaFunc /\<os\.clock\>/
    1              0.000016   syn match   luaFunc /\<os\.date\>/
    1              0.000017   syn match   luaFunc /\<os\.difftime\>/
    1              0.000021   syn match   luaFunc /\<os\.execute\>/
    1              0.000017   syn match   luaFunc /\<os\.exit\>/
    1              0.000017   syn match   luaFunc /\<os\.getenv\>/
    1              0.000018   syn match   luaFunc /\<os\.remove\>/
    1              0.000017   syn match   luaFunc /\<os\.rename\>/
    1              0.000017   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000016   syn match   luaFunc /\<os\.time\>/
    1              0.000023   syn match   luaFunc /\<os\.tmpname\>/
    1              0.000018   syn match   luaFunc /\<debug\.debug\>/
    1              0.000021   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000019   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000020   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000021   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000018   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000018   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000018   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000018   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000007   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
                                syn match luaFunc /\<debug\.getmetatable\>/
                                syn match luaFunc /\<debug\.setmetatable\>/
                                syn match luaFunc /\<debug\.getregistry\>/
                              elseif lua_subversion == 2
    1              0.000018     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000018     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000022     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000019     syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000019     syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000022     syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000019     syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000002   endif
    1              0.000002 endif
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    1              0.000007 if version >= 508 || !exists("did_lua_syntax_inits")
    1              0.000003   if version < 508
                                let did_lua_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    1              0.000020     command -nargs=+ HiLink hi def link <args>
    1              0.000002   endif
                            
    1              0.000046   HiLink luaStatement		Statement
    1              0.000028   HiLink luaRepeat		Repeat
    1              0.000026   HiLink luaFor			Repeat
    1              0.000026   HiLink luaString		String
    1              0.000028   HiLink luaString2		String
    1              0.000026   HiLink luaNumber		Number
    1              0.000026   HiLink luaOperator		Operator
    1              0.000026   HiLink luaIn			Operator
    1              0.000026   HiLink luaConstant		Constant
    1              0.000026   HiLink luaCond		Conditional
    1              0.000026   HiLink luaElse		Conditional
    1              0.000026   HiLink luaFunction		Function
    1              0.000026   HiLink luaComment		Comment
    1              0.000026   HiLink luaTodo		Todo
    1              0.000026   HiLink luaTable		Structure
    1              0.000026   HiLink luaError		Error
    1              0.000026   HiLink luaParenError		Error
    1              0.000026   HiLink luaBraceError		Error
    1              0.000026   HiLink luaSpecial		SpecialChar
    1              0.000026   HiLink luaFunc		Identifier
    1              0.000026   HiLink luaLabel		Label
                            
    1              0.000004   delcommand HiLink
    1              0.000002 endif
                            
    1              0.000007 let b:current_syntax = "lua"
                            
    1              0.000026 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /usr/share/nvim/runtime/syntax/perl.vim
Sourced 1 time
Total time:   0.014203
 Self time:   0.012218

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:      Perl 5
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Homepage:      http://github.com/vim-perl/vim-perl/tree/master
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   2013-07-23
                            " Contributors:  Andy Lester <andy@petdance.com>
                            "                Hinrik Örn Sigurðsson <hinrik.sig@gmail.com>
                            "                Lukas Mai <l.mai.web.de>
                            "                Nick Hibma <nick@van-laarhoven.org>
                            "                Sonia Heimann <niania@netsurf.org>
                            "                Rob Hoelz <rob@hoelz.ro>
                            "                and many others.
                            "
                            " Please download the most recent version first, before mailing
                            " any comments.
                            "
                            " The following parameters are available for tuning the
                            " perl syntax highlighting, with defaults given:
                            "
                            " let perl_include_pod = 1
                            " unlet perl_no_scope_in_variables
                            " unlet perl_no_extended_vars
                            " unlet perl_string_as_statement
                            " unlet perl_no_sync_on_sub
                            " unlet perl_no_sync_on_global_var
                            " let perl_sync_dist = 100
                            " unlet perl_fold
                            " unlet perl_fold_blocks
                            " unlet perl_nofold_packages
                            " let perl_nofold_subs = 1
                            " unlet perl_fold_anonymous_subs
                            
    1              0.000008 if exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000014 let s:cpo_save = &cpo
    1              0.000015 set cpo&vim
                            
    1              0.000006 if exists('&regexpengine')
    1              0.000005   let s:regexpengine=&regexpengine
    1              0.000017   set regexpengine=1
    1              0.000003 endif
                            
                            " POD starts with ^=<word> and ends with ^=cut
                            
    1              0.000007 if !exists("perl_include_pod") || perl_include_pod == 1
                              " Include a while extra syntax file
    1              0.000651   syn include @Pod syntax/pod.vim
    1              0.000005   unlet b:current_syntax
    1              0.000006   if exists("perl_fold")
                                syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend fold extend
                                syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend fold extend
                              else
    1              0.000037     syn region perlPOD start="^=[a-z]" end="^=cut" contains=@Pod,@Spell,perlTodo keepend
    1              0.000035     syn region perlPOD start="^=cut" end="^=cut" contains=perlTodo keepend
    1              0.000003   endif
    1              0.000002 else
                              " Use only the bare minimum of rules
                              if exists("perl_fold")
                                syn region perlPOD start="^=[a-z]" end="^=cut" fold
                              else
                                syn region perlPOD start="^=[a-z]" end="^=cut"
                              endif
                            endif
                            
                            
    1              0.000007 syn cluster perlTop		contains=TOP
                            
    1              0.000017 syn region perlBraces start="{" end="}" transparent extend
                            
                            " All keywords
                            "
    1              0.000024 syn match perlConditional		"\<\%(if\|elsif\|unless\|given\|when\|default\)\>"
    1              0.000039 syn match perlConditional		"\<else\%(\%(\_s\*if\>\)\|\>\)" contains=perlElseIfError skipwhite skipnl skipempty
    1              0.000025 syn match perlRepeat			"\<\%(while\|for\%(each\)\=\|do\|until\|continue\)\>"
    1              0.000029 syn match perlOperator			"\<\%(defined\|undef\|eq\|ne\|[gl][et]\|cmp\|not\|and\|or\|xor\|not\|bless\|ref\|do\)\>"
                            " for some reason, adding this as the nextgroup for perlControl fixes BEGIN
                            " folding issues...
    1              0.000014 syn match perlFakeGroup 		"" contained
    1              0.000037 syn match perlControl			"\<\%(BEGIN\|CHECK\|INIT\|END\|UNITCHECK\)\>\_s*" nextgroup=perlFakeGroup
                            
    1              0.000019 syn match perlStatementStorage		"\<\%(my\|our\|local\|state\)\>"
    1              0.000023 syn match perlStatementControl		"\<\%(return\|last\|next\|redo\|goto\|break\)\>"
    1              0.000033 syn match perlStatementScalar		"\<\%(chom\=p\|chr\|crypt\|r\=index\|lc\%(first\)\=\|length\|ord\|pack\|sprintf\|substr\|uc\%(first\)\=\)\>"
    1              0.000020 syn match perlStatementRegexp		"\<\%(pos\|quotemeta\|split\|study\)\>"
    1              0.000025 syn match perlStatementNumeric		"\<\%(abs\|atan2\|cos\|exp\|hex\|int\|log\|oct\|rand\|sin\|sqrt\|srand\)\>"
    1              0.000027 syn match perlStatementList		"\<\%(splice\|unshift\|shift\|push\|pop\|join\|reverse\|grep\|map\|sort\|unpack\)\>"
    1              0.000021 syn match perlStatementHash		"\<\%(delete\|each\|exists\|keys\|values\)\>"
    1              0.000020 syn match perlStatementIOfunc		"\<\%(syscall\|dbmopen\|dbmclose\)\>"
    1              0.000055 syn match perlStatementFiledesc		"\<\%(binmode\|close\%(dir\)\=\|eof\|fileno\|getc\|lstat\|printf\=\|read\%(dir\|line\|pipe\)\|rewinddir\|say\|select\|stat\|tell\%(dir\)\=\|write\)\>" nextgroup=perlFiledescStatementNocomma skipwhite
    1              0.000048 syn match perlStatementFiledesc		"\<\%(fcntl\|flock\|ioctl\|open\%(dir\)\=\|read\|seek\%(dir\)\=\|sys\%(open\|read\|seek\|write\)\|truncate\)\>" nextgroup=perlFiledescStatementComma skipwhite
    1              0.000024 syn match perlStatementVector		"\<vec\>"
    1              0.000033 syn match perlStatementFiles		"\<\%(ch\%(dir\|mod\|own\|root\)\|glob\|link\|mkdir\|readlink\|rename\|rmdir\|symlink\|umask\|unlink\|utime\)\>"
    1              0.000019 syn match perlStatementFiles		"-[rwxoRWXOezsfdlpSbctugkTBMAC]\>"
    1              0.000024 syn match perlStatementFlow		"\<\%(caller\|die\|dump\|eval\|exit\|wantarray\)\>"
    1              0.000020 syn match perlStatementInclude		"\<\%(require\|import\)\>"
    1              0.000076 syn match perlStatementInclude		"\<\%(use\|no\)\s\+\%(\%(attributes\|attrs\|autouse\|parent\|base\|big\%(int\|num\|rat\)\|blib\|bytes\|charnames\|constant\|diagnostics\|encoding\%(::warnings\)\=\|feature\|fields\|filetest\|if\|integer\|less\|lib\|locale\|mro\|open\|ops\|overload\|re\|sigtrap\|sort\|strict\|subs\|threads\%(::shared\)\=\|utf8\|vars\|version\|vmsish\|warnings\%(::register\)\=\)\>\)\="
    1              0.000037 syn match perlStatementProc		"\<\%(alarm\|exec\|fork\|get\%(pgrp\|ppid\|priority\)\|kill\|pipe\|set\%(pgrp\|priority\)\|sleep\|system\|times\|wait\%(pid\)\=\)\>"
    1              0.000036 syn match perlStatementSocket		"\<\%(accept\|bind\|connect\|get\%(peername\|sock\%(name\|opt\)\)\|listen\|recv\|send\|setsockopt\|shutdown\|socket\%(pair\)\=\)\>"
    1              0.000029 syn match perlStatementIPC		"\<\%(msg\%(ctl\|get\|rcv\|snd\)\|sem\%(ctl\|get\|op\)\|shm\%(ctl\|get\|read\|write\)\)\>"
    1              0.000041 syn match perlStatementNetwork		"\<\%(\%(end\|[gs]et\)\%(host\|net\|proto\|serv\)ent\|get\%(\%(host\|net\)by\%(addr\|name\)\|protoby\%(name\|number\)\|servby\%(name\|port\)\)\)\>"
    1              0.000031 syn match perlStatementPword		"\<\%(get\%(pw\%(uid\|nam\)\|gr\%(gid\|nam\)\|login\)\)\|\%(end\|[gs]et\)\%(pw\|gr\)ent\>"
    1              0.000021 syn match perlStatementTime		"\<\%(gmtime\|localtime\|time\)\>"
                            
    1              0.000027 syn match perlStatementMisc		"\<\%(warn\|format\|formline\|reset\|scalar\|prototype\|lock\|tied\=\|untie\)\>"
                            
    1              0.000018 syn keyword perlTodo			TODO TODO: TBD TBD: FIXME FIXME: XXX XXX: NOTE NOTE: contained
                            
    1              0.000055 syn region perlStatementIndirObjWrap   matchgroup=perlStatementIndirObj start="\<\%(map\|grep\|sort\|printf\=\|say\|system\|exec\)\>\s*{" end="}" contains=@perlTop,perlBraces extend
                            
    1              0.000025 syn match perlLabel      "^\s*\h\w*\s*::\@!\%(\<v\d\+\s*:\)\@<!"
                            
                            " Perl Identifiers.
                            "
                            " Should be cleaned up to better handle identifiers in particular situations
                            " (in hash keys for example)
                            "
                            " Plain identifiers: $foo, @foo, $#foo, %foo, &foo and dereferences $$foo, @$foo, etc.
                            " We do not process complex things such as @{${"foo"}}. Too complicated, and
                            " too slow. And what is after the -> is *not* considered as part of the
                            " variable - there again, too complicated and too slow.
                            
                            " Special variables first ($^A, ...) and ($|, $', ...)
    1              0.000022 syn match  perlVarPlain		 "$^[ACDEFHILMNOPRSTVWX]\="
    1              0.000023 syn match  perlVarPlain		 "$[\\\"\[\]'&`+*.,;=%~!?@#$<>(-]"
    1              0.000017 syn match  perlVarPlain		 "%+"
    1              0.000020 syn match  perlVarPlain		 "$\%(0\|[1-9]\d*\)"
                            " Same as above, but avoids confusion in $::foo (equivalent to $main::foo)
    1              0.000017 syn match  perlVarPlain		 "$::\@!"
                            " These variables are not recognized within matches.
    1              0.000019 syn match  perlVarNotInMatches	 "$[|)]"
                            " This variable is not recognized within matches delimited by m//.
    1              0.000016 syn match  perlVarSlash		 "$/"
                            
                            " And plain identifiers
    1              0.000030 syn match  perlPackageRef	 "[$@#%*&]\%(\%(::\|'\)\=\I\i*\%(\%(::\|'\)\I\i*\)*\)\=\%(::\|'\)\I"ms=s+1,me=e-1 contained
                            
                            " To not highlight packages in variables as a scope reference - i.e. in
                            " $pack::var, pack:: is a scope, just set "perl_no_scope_in_variables"
                            " If you don't want complex things like @{${"foo"}} to be processed,
                            " just set the variable "perl_no_extended_vars"...
                            
    1              0.000009 if !exists("perl_no_scope_in_variables")
    1              0.000090   syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod
    1              0.000042   syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef
    1              0.000087   syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" contains=perlPackageRef nextgroup=perlVarMember,perlVarSimpleMember,perlMethod
    1              0.000003 else
                              syn match  perlVarPlain       "\%([@$]\|\$#\)\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod
                              syn match  perlVarPlain2                   "%\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)"
                              syn match  perlFunctionName                "&\$*\%(\I\i*\)\=\%(\%(::\|'\)\I\i*\)*\%(::\|\i\@<=\)" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod
                            endif
                            
    1              0.000008 if !exists("perl_no_extended_vars")
    1              0.000343   syn cluster perlExpr		contains=perlStatementIndirObjWrap,perlStatementScalar,perlStatementRegexp,perlStatementNumeric,perlStatementList,perlStatementHash,perlStatementFiles,perlStatementTime,perlStatementMisc,perlVarPlain,perlVarPlain2,perlVarNotInMatches,perlVarSlash,perlVarBlock,perlVarBlock2,perlShellCommand,perlFloat,perlNumber,perlStringUnexpanded,perlString,perlQQ,perlArrow,perlBraces
    1              0.000072   syn region perlArrow		matchgroup=perlArrow start="->\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod contained
    1              0.000090   syn region perlArrow		matchgroup=perlArrow start="->\s*\[" end="\]" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod contained
    1              0.000072   syn region perlArrow		matchgroup=perlArrow start="->\s*{" end="}" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod contained
    1              0.000079   syn match  perlArrow		"->\s*{\s*\I\i*\s*}" contains=perlVarSimpleMemberName nextgroup=perlVarMember,perlVarSimpleMember,perlMethod contained
    1              0.000072   syn region perlArrow		matchgroup=perlArrow start="->\s*\$*\I\i*\s*(" end=")" contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod contained
    1              0.000087   syn region perlVarBlock	matchgroup=perlVarPlain start="\%($#\|[$@]\)\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod extend
    1              0.000084   syn region perlVarBlock2	matchgroup=perlVarPlain start="[%&*]\$*{" skip="\\}" end=+}\|\%(\%(<<\%('\|"\)\?\)\@=\)+ contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod extend
    1              0.000067   syn match  perlVarPlain2	"[%&*]\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod extend
    1              0.000078   syn match  perlVarPlain	"\%(\$#\|[@$]\)\$*{\I\i*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod extend
    1              0.000076   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\={" skip="\\}" end="}" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod extend
    1              0.000080   syn match  perlVarSimpleMember	"\%(->\)\={\s*\I\i*\s*}" nextgroup=perlVarMember,perlVarSimpleMember,perlMethod contains=perlVarSimpleMemberName contained extend
    1              0.000014   syn match  perlVarSimpleMemberName	"\I\i*" contained
    1              0.000073   syn region perlVarMember	matchgroup=perlVarPlain start="\%(->\)\=\[" skip="\\]" end="]" contained contains=@perlExpr nextgroup=perlVarMember,perlVarSimpleMember,perlMethod extend
    1              0.000035   syn match perlPackageConst	"__PACKAGE__" nextgroup=perlMethod
    1              0.000060   syn match  perlMethod		"->\$*\I\i*" contained nextgroup=perlVarSimpleMember,perlVarMember,perlMethod
    1              0.000004 endif
                            
                            " File Descriptors
    1              0.000020 syn match  perlFiledescRead	"<\h\w*>"
                            
    1              0.000034 syn match  perlFiledescStatementComma	"(\=\s*\u\w*\s*,"me=e-1 transparent contained contains=perlFiledescStatement
    1              0.000034 syn match  perlFiledescStatementNocomma "(\=\s*\u\w*\s*[^, \t]"me=e-1 transparent contained contains=perlFiledescStatement
                            
    1              0.000014 syn match  perlFiledescStatement	"\u\w*" contained
                            
                            " Special characters in strings and matches
    1              0.000024 syn match  perlSpecialString	"\\\%(\o\{1,3}\|x\%({\x\+}\|\x\{1,2}\)\|c.\|[^cx]\)" contained extend
    1              0.000029 syn match  perlSpecialStringU2	"\\." extend contained contains=NONE
    1              0.000014 syn match  perlSpecialStringU	"\\\\" contained
    1              0.000014 syn match  perlSpecialMatch	"\\[1-9]" contained extend
    1              0.000021 syn match  perlSpecialMatch	"\\g\%(\d\+\|{\%(-\=\d\+\|\h\w*\)}\)" contained
    1              0.000019 syn match  perlSpecialMatch	"\\k\%(<\h\w*>\|'\h\w*'\)" contained
    1              0.000019 syn match  perlSpecialMatch	"{\d\+\%(,\%(\d\+\)\=\)\=}" contained
    1              0.000019 syn match  perlSpecialMatch	"\[[]-]\=[^\[\]]*[]-]\=\]" contained extend
    1              0.000014 syn match  perlSpecialMatch	"[+*()?.]" contained
    1              0.000014 syn match  perlSpecialMatch	"(?[#:=!]" contained
    1              0.000017 syn match  perlSpecialMatch	"(?[impsx]*\%(-[imsx]\+\)\=)" contained
    1              0.000018 syn match  perlSpecialMatch	"(?\%([-+]\=\d\+\|R\))" contained
    1              0.000018 syn match  perlSpecialMatch	"(?\%(&\|P[>=]\)\h\w*)" contained
    1              0.000030 syn match  perlSpecialMatch	"(\*\%(\%(PRUNE\|SKIP\|THEN\)\%(:[^)]*\)\=\|\%(MARK\|\):[^)]*\|COMMIT\|F\%(AIL\)\=\|ACCEPT\))" contained
                            
                            " Possible errors
                            "
                            " Highlight lines with only whitespace (only in blank delimited here documents) as errors
    1              0.000015 syn match  perlNotEmptyLine	"^\s\+$" contained
                            " Highlight "} else if (...) {", it should be "} else { if (...) { " or "} elsif (...) {"
    1              0.000036 syn match perlElseIfError	"else\_s*if" containedin=perlConditional
    1              0.000036 syn keyword perlElseIfError	elseif containedin=perlConditional
                            
                            " Variable interpolation
                            "
                            " These items are interpolated inside "" strings and similar constructs.
    1              0.000083 syn cluster perlInterpDQ	contains=perlSpecialString,perlVarPlain,perlVarNotInMatches,perlVarSlash,perlVarBlock
                            " These items are interpolated inside '' strings and similar constructs.
    1              0.000034 syn cluster perlInterpSQ	contains=perlSpecialStringU,perlSpecialStringU2
                            " These items are interpolated inside m// matches and s/// substitutions.
    1              0.000063 syn cluster perlInterpSlash	contains=perlSpecialString,perlSpecialMatch,perlVarPlain,perlVarBlock
                            " These items are interpolated inside m## matches and s### substitutions.
    1              0.000020 syn cluster perlInterpMatch	contains=@perlInterpSlash,perlVarSlash
                            
                            " Shell commands
    1              0.000031 syn region  perlShellCommand	matchgroup=perlMatchStartEnd start="`" end="`" contains=@perlInterpDQ keepend
                            
                            " Constants
                            "
                            " Numbers
    1              0.000036 syn match  perlNumber	"\<\%(0\%(x\x[[:xdigit:]_]*\|b[01][01_]*\|\o[0-7_]*\|\)\|[1-9][[:digit:]_]*\)\>"
    1              0.000024 syn match  perlFloat	"\<\d[[:digit:]_]*[eE][\-+]\=\d\+"
    1              0.000027 syn match  perlFloat	"\<\d[[:digit:]_]*\.[[:digit:]_]*\%([eE][\-+]\=\d\+\)\="
    1              0.000025 syn match  perlFloat    "\.[[:digit:]][[:digit:]_]*\%([eE][\-+]\=\d\+\)\="
                            
    1              0.000041 syn match  perlString	"\<\%(v\d\+\%(\.\d\+\)*\|\d\+\%(\.\d\+\)\{2,}\)\>" contains=perlVStringV
    1              0.000014 syn match  perlVStringV	"\<v" contained
                            
                            
    1              0.000033 syn region perlParensSQ		start=+(+ end=+)+ extend contained contains=perlParensSQ,@perlInterpSQ keepend
    1              0.000033 syn region perlBracketsSQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsSQ,@perlInterpSQ keepend
    1              0.000031 syn region perlBracesSQ		start=+{+ end=+}+ extend contained contains=perlBracesSQ,@perlInterpSQ keepend
    1              0.000030 syn region perlAnglesSQ		start=+<+ end=+>+ extend contained contains=perlAnglesSQ,@perlInterpSQ keepend
                            
    1              0.000030 syn region perlParensDQ		start=+(+ end=+)+ extend contained contains=perlParensDQ,@perlInterpDQ keepend
    1              0.000031 syn region perlBracketsDQ	start=+\[+ end=+\]+ extend contained contains=perlBracketsDQ,@perlInterpDQ keepend
    1              0.000031 syn region perlBracesDQ		start=+{+ end=+}+ extend contained contains=perlBracesDQ,@perlInterpDQ keepend
    1              0.000032 syn region perlAnglesDQ		start=+<+ end=+>+ extend contained contains=perlAnglesDQ,@perlInterpDQ keepend
                            
                            
                            " Simple version of searches and matches
    1              0.000045 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1[msixpodualgc]*+ contains=@perlInterpMatch keepend extend
    1              0.000036 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m#+ end=+#[msixpodualgc]*+ contains=@perlInterpMatch keepend extend
    1              0.000038 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*'+ end=+'[msixpodualgc]*+ contains=@perlInterpSQ keepend extend
    1              0.000039 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*/+ end=+/[msixpodualgc]*+ contains=@perlInterpSlash keepend extend
    1              0.000048 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*(+ end=+)[msixpodualgc]*+ contains=@perlInterpMatch,perlParensDQ keepend extend
                            
                            " A special case for m{}, m<> and m[] which allows for comments and extra whitespace in the pattern
    1              0.000061 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*{+ end=+}[msixpodualgc]*+ contains=@perlInterpMatch,perlComment,perlBracesDQ extend
    1              0.000048 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*<+ end=+>[msixpodualgc]*+ contains=@perlInterpMatch,perlAnglesDQ keepend extend
    1              0.000062 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!m\s*\[+ end=+\][msixpodualgc]*+ contains=@perlInterpMatch,perlComment,perlBracketsDQ keepend extend
                            
                            " Below some hacks to recognise the // variant. This is virtually impossible to catch in all
                            " cases as the / is used in so many other ways, but these should be the most obvious ones.
    1              0.000094 syn region perlMatch	matchgroup=perlMatchStartEnd start="\%([$@%&*]\@<!\%(\<split\|\<while\|\<if\|\<unless\|\.\.\|[-+*!~(\[{=]\)\s*\)\@<=/\%(/=\)\@!" start=+^/\%(/=\)\@!+ start=+\s\@<=/\%(/=\)\@![^[:space:][:digit:]$@%=]\@=\%(/\_s*\%([([{$@%&*[:digit:]"'`]\|\_s\w\|[[:upper:]_abd-fhjklnqrt-wyz]\)\)\@!+ skip=+\\/+ end=+/[msixpodualgc]*+ contains=@perlInterpSlash extend
                            
                            
                            " Substitutions
                            " perlMatch is the first part, perlSubstitution* is the substitution part
    1              0.000054 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\>\s*\z([^[:space:]'([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    1              0.000051 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*'+  end=+'+me=e-1 contains=@perlInterpSQ nextgroup=perlSubstitutionSQ keepend extend
    1              0.000050 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*/+  end=+/+me=e-1 contains=@perlInterpSlash nextgroup=perlSubstitutionGQQ keepend extend
    1              0.000047 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s#+  end=+#+me=e-1 contains=@perlInterpMatch nextgroup=perlSubstitutionGQQ keepend extend
    1              0.000062 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*(+ end=+)+ contains=@perlInterpMatch,perlParensDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    1              0.000062 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*<+ end=+>+ contains=@perlInterpMatch,perlAnglesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    1              0.000064 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*\[+ end=+\]+ contains=@perlInterpMatch,perlBracketsDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    1              0.000062 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!s\s*{+ end=+}+ contains=@perlInterpMatch,perlBracesDQ nextgroup=perlSubstitutionGQQ skipwhite skipempty skipnl keepend extend
    1              0.000032 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]'([{<]\)+ end=+\z1[msixpodualgcer]*+ keepend contained contains=@perlInterpDQ extend
    1              0.000041 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+(+ end=+)[msixpodualgcer]*+ contained contains=@perlInterpDQ,perlParensDQ keepend extend
    1              0.000043 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\][msixpodualgcer]*+ contained contains=@perlInterpDQ,perlBracketsDQ keepend extend
    1              0.000040 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+{+ end=+}[msixpodualgcer]*+ contained contains=@perlInterpDQ,perlBracesDQ keepend extend extend
    1              0.000042 syn region perlSubstitutionGQQ		matchgroup=perlMatchStartEnd start=+<+ end=+>[msixpodualgcer]*+ contained contains=@perlInterpDQ,perlAnglesDQ keepend extend
    1              0.000029 syn region perlSubstitutionSQ		matchgroup=perlMatchStartEnd start=+'+  end=+'[msixpodualgcer]*+ contained contains=@perlInterpSQ keepend extend
                            
                            " Translations
                            " perlMatch is the first part, perlTranslation* is the second, translator part.
    1              0.000058 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\>\s*\z([^[:space:]([{<#]\)+ end=+\z1+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    1              0.000052 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)#+ end=+#+me=e-1 contains=@perlInterpSQ nextgroup=perlTranslationGQ
    1              0.000064 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    1              0.000063 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    1              0.000068 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    1              0.000063 syn region perlMatch	matchgroup=perlMatchStartEnd start=+\<\%(::\|'\|->\)\@<!\%(tr\|y\)\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ nextgroup=perlTranslationGQ skipwhite skipempty skipnl
    1              0.000028 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\z([^[:space:]([{<]\)+ end=+\z1[cdsr]*+ contained
    1              0.000038 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+(+ end=+)[cdsr]*+ contains=perlParensSQ contained
    1              0.000038 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+\[+ end=+\][cdsr]*+ contains=perlBracketsSQ contained
    1              0.000037 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+{+ end=+}[cdsr]*+ contains=perlBracesSQ contained
    1              0.000037 syn region perlTranslationGQ		matchgroup=perlMatchStartEnd start=+<+ end=+>[cdsr]*+ contains=perlAnglesSQ contained
                            
                            
                            " Strings and q, qq, qw and qr expressions
                            
    1              0.000029 syn region perlStringUnexpanded	matchgroup=perlStringStartEnd start="'" end="'" contains=@perlInterpSQ keepend extend
    1              0.000029 syn region perlString		matchgroup=perlStringStartEnd start=+"+  end=+"+ contains=@perlInterpDQ keepend extend
    1              0.000039 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpSQ keepend extend
    1              0.000033 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q#+ end=+#+ contains=@perlInterpSQ keepend extend
    1              0.000048 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*(+ end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    1              0.000047 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*\[+ end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    1              0.000049 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*{+ end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    1              0.000051 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q\s*<+ end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    1              0.000039 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\>\s*\z([^[:space:]#([{<]\)+ end=+\z1+ contains=@perlInterpDQ keepend extend
    1              0.000035 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]#+ end=+#+ contains=@perlInterpDQ keepend extend
    1              0.000052 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*(+ end=+)+ contains=@perlInterpDQ,perlParensDQ keepend extend
    1              0.000049 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*\[+ end=+\]+ contains=@perlInterpDQ,perlBracketsDQ keepend extend
    1              0.000048 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*{+ end=+}+ contains=@perlInterpDQ,perlBracesDQ keepend extend
    1              0.000049 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!q[qx]\s*<+ end=+>+ contains=@perlInterpDQ,perlAnglesDQ keepend extend
                            
    1              0.000038 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\z([^[:space:]#([{<]\)+  end=+\z1+ contains=@perlInterpSQ keepend extend
    1              0.000036 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw#+  end=+#+ contains=@perlInterpSQ keepend extend
    1              0.000058 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*(+  end=+)+ contains=@perlInterpSQ,perlParensSQ keepend extend
    1              0.000116 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*\[+  end=+\]+ contains=@perlInterpSQ,perlBracketsSQ keepend extend
    1              0.000050 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*{+  end=+}+ contains=@perlInterpSQ,perlBracesSQ keepend extend
    1              0.000049 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qw\s*<+  end=+>+ contains=@perlInterpSQ,perlAnglesSQ keepend extend
                            
    1              0.000040 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\>\s*\z([^[:space:]#([{<'/]\)+  end=+\z1[imosx]*+ contains=@perlInterpMatch keepend extend
    1              0.000036 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*/+  end=+/[imosx]*+ contains=@perlInterpSlash keepend extend
    1              0.000038 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr#+  end=+#[imosx]*+ contains=@perlInterpMatch keepend extend
    1              0.000039 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*'+  end=+'[imosx]*+ contains=@perlInterpSQ keepend extend
    1              0.000050 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*(+  end=+)[imosx]*+ contains=@perlInterpMatch,perlParensDQ keepend extend
                            
                            " A special case for qr{}, qr<> and qr[] which allows for comments and extra whitespace in the pattern
    1              0.000061 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*{+  end=+}[imosx]*+ contains=@perlInterpMatch,perlBracesDQ,perlComment keepend extend
    1              0.000061 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*<+  end=+>[imosx]*+ contains=@perlInterpMatch,perlAnglesDQ,perlComment keepend extend
    1              0.000064 syn region perlQQ		matchgroup=perlStringStartEnd start=+\<\%(::\|'\|->\)\@<!qr\s*\[+  end=+\][imosx]*+ contains=@perlInterpMatch,perlBracketsDQ,perlComment keepend extend
                            
                            " Constructs such as print <<EOF [...] EOF, 'here' documents
                            "
                            " XXX Any statements after the identifier are in perlString colour (i.e.
                            " 'if $a' in 'print <<EOF if $a'). This is almost impossible to get right it
                            " seems due to the 'auto-extending nature' of regions.
    1              0.000008 if exists("perl_fold")
                              syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\z(\I\i*\).*+    end=+^\z1$+ contains=@perlInterpDQ fold extend
                              syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ end=+^\z1$+ contains=@perlInterpDQ fold extend
                              syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ end=+^\z1$+ contains=@perlInterpSQ fold extend
                              syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*""+           end=+^$+    contains=@perlInterpDQ,perlNotEmptyLine fold extend
                              syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*''+           end=+^$+    contains=@perlInterpSQ,perlNotEmptyLine fold extend
                              syn region perlAutoload	matchgroup=perlStringStartEnd start=+<<\s*\(['"]\=\)\z(END_\%(SUB\|OF_FUNC\|OF_AUTOLOAD\)\)\1+ end=+^\z1$+ contains=ALL fold extend
                            else
    1              0.000034   syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\z(\I\i*\).*+    end=+^\z1$+ contains=@perlInterpDQ
    1              0.000036   syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*"\z([^\\"]*\%(\\.[^\\"]*\)*\)"+ end=+^\z1$+ contains=@perlInterpDQ
    1              0.000034   syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*'\z([^\\']*\%(\\.[^\\']*\)*\)'+ end=+^\z1$+ contains=@perlInterpSQ
    1              0.000044   syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*""+           end=+^$+    contains=@perlInterpDQ,perlNotEmptyLine
    1              0.000044   syn region perlHereDoc	matchgroup=perlStringStartEnd start=+<<\s*''+           end=+^$+    contains=@perlInterpSQ,perlNotEmptyLine
    1              0.000038   syn region perlAutoload	matchgroup=perlStringStartEnd start=+<<\s*\(['"]\=\)\z(END_\%(SUB\|OF_FUNC\|OF_AUTOLOAD\)\)\1+ end=+^\z1$+ contains=ALL
    1              0.000003 endif
                            
                            
                            " Class declarations
                            "
    1              0.000040 syn match   perlPackageDecl		"\<package\s\+\%(\h\|::\)\%(\w\|::\)*" contains=perlStatementPackage
    1              0.000013 syn keyword perlStatementPackage	package contained
                            
                            " Functions
                            "       sub [name] [(prototype)] {
                            "
    1              0.000016 syn match perlSubError "[^[:space:];{#]" contained
    1              0.000007 if v:version == 701 && !has('patch221')  " XXX I hope that's the right one
                                syn match perlSubAttributes ":" contained
                            else
    1              0.000023     syn match perlSubAttributesCont "\h\w*\_s*\%(:\_s*\)\=" nextgroup=@perlSubAttrMaybe contained
    1              0.000046     syn region perlSubAttributesCont matchgroup=perlSubAttributesCont start="\h\w*(" end=")\_s*\%(:\_s*\)\=" nextgroup=@perlSubAttrMaybe contained contains=@perlInterpSQ,perlParensSQ
    1              0.000050     syn cluster perlSubAttrMaybe contains=perlSubAttributesCont,perlSubError,perlFakeGroup
    1              0.000026     syn match perlSubAttributes "" contained nextgroup=perlSubError
    1              0.000016     syn match perlSubAttributes ":\_s*" contained nextgroup=@perlSubAttrMaybe
    1              0.000003 endif
    1              0.000036 syn match perlSubPrototypeError "(\%(\_s*\%(\%(\\\%([$@%&*]\|\[[$@%&*]\+\]\)\|[$&*]\|[@%]\%(\_s*)\)\@=\|;\%(\_s*[)$@%&*\\]\)\@=\|_\%(\_s*[);]\)\@=\)\_s*\)*\)\@>\zs\_[^)]\+" contained
    1              0.000058 syn match perlSubPrototype +(\_[^)]*)\_s*\|+ nextgroup=perlSubAttributes,perlComment contained contains=perlSubPrototypeError
    1              0.000049 syn match perlSubName +\%(\h\|::\|'\w\)\%(\w\|::\|'\w\)*\_s*\|+ contained nextgroup=perlSubPrototype,perlComment
                            
    1              0.000034 syn match perlFunction +\<sub\>\_s*+ nextgroup=perlSubName
                            
    1              0.000008 if !exists("perl_no_scope_in_variables")
    1              0.000016    syn match  perlFunctionPRef	"\h\w*::" contained
    1              0.000015    syn match  perlFunctionName	"\h\w*[^:]" contained
    1              0.000003 else
                               syn match  perlFunctionName	"\h[[:alnum:]_:]*" contained
                            endif
                            
                            " The => operator forces a bareword to the left of it to be interpreted as
                            " a string
    1              0.000027 syn match  perlString "\I\@<!-\?\I\i*\%(\s*=>\)\@="
                            
                            " All other # are comments, except ^#!
    1              0.000037 syn match  perlComment		"#.*" contains=perlTodo,@Spell extend
    1              0.000019 syn match  perlSharpBang	"^#!.*"
                            
                            " Formats
    1              0.000098 syn region perlFormat		matchgroup=perlStatementIOFunc start="^\s*\<format\s\+\k\+\s*=\s*$"rs=s+6 end="^\s*\.\s*$" contains=perlFormatName,perlFormatField,perlVarPlain,perlVarPlain2
    1              0.000018 syn match  perlFormatName	"format\s\+\k\+\s*="lc=7,me=e-1 contained
    1              0.000017 syn match  perlFormatField	"[@^][|<>~]\+\%(\.\.\.\)\=" contained
    1              0.000014 syn match  perlFormatField	"[@^]#[#.]*" contained
    1              0.000013 syn match  perlFormatField	"@\*" contained
    1              0.000016 syn match  perlFormatField	"@[^A-Za-z_|<>~#*]"me=e-1 contained
    1              0.000015 syn match  perlFormatField	"@$" contained
                            
                            " __END__ and __DATA__ clauses
    1              0.000007 if exists("perl_fold")
                              syntax region perlDATA		start="^__DATA__$" skip="." end="." fold
                              syntax region perlDATA		start="^__END__$" skip="." end="." contains=perlPOD,@perlDATA fold
                            else
    1              0.000025   syntax region perlDATA		start="^__DATA__$" skip="." end="."
    1              0.000040   syntax region perlDATA		start="^__END__$" skip="." end="." contains=perlPOD,@perlDATA
    1              0.000003 endif
                            
                            "
                            " Folding
                            
    1              0.000006 if exists("perl_fold")
                              " Note: this bit must come before the actual highlighting of the "package"
                              " keyword, otherwise this will screw up Pod lines that match /^package/
                              if !exists("perl_nofold_packages")
                                syn region perlPackageFold start="^package \S\+;\s*\%(#.*\)\=$" end="^1;\=\s*\%(#.*\)\=$" end="\n\+package"me=s-1 transparent fold keepend
                              endif
                              if !exists("perl_nofold_subs")
                                if exists("perl_fold_anonymous_subs") && perl_fold_anonymous_subs
                                  syn region perlSubFold     start="\<sub\>[^\n;]*{" end="}" transparent fold keepend extend
                                  syn region perlSubFold     start="\<\%(BEGIN\|END\|CHECK\|INIT\)\>\s*{" end="}" transparent fold keepend
                                else
                                  syn region perlSubFold     start="^\z(\s*\)\<sub\>.*[^};]$" end="^\z1}\s*\%(#.*\)\=$" transparent fold keepend
                                  syn region perlSubFold start="^\z(\s*\)\<\%(BEGIN\|END\|CHECK\|INIT\|UNITCHECK\)\>.*[^};]$" end="^\z1}\s*$" transparent fold keepend
                                endif
                              endif
                            
                              if exists("perl_fold_blocks")
                                syn region perlBlockFold start="^\z(\s*\)\%(if\|elsif\|unless\|for\|while\|until\|given\)\s*(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" start="^\z(\s*\)foreach\s*\%(\%(my\|our\)\=\s*\S\+\s*\)\=(.*)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                                syn region perlBlockFold start="^\z(\s*\)\%(do\|else\)\%(\s*{\)\=\s*\%(#.*\)\=$" end="^\z1}\s*while" end="^\z1}\s*;\=\%(#.*\)\=$" transparent fold keepend
                              endif
                            
                              setlocal foldmethod=syntax
                              syn sync fromstart
                            else
                              " fromstart above seems to set minlines even if perl_fold is not set.
    1              0.000005   syn sync minlines=0
    1              0.000002 endif
                            
    1              0.000013 command -nargs=+ HiLink hi def link <args>
                            
                            " NOTE: If you're linking new highlight groups to perlString, please also put
                            "       them into b:match_skip in ftplugin/perl.vim.
                            
                            " The default highlighting.
    1              0.000032 HiLink perlSharpBang		PreProc
    1              0.000027 HiLink perlControl		PreProc
    1              0.000025 HiLink perlInclude		Include
    1              0.000025 HiLink perlSpecial		Special
    1              0.000025 HiLink perlString		String
    1              0.000025 HiLink perlCharacter		Character
    1              0.000025 HiLink perlNumber		Number
    1              0.000025 HiLink perlFloat		Float
    1              0.000025 HiLink perlType			Type
    1              0.000025 HiLink perlIdentifier		Identifier
    1              0.000025 HiLink perlLabel		Label
    1              0.000025 HiLink perlStatement		Statement
    1              0.000026 HiLink perlConditional		Conditional
    1              0.000025 HiLink perlRepeat		Repeat
    1              0.000026 HiLink perlOperator		Operator
    1              0.000025 HiLink perlFunction		Keyword
    1              0.000026 HiLink perlSubName		Function
    1              0.000025 HiLink perlSubPrototype		Type
    1              0.000025 HiLink perlSubAttributes	PreProc
    1              0.000019 HiLink perlSubAttributesCont	perlSubAttributes
    1              0.000025 HiLink perlComment		Comment
    1              0.000026 HiLink perlTodo			Todo
    1              0.000007 if exists("perl_string_as_statement")
                              HiLink perlStringStartEnd	perlStatement
                            else
    1              0.000019   HiLink perlStringStartEnd	perlString
    1              0.000002 endif
    1              0.000019 HiLink perlVStringV		perlStringStartEnd
    1              0.000018 HiLink perlList			perlStatement
    1              0.000023 HiLink perlMisc			perlStatement
    1              0.000019 HiLink perlVarPlain		perlIdentifier
    1              0.000018 HiLink perlVarPlain2		perlIdentifier
    1              0.000018 HiLink perlArrow		perlIdentifier
    1              0.000018 HiLink perlFiledescRead		perlIdentifier
    1              0.000018 HiLink perlFiledescStatement	perlIdentifier
    1              0.000019 HiLink perlVarSimpleMember	perlIdentifier
    1              0.000019 HiLink perlVarSimpleMemberName 	perlString
    1              0.000019 HiLink perlVarNotInMatches	perlIdentifier
    1              0.000018 HiLink perlVarSlash		perlIdentifier
    1              0.000019 HiLink perlQQ			perlString
    1              0.000018 HiLink perlHereDoc		perlString
    1              0.000019 HiLink perlStringUnexpanded	perlString
    1              0.000019 HiLink perlSubstitutionSQ	perlString
    1              0.000019 HiLink perlSubstitutionGQQ	perlString
    1              0.000019 HiLink perlTranslationGQ	perlString
    1              0.000018 HiLink perlMatch		perlString
    1              0.000018 HiLink perlMatchStartEnd	perlStatement
    1              0.000018 HiLink perlFormatName		perlIdentifier
    1              0.000020 HiLink perlFormatField		perlString
    1              0.000018 HiLink perlPackageDecl		perlType
    1              0.000017 HiLink perlStorageClass		perlType
    1              0.000018 HiLink perlPackageRef		perlType
    1              0.000018 HiLink perlStatementPackage	perlStatement
    1              0.000019 HiLink perlStatementStorage	perlStatement
    1              0.000019 HiLink perlStatementControl	perlStatement
    1              0.000019 HiLink perlStatementScalar	perlStatement
    1              0.000019 HiLink perlStatementRegexp	perlStatement
    1              0.000020 HiLink perlStatementNumeric	perlStatement
    1              0.000019 HiLink perlStatementList	perlStatement
    1              0.000019 HiLink perlStatementHash	perlStatement
    1              0.000019 HiLink perlStatementIOfunc	perlStatement
    1              0.000019 HiLink perlStatementFiledesc	perlStatement
    1              0.000019 HiLink perlStatementVector	perlStatement
    1              0.000019 HiLink perlStatementFiles	perlStatement
    1              0.000019 HiLink perlStatementFlow	perlStatement
    1              0.000019 HiLink perlStatementInclude	perlStatement
    1              0.000019 HiLink perlStatementProc	perlStatement
    1              0.000018 HiLink perlStatementSocket	perlStatement
    1              0.000019 HiLink perlStatementIPC		perlStatement
    1              0.000019 HiLink perlStatementNetwork	perlStatement
    1              0.000018 HiLink perlStatementPword	perlStatement
    1              0.000019 HiLink perlStatementTime	perlStatement
    1              0.000019 HiLink perlStatementMisc	perlStatement
    1              0.000019 HiLink perlStatementIndirObj	perlStatement
    1              0.000018 HiLink perlFunctionName		perlIdentifier
    1              0.000018 HiLink perlMethod		perlIdentifier
    1              0.000018 HiLink perlFunctionPRef		perlType
    1              0.000019 HiLink perlPOD			perlComment
    1              0.000019 HiLink perlShellCommand		perlString
    1              0.000017 HiLink perlSpecialAscii		perlSpecial
    1              0.000019 HiLink perlSpecialDollar	perlSpecial
    1              0.000019 HiLink perlSpecialString	perlSpecial
    1              0.000018 HiLink perlSpecialStringU	perlSpecial
    1              0.000018 HiLink perlSpecialMatch		perlSpecial
    1              0.000018 HiLink perlDATA			perlComment
                            
                            " NOTE: Due to a bug in Vim (or more likely, a misunderstanding on my part),
                            "       I had to remove the transparent property from the following regions
                            "       in order to get them to highlight correctly.  Feel free to remove
                            "       these and reinstate the transparent property if you know how.
    1              0.000019 HiLink perlParensSQ		perlString
    1              0.000019 HiLink perlBracketsSQ		perlString
    1              0.000019 HiLink perlBracesSQ		perlString
    1              0.000019 HiLink perlAnglesSQ		perlString
                            
    1              0.000018 HiLink perlParensDQ		perlString
    1              0.000044 HiLink perlBracketsDQ		perlString
    1              0.000021 HiLink perlBracesDQ		perlString
    1              0.000019 HiLink perlAnglesDQ		perlString
                            
    1              0.000019 HiLink perlSpecialStringU2	perlString
                            
                            " Possible errors
    1              0.000025 HiLink perlNotEmptyLine		Error
    1              0.000026 HiLink perlElseIfError		Error
    1              0.000025 HiLink perlSubPrototypeError	Error
    1              0.000025 HiLink perlSubError		Error
                            
    1              0.000004 delcommand HiLink
                            
                            " Syncing to speed up processing
                            "
    1              0.000008 if !exists("perl_no_sync_on_sub")
    1              0.000026   syn sync match perlSync	grouphere NONE "^\s*\<package\s"
    1              0.000022   syn sync match perlSync	grouphere NONE "^\s*\<sub\>"
    1              0.000019   syn sync match perlSync	grouphere NONE "^}"
    1              0.000003 endif
                            
    1              0.000006 if !exists("perl_no_sync_on_global_var")
    1              0.000026   syn sync match perlSync	grouphere NONE "^$\I[[:alnum:]_:]+\s*=\s*{"
    1              0.000026   syn sync match perlSync	grouphere NONE "^[@%]\I[[:alnum:]_:]+\s*=\s*("
    1              0.000003 endif
                            
    1              0.000005 if exists("perl_sync_dist")
                              execute "syn sync maxlines=" . perl_sync_dist
                            else
    1              0.000005   syn sync maxlines=100
    1              0.000002 endif
                            
    1              0.000030 syn sync match perlSyncPOD	grouphere perlPOD "^=pod"
    1              0.000029 syn sync match perlSyncPOD	grouphere perlPOD "^=head"
    1              0.000028 syn sync match perlSyncPOD	grouphere perlPOD "^=item"
    1              0.000022 syn sync match perlSyncPOD	grouphere NONE "^=cut"
                            
    1              0.000006 let b:current_syntax = "perl"
                            
    1              0.000006 if exists('&regexpengine')
    1              0.000013   let &regexpengine=s:regexpengine
    1              0.000004   unlet s:regexpengine
    1              0.000002 endif
                            
    1              0.000017 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " XXX Change to sts=4:sw=4
                            " vim:ts=8:sts=2:sw=2:expandtab:ft=vim

SCRIPT  /usr/share/nvim/runtime/syntax/pod.vim
Sourced 1 time
Total time:   0.001969
 Self time:   0.001969

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:      Perl POD format
                            " Maintainer:    vim-perl <vim-perl@googlegroups.com>
                            " Previously:    Scott Bigham <dsb@killerbunnies.org>
                            " Homepage:      http://github.com/vim-perl/vim-perl
                            " Bugs/requests: http://github.com/vim-perl/vim-perl/issues
                            " Last Change:   2013-07-21
                            
                            " To add embedded POD documentation highlighting to your syntax file, add
                            " the commands:
                            "
                            "   syn include @Pod <sfile>:p:h/pod.vim
                            "   syn region myPOD start="^=pod" start="^=head" end="^=cut" keepend contained contains=@Pod
                            "
                            " and add myPod to the contains= list of some existing region, probably a
                            " comment.  The "keepend" flag is needed because "=cut" is matched as a
                            " pattern in its own right.
                            
                            
                            " Remove any old syntax stuff hanging around (this is suppressed
                            " automatically by ":syn include" if necessary).
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
    1              0.000006 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000014 let s:cpo_save = &cpo
    1              0.000013 set cpo&vim
                            
                            " POD commands
    1              0.000047 syn match podCommand    "^=encoding"  nextgroup=podCmdText contains=@NoSpell
    1              0.000035 syn match podCommand    "^=head[1234]"  nextgroup=podCmdText contains=@NoSpell
    1              0.000034 syn match podCommand    "^=item"        nextgroup=podCmdText contains=@NoSpell
    1              0.000033 syn match podCommand    "^=over"        nextgroup=podOverIndent skipwhite contains=@NoSpell
    1              0.000016 syn match podCommand    "^=back"        contains=@NoSpell
    1              0.000016 syn match podCommand    "^=cut"         contains=@NoSpell
    1              0.000017 syn match podCommand    "^=pod"         contains=@NoSpell
    1              0.000032 syn match podCommand    "^=for"         nextgroup=podForKeywd skipwhite contains=@NoSpell
    1              0.000034 syn match podCommand    "^=begin"       nextgroup=podForKeywd skipwhite contains=@NoSpell
    1              0.000032 syn match podCommand    "^=end"         nextgroup=podForKeywd skipwhite contains=@NoSpell
                            
                            " Text of a =head1, =head2 or =item command
    1              0.000032 syn match podCmdText	".*$" contained contains=podFormat,@NoSpell
                            
                            " Indent amount of =over command
    1              0.000016 syn match podOverIndent	"\d\+" contained contains=@NoSpell
                            
                            " Formatter identifier keyword for =for, =begin and =end commands
    1              0.000016 syn match podForKeywd	"\S\+" contained contains=@NoSpell
                            
                            " An indented line, to be displayed verbatim
    1              0.000017 syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                            " Inline textual items handled specially by POD
    1              0.000025 syn match podSpecial	"\(\<\|&\)\I\i*\(::\I\i*\)*([^)]*)" contains=@NoSpell
    1              0.000021 syn match podSpecial	"[$@%]\I\i*\(::\I\i*\)*\>" contains=@NoSpell
                            
                            " Special formatting sequences
    1              0.000039 syn region podFormat	start="[IBSCLFX]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
    1              0.000038 syn region podFormat	start="[IBSCLFX]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
    1              0.000016 syn match  podFormat	"Z<>"
    1              0.000051 syn match  podFormat	"E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
    1              0.000018 syn match  podEscape	"\I\i*>"me=e-1 contained contains=@NoSpell
    1              0.000016 syn match  podEscape2	"\d\+>"me=e-1 contained contains=@NoSpell
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    1              0.000006 if version >= 508 || !exists("did_pod_syntax_inits")
    1              0.000003   if version < 508
                                let did_pod_syntax_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    1              0.000012     command -nargs=+ HiLink hi def link <args>
    1              0.000002   endif
                            
    1              0.000032   HiLink podCommand		Statement
    1              0.000028   HiLink podCmdText		String
    1              0.000026   HiLink podOverIndent		Number
    1              0.000027   HiLink podForKeywd		Identifier
    1              0.000026   HiLink podFormat		Identifier
    1              0.000061   HiLink podVerbatimLine	PreProc
    1              0.000030   HiLink podSpecial		Identifier
    1              0.000026   HiLink podEscape		String
    1              0.000026   HiLink podEscape2		Number
                            
    1              0.000004   delcommand HiLink
    1              0.000002 endif
                            
    1              0.000007 if exists("perl_pod_spellcheck_headings")
                              " Spell-check headings
                              syn clear podCmdText
                              syn match podCmdText    ".*$" contained contains=podFormat
                            endif
                            
    1              0.000006 if exists("perl_pod_formatting")
                              " By default, escapes like C<> are not checked for spelling. Remove B<>
                              " and I<> from the list of escapes.
                              syn clear podFormat
                              syn region podFormat start="[CLF]<[^<]"me=e-1 end=">" oneline contains=podFormat,@NoSpell
                              syn region podFormat start="[CLF]<<\s" end="\s>>" oneline contains=podFormat,@NoSpell
                            
                              " Don't spell-check inside E<>, but ensure that the E< itself isn't
                              " marked as a spelling mistake.
                              syn match podFormat   "E<\(\d\+\|\I\i*\)>" contains=podEscape,podEscape2,@NoSpell
                            
                              " Z<> is a mock formatting code. Ensure Z<> on its own isn't marked as a
                              " spelling mistake.
                              syn match podFormat   "Z<>" contains=podEscape,podEscape2,@NoSpell
                            
                              " These are required so that whatever is *within* B<...>, I<...>, etc. is
                              " spell-checked, but not the B, I, ... itself.
                              syn match podBoldOpen    "B<" contains=@NoSpell
                              syn match podItalicOpen  "I<" contains=@NoSpell
                              syn match podNoSpaceOpen "S<" contains=@NoSpell
                              syn match podIndexOpen   "X<" contains=@NoSpell
                            
                              " Same as above but for the << >> syntax.
                              syn match podBoldAlternativeDelimOpen    "B<< " contains=@NoSpell
                              syn match podItalicAlternativeDelimOpen  "I<< " contains=@NoSpell
                              syn match podNoSpaceAlternativeDelimOpen "S<< " contains=@NoSpell
                              syn match podIndexAlternativeDelimOpen   "X<< " contains=@NoSpell
                            
                              " Add support for spell checking text inside B<>, I<>, S<> and X<>.
                              syn region podBold start="B<[^<]"me=e end=">" oneline contains=podBoldItalic,podBoldOpen
                              syn region podBoldAlternativeDelim start="B<<\s" end="\s>>" oneline contains=podBoldAlternativeDelimOpen
                            
                              syn region podItalic start="I<[^<]"me=e end=">" oneline contains=podItalicBold,podItalicOpen
                              syn region podItalicAlternativeDelim start="I<<\s" end="\s>>" oneline contains=podItalicAlternativeDelimOpen
                            
                              " Nested bold/italic and vice-versa
                              syn region podBoldItalic contained start="I<[^<]"me=e end=">" oneline
                              syn region podItalicBold contained start="B<[^<]"me=e end=">" oneline
                            
                              syn region podNoSpace start="S<[^<]"ms=s-2 end=">"me=e oneline contains=podNoSpaceOpen
                              syn region podNoSpaceAlternativeDelim start="S<<\s"ms=s-2 end="\s>>"me=e oneline contains=podNoSpaceAlternativeDelimOpen
                            
                              syn region podIndex start="X<[^<]"ms=s-2 end=">"me=e oneline contains=podIndexOpen
                              syn region podIndexAlternativeDelim start="X<<\s"ms=s-2 end="\s>>"me=e oneline contains=podIndexAlternativeDelimOpen
                            
                              " Restore this (otherwise B<> is shown as bold inside verbatim)
                              syn match podVerbatimLine	"^\s.*$" contains=@NoSpell
                            
                              " Ensure formatted text can be displayed in headings and items
                              syn clear podCmdText
                            
                              if exists("perl_pod_spellcheck_headings")
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \podBoldOpen,podItalicOpen,podBoldAlternativeDelimOpen,
                                      \podItalicAlternativeDelimOpen,podNoSpaceOpen
                              else
                                syn match podCmdText ".*$" contained contains=podFormat,podBold,
                                      \podBoldAlternativeDelim,podItalic,podItalicAlternativeDelim,
                                      \@NoSpell
                              endif
                            
                              " Specify how to display these
                              hi def podBold term=bold cterm=bold gui=bold
                            
                              hi link podBoldAlternativeDelim podBold
                              hi link podBoldAlternativeDelimOpen podBold
                              hi link podBoldOpen podBold
                            
                              hi link podNoSpace                 Identifier
                              hi link podNoSpaceAlternativeDelim Identifier
                            
                              hi link podIndex                   Identifier
                              hi link podIndexAlternativeDelim   Identifier
                            
                              hi def podItalic term=italic cterm=italic gui=italic
                            
                              hi link podItalicAlternativeDelim podItalic
                              hi link podItalicAlternativeDelimOpen podItalic
                              hi link podItalicOpen podItalic
                            
                              hi def podBoldItalic term=italic,bold cterm=italic,bold gui=italic,bold
                              hi def podItalicBold term=italic,bold cterm=italic,bold gui=italic,bold
                            endif
                            
    1              0.000006 let b:current_syntax = "pod"
                            
    1              0.000017 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/ruby.vim
Sourced 1 time
Total time:   0.008585
 Self time:   0.008585

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
    1              0.000008 if exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000009 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
                            endif
                            
    1              0.000080 syn cluster rubyNotTop contains=@rubyExtendedStringSpecial,@rubyRegexpSpecial,@rubyDeclaration,rubyConditional,rubyExceptional,rubyMethodExceptional,rubyTodo
                            
    1              0.000006 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
                            endif
                            
                            " Operators
    1              0.000006 if exists("ruby_operators")
                              syn match  rubyOperator "[~!^&|*/%+-]\|\%(class\s*\)\@<!<<\|<=>\|<=\|\%(<\|\<class\s\+\u\w*\s*\)\@<!<[^<]\@=\|===\|==\|=\~\|>>\|>=\|=\@<!>\|\*\*\|\.\.\.\|\.\.\|::"
                              syn match  rubyOperator "->\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|&&\|||=\||=\|||\|%=\|+=\|!\~\|!="
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\w[?!]\=\|[]})]\)\@<=\[\s*" end="\s*]" contains=ALLBUT,@rubyNotTop
                            endif
                            
                            " Expression Substitution and Backslash Notation
    1              0.000025 syn match rubyStringEscape "\\\\\|\\[abefnrstv]\|\\\o\{1,3}\|\\x\x\{1,2}"						    contained display
    1              0.000027 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)" contained display
    1              0.000015 syn match rubyQuoteEscape  "\\[\\']"											    contained display
                            
    1              0.000032 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    1              0.000096 syn match  rubyInterpolation	      "#\%(\$\|@@\=\)\w\+"    display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable,rubyPredefinedVariable
    1              0.000023 syn match  rubyInterpolationDelimiter "#\ze\%(\$\|@@\=\)\w\+" display contained
    1              0.000069 syn match  rubyInterpolation	      "#\$\%(-\w\|\W\)"       display contained contains=rubyInterpolationDelimiter,rubyPredefinedVariable,rubyInvalidVariable
    1              0.000022 syn match  rubyInterpolationDelimiter "#\ze\$\%(-\w\|\W\)"    display contained
    1              0.000037 syn region rubyNoInterpolation	      start="\\#{" end="}"            contained
    1              0.000015 syn match  rubyNoInterpolation	      "\\#{"		      display contained
    1              0.000016 syn match  rubyNoInterpolation	      "\\#\%(\$\|@@\=\)\w\+"  display contained
    1              0.000014 syn match  rubyNoInterpolation	      "\\#\$\W"		      display contained
                            
    1              0.000031 syn match rubyDelimEscape	"\\[(<{\[)>}\]]" transparent display contained contains=NONE
                            
    1              0.000036 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  matchgroup=rubyString end=")"	transparent contained
    1              0.000029 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  matchgroup=rubyString end="}"	transparent contained
    1              0.000030 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  matchgroup=rubyString end=">"	transparent contained
    1              0.000025 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" matchgroup=rubyString end="\]"	transparent contained
                            
                            " These are mostly Oniguruma ready
    1              0.000028 syn region rubyRegexpComment	matchgroup=rubyRegexpSpecial   start="(?#"								  skip="\\)"  end=")"  contained
    1              0.000037 syn region rubyRegexpParens	matchgroup=rubyRegexpSpecial   start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
    1              0.000063 syn region rubyRegexpBrackets	matchgroup=rubyRegexpCharClass start="\[\^\="								  skip="\\\]" end="\]" contained transparent contains=rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass oneline
    1              0.000015 syn match  rubyRegexpCharClass	"\\[DdHhSsWw]"	       contained display
    1              0.000030 syn match  rubyRegexpCharClass	"\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\):\]" contained
    1              0.000016 syn match  rubyRegexpEscape	"\\[].*?+^$|\\/(){}[]" contained
    1              0.000014 syn match  rubyRegexpQuantifier	"[*?+][?+]\="	       contained display
    1              0.000018 syn match  rubyRegexpQuantifier	"{\d\+\%(,\d*\)\=}?\=" contained display
    1              0.000015 syn match  rubyRegexpAnchor	"[$^]\|\\[ABbGZz]"     contained display
    1              0.000012 syn match  rubyRegexpDot	"\."		       contained display
    1              0.000012 syn match  rubyRegexpSpecial	"|"		       contained display
    1              0.000016 syn match  rubyRegexpSpecial	"\\[1-9]\d\=\d\@!"     contained display
    1              0.000019 syn match  rubyRegexpSpecial	"\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    1              0.000020 syn match  rubyRegexpSpecial	"\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    1              0.000017 syn match  rubyRegexpSpecial	"\\g<\%([a-z_]\w*\|-\=\d\+\)>" contained display
    1              0.000018 syn match  rubyRegexpSpecial	"\\g'\%([a-z_]\w*\|-\=\d\+\)'" contained display
                            
    1              0.000046 syn cluster rubyStringSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape
    1              0.000058 syn cluster rubyExtendedStringSpecial contains=@rubyStringSpecial,rubyNestedParentheses,rubyNestedCurlyBraces,rubyNestedAngleBrackets,rubyNestedSquareBrackets
    1              0.000154 syn cluster rubyRegexpSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment
                            
                            " Numbers and ASCII Codes
    1              0.000034 syn match rubyASCIICode	"\%(\w\|[]})\"'/]\)\@<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)"
    1              0.000026 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*\>"								display
    1              0.000026 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)\>"						display
    1              0.000021 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*\>"								display
    1              0.000023 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*\>"								display
    1              0.000023 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*\>"					display
    1              0.000028 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)\>"	display
                            
                            " Identifiers
    1              0.000042 syn match rubyLocalVariableOrMethod "\<[_[:lower:]][_[:alnum:]]*[?!=]\=" contains=NONE display transparent
    1              0.000031 syn match rubyBlockArgument	    "&[_[:lower:]][_[:alnum:]]"		 contains=NONE display transparent
                            
    1              0.000033 syn match  rubyConstant		"\%(\%([.@$]\@<!\.\)\@<!\<\|::\)\_s*\zs\u\w*\%(\>\|::\)\@=\%(\s*(\)\@!"
    1              0.000021 syn match  rubyClassVariable	"@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    1              0.000023 syn match  rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  display
    1              0.000020 syn match  rubyGlobalVariable	"$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    1              0.000035 syn match  rubySymbol		"[]})\"':]\@<!:\%(\^\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)"
    1              0.000027 syn match  rubySymbol		"[]})\"':]\@<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"
    1              0.000031 syn match  rubySymbol		"[]})\"':]\@<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"
    1              0.000032 syn match  rubySymbol		"[]})\"':]\@<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\="
    1              0.000027 syn match  rubySymbol		"\%([{(,]\_s*\)\@<=\l\w*[!?]\=::\@!"he=e-1
    1              0.000029 syn match  rubySymbol		"[]})\"':]\@<!\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:\s\@="he=e-1
    1              0.000028 syn match  rubySymbol		"\%([{(,]\_s*\)\@<=[[:space:],{]\l\w*[!?]\=::\@!"hs=s+1,he=e-1
    1              0.000029 syn match  rubySymbol		"[[:space:],{]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:\s\@="hs=s+1,he=e-1
    1              0.000046 syn region rubySymbol		start="[]})\"':]\@<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape fold
    1              0.000031 syn region rubySymbol		start="[]})\"':]\@<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial fold
                            
    1              0.000018 syn match  rubyBlockParameter	  "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" contained
    1              0.000036 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\s*\)\@<=|" end="|" oneline display contains=rubyBlockParameter
                            
    1              0.000016 syn match rubyInvalidVariable	 "$[^ A-Za-z_-]"
    1              0.000018 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<=>?@\`~]#
    1              0.000020 syn match rubyPredefinedVariable "$\d\+"										   display
    1              0.000017 syn match rubyPredefinedVariable "$_\>"											   display
    1              0.000018 syn match rubyPredefinedVariable "$-[0FIKadilpvw]\>"									   display
    1              0.000021 syn match rubyPredefinedVariable "$\%(deferr\|defout\|stderr\|stdin\|stdout\)\>"					   display
    1              0.000026 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|KCODE\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    1              0.000024 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(MatchingData\|ARGF\|ARGV\|ENV\)\>\%(\s*(\)\@!"
    1              0.000022 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(DATA\|FALSE\|NIL\)\>\%(\s*(\)\@!"
    1              0.000026 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\|TRUE\)\>\%(\s*(\)\@!"
    1              0.000034 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Normal Regular Expression
    1              0.000053 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    1              0.000044 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
                            
                            " Generalized Regular Expression
    1              0.000037 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.? /]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    1              0.000031 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				 end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial fold
    1              0.000054 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				 end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimEscape fold
    1              0.000028 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				 end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial fold
    1              0.000029 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				 end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial fold
                            
                            " Normal String and Shell Command Output
    1              0.000037 syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial,@Spell fold
    1              0.000051 syn region rubyString matchgroup=rubyStringDelimiter start="'"	end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape,@Spell    fold
    1              0.000035 syn region rubyString matchgroup=rubyStringDelimiter start="`"	end="`"  skip="\\\\\|\\`"  contains=@rubyStringSpecial fold
                            
                            " Generalized Single Quoted String, Symbol and Array of Strings
    1              0.000043 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" fold
    1              0.000061 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]{"				   end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimEscape
    1              0.000061 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]<"				   end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimEscape
    1              0.000059 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]\["				   end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimEscape
    1              0.000059 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]("				   end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimEscape
    1              0.000034 syn region rubyString matchgroup=rubyStringDelimiter start="%q "				   end=" "   skip="\\\\\|\\)"	fold
    1              0.000055 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.? /]\)"   end="\z1" skip="\\\\\|\\\z1" fold
    1              0.000063 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				   end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimEscape
    1              0.000063 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				   end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimEscape
    1              0.000065 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				   end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimEscape
    1              0.000058 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				   end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimEscape
                            
                            " Generalized Double Quoted String and Array of Strings and Shell Command Output
                            " Note: %= is not matched here as the beginning of a double quoted string
    1              0.000040 syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	    end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    1              0.000043 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    1              0.000063 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\={"				    end="}"   skip="\\\\\|\\}"	 contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimEscape    fold
    1              0.000062 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\=<"				    end=">"   skip="\\\\\|\\>"	 contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimEscape  fold
    1              0.000061 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\=\["				    end="\]"  skip="\\\\\|\\\]"	 contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimEscape fold
    1              0.000060 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\=("				    end=")"   skip="\\\\\|\\)"	 contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimEscape    fold
    1              0.000038 syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx] "				    end=" "   skip="\\\\\|\\)"   contains=@rubyStringSpecial fold
                            
                            " Here Document
    1              0.000048 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+	 end=+$+ oneline contains=ALLBUT,@rubyNotTop
    1              0.000042 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs"\%([^"]*\)"+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    1              0.000041 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs'\%([^']*\)'+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    1              0.000041 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs`\%([^`]*\)`+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    1              0.000075 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    1              0.000069 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    1              0.000068 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc			fold keepend
    1              0.000070 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
                            
    1              0.000064 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    1              0.000059 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-"\z([^"]*\)"\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    1              0.000066 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-'\z([^']*\)'\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		     fold keepend
    1              0.000057 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-`\z([^`]*\)`\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
                            
    1              0.000009 if exists('main_syntax') && main_syntax == 'eruby'
                              let b:ruby_no_expensive = 1
                            end
                            
    1              0.000086 syn match  rubyAliasDeclaration    "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable nextgroup=rubyAliasDeclaration2 skipwhite
    1              0.000071 syn match  rubyAliasDeclaration2   "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable
    1              0.000105 syn match  rubyMethodDeclaration   "[^[:space:];#(]\+"	 contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    1              0.000053 syn match  rubyClassDeclaration    "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    1              0.000053 syn match  rubyModuleDeclaration   "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    1              0.000030 syn match  rubyFunction "\<[_[:alpha:]][_[:alnum:]]*[?!=]\=[[:alnum:]_.:?!=]\@!" contained containedin=rubyMethodDeclaration
    1              0.000043 syn match  rubyFunction "\%(\s\|^\)\@<=[_[:alpha:]][_[:alnum:]]*[?!=]\=\%(\s\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    1              0.000068 syn match  rubyFunction "\%([[:space:].]\|^\)\@<=\%(\[\]=\=\|\*\*\|[+-]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    1              0.000089 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyFunction,rubyBlockParameter
                            
                            " Keywords
                            " Note: the following keywords have already been defined:
                            " begin case class def do end for if module unless until while
    1              0.000023 syn match   rubyControl	       "\<\%(and\|break\|in\|next\|not\|or\|redo\|rescue\|retry\|return\)\>[?!]\@!"
    1              0.000016 syn match   rubyOperator       "\<defined?" display
    1              0.000018 syn match   rubyKeyword	       "\<\%(super\|yield\)\>[?!]\@!"
    1              0.000019 syn match   rubyBoolean	       "\<\%(true\|false\)\>[?!]\@!"
    1              0.000024 syn match   rubyPseudoVariable "\<\%(nil\|self\|__ENCODING__\|__FILE__\|__LINE__\|__callee__\|__method__\)\>[?!]\@!" " TODO: reorganise
    1              0.000017 syn match   rubyBeginEnd       "\<\%(BEGIN\|END\)\>[?!]\@!"
                            
                            " Expensive Mode - match 'end' with the appropriate opening keyword for syntax
                            " based folding and special highlighting of module/class/method definitions
    1              0.000011 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
    1              0.000029   syn match  rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration  skipwhite skipnl
    1              0.000028   syn match  rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
    1              0.000028   syn match  rubyDefine "\<undef\>"  nextgroup=rubyFunction	     skipwhite skipnl
    1              0.000028   syn match  rubyClass	"\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
    1              0.000027   syn match  rubyModule "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                            
    1              0.000033   syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
    1              0.000029   syn region rubyBlock	     start="\<class\>"	matchgroup=rubyClass  end="\<end\>"		       contains=ALLBUT,@rubyNotTop fold
    1              0.000027   syn region rubyBlock	     start="\<module\>" matchgroup=rubyModule end="\<end\>"		       contains=ALLBUT,@rubyNotTop fold
                            
                              " modifiers
    1              0.000018   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"    display
    1              0.000017   syn match rubyRepeatModifier	     "\<\%(while\|until\)\>" display
                            
    1              0.000030   syn region rubyDoBlock      matchgroup=rubyControl start="\<do\>" end="\<end\>"                 contains=ALLBUT,@rubyNotTop fold
                              " curly bracket block or hash literal
    1              0.000034   syn region rubyCurlyBlock	matchgroup=rubyCurlyBlockDelimiter  start="{" end="}"				contains=ALLBUT,@rubyNotTop fold
    1              0.000031   syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter	    start="\%(\w\|[\]})]\)\@<!\[" end="]"	contains=ALLBUT,@rubyNotTop fold
                            
                              " statements without 'do'
    1              0.000028   syn region rubyBlockExpression       matchgroup=rubyControl	  start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    1              0.000042   syn region rubyCaseExpression	       matchgroup=rubyConditional start="\<case\>"  end="\<end\>" contains=ALLBUT,@rubyNotTop fold
    1              0.000057   syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
                            
    1              0.000039   syn match rubyConditional "\<\%(then\|else\|when\)\>[?!]\@!"	contained containedin=rubyCaseExpression
    1              0.000036   syn match rubyConditional "\<\%(then\|else\|elsif\)\>[?!]\@!" contained containedin=rubyConditionalExpression
                            
    1              0.000032   syn match rubyExceptional	  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyBlockExpression
    1              0.000033   syn match rubyMethodExceptional "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyMethodBlock
                            
                              " statements with optional 'do'
    1              0.000070   syn region rubyOptionalDoLine   matchgroup=rubyRepeat start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\%(\<do\>\)" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
    1              0.000068   syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine fold
                            
    1              0.000008   if !exists("ruby_minlines")
                                let ruby_minlines = 500
                              endif
    1              0.000015   exec "syn sync minlines=" . ruby_minlines
                            
    1              0.000002 else
                              syn match rubyControl "\<def\>[?!]\@!"    nextgroup=rubyMethodDeclaration skipwhite skipnl
                              syn match rubyControl "\<class\>[?!]\@!"  nextgroup=rubyClassDeclaration  skipwhite skipnl
                              syn match rubyControl "\<module\>[?!]\@!" nextgroup=rubyModuleDeclaration skipwhite skipnl
                              syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|ensure\|then\|when\|end\)\>[?!]\@!"
                              syn match rubyKeyword "\<\%(alias\|undef\)\>[?!]\@!"
                            endif
                            
                            " Special Methods
    1              0.000007 if !exists("ruby_no_special_methods")
    1              0.000020   syn keyword rubyAccess    public protected private public_class_method private_class_method public_constant private_constant module_function
                              " attr is a common variable name
    1              0.000030   syn match   rubyAttribute "\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!"
    1              0.000026   syn keyword rubyAttribute attr_accessor attr_reader attr_writer
    1              0.000159   syn match   rubyControl   "\<\%(exit!\|\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>[?!]\@!\)"
    1              0.000019   syn keyword rubyEval	    eval class_eval instance_eval module_eval
    1              0.000016   syn keyword rubyException raise fail catch throw
                              " false positive with 'include?'
    1              0.000027   syn match   rubyInclude   "\<include\>[?!]\@!"
    1              0.000025   syn keyword rubyInclude   autoload extend load prepend require require_relative
    1              0.000016   syn keyword rubyKeyword   callcc caller lambda proc
    1              0.000002 endif
                            
                            " Comments and Documentation
    1              0.000018 syn match   rubySharpBang "\%^#!.*" display
    1              0.000015 syn keyword rubyTodo	  FIXME NOTE TODO OPTIMIZE XXX todo contained
    1              0.000054 syn match   rubyComment   "#.*" contains=rubySharpBang,rubySpaceError,rubyTodo,@Spell
    1              0.000008 if !exists("ruby_no_comment_fold")
    1              0.000063   syn region rubyMultilineComment start="\%(\%(^\s*#.*\n\)\@<!\%(^\s*#.*\n\)\)\%(\(^\s*#.*\n\)\{1,}\)\@=" end="\%(^\s*#.*\n\)\@<=\%(^\s*#.*\n\)\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    1              0.000053   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$" contains=rubySpaceError,rubyTodo,@Spell fold
    1              0.000005 else
                              syn region rubyDocumentation	  start="^=begin\s*$" end="^=end\s*$" contains=rubySpaceError,rubyTodo,@Spell
                            endif
                            
                            " Note: this is a hack to prevent 'keywords' being highlighted as such when called as methods with an explicit receiver
    1              0.000043 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(alias\|and\|begin\|break\|case\|class\|def\|defined\|do\|else\)\>"		  transparent contains=NONE
    1              0.000044 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(elsif\|end\|ensure\|false\|for\|if\|in\|module\|next\|nil\)\>"		  transparent contains=NONE
    1              0.000054 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(not\|or\|redo\|rescue\|retry\|return\|self\|super\|then\|true\)\>"		  transparent contains=NONE
    1              0.000042 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(undef\|unless\|until\|when\|while\|yield\|BEGIN\|END\|__FILE__\|__LINE__\)\>" transparent contains=NONE
                            
    1              0.000036 syn match rubyKeywordAsMethod "\<\%(alias\|begin\|case\|class\|def\|do\|end\)[?!]" transparent contains=NONE
    1              0.000036 syn match rubyKeywordAsMethod "\<\%(if\|module\|undef\|unless\|until\|while\)[?!]" transparent contains=NONE
                            
    1              0.000041 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(abort\|at_exit\|attr\|attr_accessor\|attr_reader\)\>"	transparent contains=NONE
    1              0.000052 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(attr_writer\|autoload\|callcc\|catch\|caller\)\>"		transparent contains=NONE
    1              0.000042 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(eval\|class_eval\|instance_eval\|module_eval\|exit\)\>"	transparent contains=NONE
    1              0.000038 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(extend\|fail\|fork\|include\|lambda\)\>"			transparent contains=NONE
    1              0.000038 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(load\|loop\|prepend\|private\|proc\|protected\)\>"		transparent contains=NONE
    1              0.000041 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(public\|require\|require_relative\|raise\|throw\|trap\)\>"	transparent contains=NONE
                            
                            " __END__ Directive
    1              0.000028 syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$" fold
                            
    1              0.000015 hi def link rubyClass			rubyDefine
    1              0.000014 hi def link rubyModule			rubyDefine
    1              0.000014 hi def link rubyMethodExceptional	rubyDefine
    1              0.000021 hi def link rubyDefine			Define
    1              0.000021 hi def link rubyFunction		Function
    1              0.000028 hi def link rubyConditional		Conditional
    1              0.000021 hi def link rubyConditionalModifier	rubyConditional
    1              0.000021 hi def link rubyExceptional		rubyConditional
    1              0.000028 hi def link rubyRepeat			Repeat
    1              0.000022 hi def link rubyRepeatModifier		rubyRepeat
    1              0.000020 hi def link rubyOptionalDo		rubyRepeat
    1              0.000021 hi def link rubyControl			Statement
    1              0.000028 hi def link rubyInclude			Include
    1              0.000021 hi def link rubyInteger			Number
    1              0.000021 hi def link rubyASCIICode		Character
    1              0.000021 hi def link rubyFloat			Float
    1              0.000021 hi def link rubyBoolean			Boolean
    1              0.000021 hi def link rubyException		Exception
    1              0.000007 if !exists("ruby_no_identifiers")
    1              0.000022   hi def link rubyIdentifier		Identifier
    1              0.000002 else
                              hi def link rubyIdentifier		NONE
                            endif
    1              0.000014 hi def link rubyClassVariable		rubyIdentifier
    1              0.000028 hi def link rubyConstant		Type
    1              0.000014 hi def link rubyGlobalVariable		rubyIdentifier
    1              0.000013 hi def link rubyBlockParameter		rubyIdentifier
    1              0.000013 hi def link rubyInstanceVariable	rubyIdentifier
    1              0.000013 hi def link rubyPredefinedIdentifier	rubyIdentifier
    1              0.000013 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    1              0.000014 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    1              0.000029 hi def link rubySymbol			Constant
    1              0.000021 hi def link rubyKeyword			Keyword
    1              0.000021 hi def link rubyOperator		Operator
    1              0.000021 hi def link rubyBeginEnd		Statement
    1              0.000021 hi def link rubyAccess			Statement
    1              0.000028 hi def link rubyAttribute		Statement
    1              0.000021 hi def link rubyEval			Statement
    1              0.000021 hi def link rubyPseudoVariable		Constant
                            
    1              0.000021 hi def link rubyComment			Comment
    1              0.000022 hi def link rubyData			Comment
    1              0.000020 hi def link rubyDataDirective		Delimiter
    1              0.000021 hi def link rubyDocumentation		Comment
    1              0.000021 hi def link rubyTodo			Todo
                            
    1              0.000015 hi def link rubyQuoteEscape		rubyStringEscape
    1              0.000022 hi def link rubyStringEscape		Special
    1              0.000028 hi def link rubyInterpolationDelimiter	Delimiter
    1              0.000014 hi def link rubyNoInterpolation		rubyString
    1              0.000021 hi def link rubySharpBang		PreProc
    1              0.000021 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    1              0.000021 hi def link rubySymbolDelimiter		rubyStringDelimiter
    1              0.000028 hi def link rubyStringDelimiter		Delimiter
    1              0.000014 hi def link rubyHeredoc			rubyString
    1              0.000021 hi def link rubyString			String
    1              0.000014 hi def link rubyRegexpEscape		rubyRegexpSpecial
    1              0.000014 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    1              0.000014 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    1              0.000014 hi def link rubyRegexpDot		rubyRegexpCharClass
    1              0.000014 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    1              0.000021 hi def link rubyRegexpSpecial		Special
    1              0.000022 hi def link rubyRegexpComment		Comment
    1              0.000014 hi def link rubyRegexp			rubyString
                            
    1              0.000021 hi def link rubyInvalidVariable		Error
    1              0.000021 hi def link rubyError			Error
    1              0.000012 hi def link rubySpaceError		rubyError
                            
    1              0.000006 let b:current_syntax = "ruby"
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/share/nvim/runtime/syntax/python.vim
Sourced 1 time
Total time:   0.006599
 Self time:   0.006599

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2016 Jul 21
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " For version 5.x: Clear all syntax items.
                            " For version 6.x: Quit when a syntax file was already loaded.
    1              0.000005 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    1              0.000016 let s:cpo_save = &cpo
    1              0.000015 set cpo&vim
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/2/reference/lexical_analysis.html#keywords,
                            " https://docs.python.org/3/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3 and 2.
                            " We include Python 3 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3 but they are
                            "   built-ins in 2 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3 and will be highlighted.
                            " - 'print' is a built-in in Python 3 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2)
                            " - async and await were added in Python 3.5 and are soft keywords.
                            "
    1              0.000022 syn keyword pythonStatement	False None True
    1              0.000022 syn keyword pythonStatement	as assert break continue del exec global
    1              0.000024 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    1              0.000046 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    1              0.000019 syn keyword pythonConditional	elif else if
    1              0.000019 syn keyword pythonRepeat	for while
    1              0.000012 syn keyword pythonOperator	and in is not or
    1              0.000019 syn keyword pythonException	except finally raise try
    1              0.000020 syn keyword pythonInclude	from import
    1              0.000011 syn keyword pythonAsync		async await
                            
                            " Decorators (new in Python 2.4)
    1              0.000040 syn match   pythonDecorator	"@" display nextgroup=pythonFunction skipwhite
                            " The zero-length non-grouping match before the function name is
                            " extremely important in pythonFunction.  Without it, everything is
                            " interpreted as a function inside the contained environment of
                            " doctests.
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    1              0.000029 syn match   pythonFunction
                                  \ "\%(\%(def\s\|class\s\|@\)\s*\)\@<=\h\%(\w\|\.\)*" contained
                            
    1              0.000027 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    1              0.000012 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    1              0.000042 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    1              0.000063 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ skip=+\\["']+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    1              0.000034 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    1              0.000055 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    1              0.000015 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    1              0.000014 syn match   pythonEscape	"\\\o\{1,3}" contained
    1              0.000015 syn match   pythonEscape	"\\x\x\{2}" contained
    1              0.000018 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    1              0.000015 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    1              0.000013 syn match   pythonEscape	"\\$"
                            
    1              0.000007 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/2/reference/lexical_analysis.html#numeric-literals
                            " https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
    1              0.000006 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    1              0.000017   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    1              0.000015   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    1              0.000016   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    1              0.000017   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    1              0.000014   syn match   pythonNumber	"\<\d\+[jJ]\>"
    1              0.000016   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    1              0.000020   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    1              0.000023   syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    1              0.000003 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/2/library/constants.html
                            " https://docs.python.org/3/library/constants.html
                            " http://docs.python.org/2/library/functions.html
                            " http://docs.python.org/3/library/functions.html
                            " http://docs.python.org/2/library/functions.html#non-essential-built-in-functions
                            " http://docs.python.org/3/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    1              0.000006 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    1              0.000013   syn keyword pythonBuiltin	False True None
    1              0.000012   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    1              0.000013   syn keyword pythonBuiltin	abs all any bin bool bytearray callable chr
    1              0.000014   syn keyword pythonBuiltin	classmethod compile complex delattr dict dir
    1              0.000013   syn keyword pythonBuiltin	divmod enumerate eval filter float format
    1              0.000015   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    1              0.000037   syn keyword pythonBuiltin	help hex id input int isinstance
    1              0.000217   syn keyword pythonBuiltin	issubclass iter len list locals map max
    1              0.000214   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    1              0.000235   syn keyword pythonBuiltin	print property range repr reversed round set
    1              0.000183   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    1              0.000218   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2 only
    1              0.000176   syn keyword pythonBuiltin	basestring cmp execfile file
    1              0.000190   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    1              0.000081   syn keyword pythonBuiltin	unicode xrange
                              " Python 3 only
    1              0.000081   syn keyword pythonBuiltin	ascii bytes exec
                              " non-essential built-in functions; Python 2 only
    1              0.000150   syn keyword pythonBuiltin	apply buffer coerce intern
                              " avoid highlighting attributes as builtins
    1              0.000028   syn match   pythonAttribute	/\.\h\w*/hs=s+1 contains=ALLBUT,pythonBuiltin transparent
    1              0.000003 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/2/library/exceptions.html
                            " http://docs.python.org/3/library/exceptions.html
    1              0.000007 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    1              0.000111   syn keyword pythonExceptions	BaseException Exception
    1              0.000083   syn keyword pythonExceptions	ArithmeticError BufferError
    1              0.000049   syn keyword pythonExceptions	LookupError
                              " builtin base exceptions removed in Python 3
    1              0.000083   syn keyword pythonExceptions	EnvironmentError StandardError
                              " builtin exceptions (actually raised)
    1              0.000082   syn keyword pythonExceptions	AssertionError AttributeError
    1              0.000118   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    1              0.000082   syn keyword pythonExceptions	ImportError IndentationError
    1              0.000118   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    1              0.000118   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    1              0.000118   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    1              0.000118   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    1              0.000154   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    1              0.000083   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    1              0.000083   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    1              0.000083   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    1              0.000047   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin OS exceptions in Python 3
    1              0.000084   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    1              0.000087   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    1              0.000087   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    1              0.000085   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    1              0.000084   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    1              0.000084   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    1              0.000086   syn keyword pythonExceptions	PermissionError ProcessLookupError
    1              0.000085   syn keyword pythonExceptions	RecursionError StopAsyncIteration
    1              0.000048   syn keyword pythonExceptions	TimeoutError
                              " builtin exceptions deprecated/removed in Python 3
    1              0.000120   syn keyword pythonExceptions	IOError VMSError WindowsError
                              " builtin warnings
    1              0.000121   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    1              0.000089   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    1              0.000124   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    1              0.000085   syn keyword pythonExceptions	UserWarning Warning
                              " builtin warnings in Python 3
    1              0.000048   syn keyword pythonExceptions	ResourceWarning
    1              0.000002 endif
                            
    1              0.000007 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    1              0.000007 if !exists("python_no_doctest_highlight")
    1              0.000006   if !exists("python_no_doctest_code_highlight")
    1              0.000034     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,@Spell
    1              0.000027     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    1              0.000003   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    1              0.000002 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    1              0.000021 syn sync match pythonSync grouphere NONE "^\s*\%(def\|class\)\s\+\h\w*\s*("
                            
    1              0.000007 if version >= 508 || !exists("did_python_syn_inits")
    1              0.000003   if version <= 508
                                let did_python_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    1              0.000015     command -nargs=+ HiLink hi def link <args>
    1              0.000002   endif
                            
                              " The default highlight links.  Can be overridden later.
    1              0.000035   HiLink pythonStatement	Statement
    1              0.000032   HiLink pythonConditional	Conditional
    1              0.000031   HiLink pythonRepeat		Repeat
    1              0.000024   HiLink pythonOperator		Operator
    1              0.000031   HiLink pythonException	Exception
    1              0.000031   HiLink pythonInclude		Include
    1              0.000024   HiLink pythonAsync		Statement
    1              0.000023   HiLink pythonDecorator	Define
    1              0.000043   HiLink pythonFunction		Function
    1              0.000025   HiLink pythonComment		Comment
    1              0.000023   HiLink pythonTodo		Todo
    1              0.000023   HiLink pythonString		String
    1              0.000023   HiLink pythonRawString	String
    1              0.000024   HiLink pythonQuotes		String
    1              0.000016   HiLink pythonTripleQuotes	pythonQuotes
    1              0.000024   HiLink pythonEscape		Special
    1              0.000007   if !exists("python_no_number_highlight")
    1              0.000025     HiLink pythonNumber		Number
    1              0.000002   endif
    1              0.000008   if !exists("python_no_builtin_highlight")
    1              0.000025     HiLink pythonBuiltin	Function
    1              0.000002   endif
    1              0.000006   if !exists("python_no_exception_highlight")
    1              0.000024     HiLink pythonExceptions	Structure
    1              0.000002   endif
    1              0.000006   if exists("python_space_error_highlight")
                                HiLink pythonSpaceError	Error
                              endif
    1              0.000005   if !exists("python_no_doctest_highlight")
    1              0.000024     HiLink pythonDoctest	Special
    1              0.000023     HiLink pythonDoctestValue	Define
    1              0.000002   endif
                            
    1              0.000004   delcommand HiLink
    1              0.000002 endif
                            
    1              0.000006 let b:current_syntax = "python"
                            
    1              0.000018 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/share/nvim/runtime/syntax/vim/generated.vim
Sourced 1 time
Total time:   0.003026
 Self time:   0.003026

count  total (s)   self (s)
                            syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] au[tocmd] aug[roup] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cad[dbuffer] cadde[xpr] caddf[ile] cal[l] cat[ch] cb[uffer] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckpath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev] cnorem[enu] co[py] col[der] colo[rscheme]
    1              0.000121 syn keyword vimCommand contained  com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] do[autocmd] doautoa[ll] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] ha[rdcopy] hi[ghlight] hid[e] his[tory]
    1              0.000113 syn keyword vimCommand contained  i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] lat[er] lb[uffer] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch]
    1              0.000120 syn keyword vimCommand contained  me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] nb[key] nbc[lose] nbs[tart] ne[w] nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[mptfind] promptr[epl] prof[ile] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r] redr[aw] redraws[tatus]
    1              0.000123 syn keyword vimCommand contained  reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir]
    1              0.000124 syn keyword vimCommand contained  tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[ap] tmapc[lear] tme[nu] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmap] tunme[nu] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[verb] wsh[ada] wu[ndo] wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu]
    1              0.000023 syn keyword vimCommand contained  xu[nmap] xunme[nu] y[ank] N[ext]
                            
    1              0.000195 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari altkeymap akm invaltkeymap noaltkeymap invakm noakm ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh
    1              0.000069 syn keyword vimOption contained  buflisted bl invbuflisted nobuflisted invbl nobl buftype bt casemap cmp cdpath cd cedit charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    1              0.000069 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm esckeys ek invesckeys noesckeys invek noek eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs
    1              0.000065 syn keyword vimOption contained  fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol fkmap fk invfkmap nofkmap invfk nofk foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontset gfs guifontwide gfw guiheadroom ghr guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp
    1              0.000059 syn keyword vimOption contained  hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr
    1              0.000057 syn keyword vimOption contained  lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl magic invmagic nomagic makeef mef makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmem mm maxmempattern mmp maxmemtot mmt menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev
    1              0.000059 syn keyword vimOption contained  operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumheight ph quoteescape qe readonly ro invreadonly noreadonly invro noro redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr
    1              0.000071 syn keyword vimOption contained  scrollbind scb invscrollbind noscrollbind invscb noscb scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi
    1              0.000065 syn keyword vimOption contained  smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc terse invterse noterse
    1              0.000060 syn keyword vimOption contained  textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw
    1              0.000027 syn keyword vimOption contained  winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    1              0.000006 syn case ignore
                            
    1              0.000206 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre CmdUndefined CmdWinEnter CmdWinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave JobActivity MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre
    1              0.000034 syn keyword vimAutoEvent contained  SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermResponse TextChanged TextChangedI TextYankPost User VimEnter VimLeave VimLeavePre VimResized WinNew WinEnter WinLeave BufRead BufWrite BufCreate FileEncoding
                            
    1              0.000018 syn keyword nvimAutoEvent contained  TermOpen TabClosed TermClose TabNewEntered DirChanged TabNew
                            
    1              0.000003 syn case match
                            
    1              0.000058 syn keyword vimFuncName contained  nvim_set_current_line visualmode nvim_get_option nvim_get_current_tabpage assert_match getbufinfo nvim_buf_clear_highlight strtrans str2nr tabpagewinnr floor nvim_win_set_cursor matchadd hasmapto assert_false setcmdpos atan getcharsearch highlight_exists getwinvar substitute or line2byte nvim_win_is_valid nvim_win_get_option assert_equal nvim_win_set_height nvim_win_get_position getcmdpos asin glob2regpat browse synID rename screencol spellsuggest setpos nvim_set_option remove assert_exception getftype json_decode getbufline searchpair getpos synIDtrans strridx getcmdtype wildmenumode bufexists getcwd nvim_buf_set_name nvim_win_set_option eval foldclosed timer_start nvim_out_write nvim_get_color_by_name soundfold matchstrpos simplify getfontname nvim_win_set_width pathshorten tempname and dictwatcheradd fmod
    1              0.000057 syn keyword vimFuncName contained  synIDattr atan2 writefile isdirectory getregtype histadd diff_filler arglistid shiftwidth setqflist strpart nvim_buf_get_name jobstop bufloaded nvim_set_current_tabpage matchaddpos bufwinid getcmdline inputdialog hlexists reverse extend fnamemodify nvim_tabpage_get_win nvim_win_get_cursor tabpagebuflist executable nvim_win_del_var tan keys empty ceil complete_add nvim_win_get_tabpage setmatches nvim_win_get_buf join foreground bufwinnr add reltimefloat changenr last_buffer_nr strgetchar line strlen nvim_buf_get_number nvim_win_get_number virtcol jobclose win_findbuf col serverstop winrestview foldtextresult nextnonblank wordcount nvim_buf_get_lines acos getcompletion argidx match haslocaldir reltime sort jobstart assert_notmatch matchend nvim_get_var getqflist nvim_get_vvar filter nvim_buf_set_option index
    1              0.000062 syn keyword vimFuncName contained  winwidth execute nvim_list_bufs nvim_tabpage_is_valid complete copy nvim_get_current_win tabpagenr finddir assert_notequal buffer_exists bufnr histnr sqrt argv libcall items eventhandler count getcmdwintype exepath resolve nvim_tabpage_get_number nvim_strwidth screenchar getpid nvim_command_output printf fnameescape has_key range winheight buffer_name get getbufvar strchars cos getfperm invert diff_hlID serverstart delete exists nvim_buf_del_var gettabvar hostname argc libcallnr indent maparg mapcheck float2nr foldtext rpcrequest garbagecollect setfperm uniq string file_readable getmatches expand pyeval cursor mode setline deepcopy undofile getloclist cosh round setreg inputsecret screenattr nvim_get_current_buf nvim_buf_get_var jobresize nvim_buf_set_lines winnr len nvim_buf_is_valid append win_gotoid lispindent
    1              0.000058 syn keyword vimFuncName contained  settabvar getline nvim_list_wins tolower complete_check browsedir cscope_connection log did_filetype log10 islocked undotree matchlist function win_id2win matchstr wincol settabwinvar localtime nvim_err_write byteidxcomp winbufnr type matcharg prevnonblank pumvisible py3eval nvim_list_tabpages inputsave gettabwinvar reltimestr cindent nvim_win_get_var highlightID nvim_feedkeys trunc repeat histdel rpcstart nvim_set_current_buf getcharmod assert_fails findfile api_info hlID strcharpart rpcstop searchpairpos tagfiles inputlist searchpos serverlist setbufvar map foldlevel strwidth nvim_tabpage_get_var max dictwatcherdel byte2line getchar confirm setloclist winrestcmd searchdecl nvim_buf_get_mark synstack msgpackparse strdisplaywidth nvim_set_current_dir byteidx nvim_get_current_line nvim_input nvim_del_current_line
    1              0.000057 syn keyword vimFuncName contained  setwinvar globpath termopen nvim_list_runtime_paths nvim_replace_termcodes gettabinfo getwininfo winline synconcealed readfile rpcnotify nvim_win_get_width feedkeys pow filereadable escape str2float nvim_buf_line_count nr2char min nvim_buf_set_var search inputrestore bufname nvim_win_get_height sin submatch system systemlist msgpackdump taglist nvim_err_writeln insert sha256 nvim_eval timer_stop toupper tr buffer_number histget values win_getid win_id2tabwin setcharsearch iconv jobpid split stridx winsaveview jobsend getwinposx clearmatches screenrow getwinposy jobwait has assert_true filewritable nvim_tabpage_list_wins buflisted matchdelete char2nr nvim_win_set_var shellescape foldclosedend nvim_set_var nvim_call_function strftime nvim_set_current_win mkdir spellbadword call nvim_buf_add_highlight nvim_buf_get_option
    1              0.000025 syn keyword vimFuncName contained  getfsize json_encode nvim_command nvim_tabpage_set_var nvim_tabpage_del_var abs xor sinh getreg nvim_get_color_map getftime tanh glob input nvim_del_var getcurpos exp

SCRIPT  /usr/share/nvim/runtime/ftoff.vim
Sourced 1 time
Total time:   0.001107
 Self time:   0.001107

count  total (s)   self (s)
                            " Vim support file to switch off detection of file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2001 Jun 11
                            
    1              0.000005 if exists("did_load_filetypes")
    1              0.000004   unlet did_load_filetypes
    1              0.000001 endif
                            
                            " Remove all autocommands in the filetypedetect group
    1              0.001055 silent! au! filetypedetect *

FUNCTION  <SNR>130_update_branch()
Called 1247 times
Total time:   0.670563
 Self time:   0.165704

count  total (s)   self (s)
 1247              0.054355   let l:path = exists("*fnamemodify") ? fnamemodify(resolve(@%), ":p:h") : expand("%:p:h")
 3741              0.013214   for vcs in keys(s:vcs_config)
 2494   0.539828   0.034969     call {s:vcs_config[vcs].update_branch}(l:path)
 2494              0.018520     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    1              0.000007       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    1              0.000003       unlet! b:airline_head
    1              0.000001     endif
 2494              0.003706   endfor

FUNCTION  cm#context()
Called 38 times
Total time:   0.003156
 Self time:   0.003156

count  total (s)   self (s)
   38              0.000519 	let l:ret = {'bufnr':bufnr('%'), 'curpos':getcurpos(), 'changedtick':b:changedtick}
   38              0.000309 	let l:ret['lnum'] = l:ret['curpos'][1]
   38              0.000234 	let l:ret['col'] = l:ret['curpos'][2]
   38              0.000201 	let l:ret['filetype'] = &filetype
   38              0.000799 	let l:ret['filepath'] = expand('%:p')
   38              0.000181 	if l:ret['filepath'] == ''
                            		" this is necessary here, otherwise empty filepath is somehow
                            		" converted to None in vim's python binding.
                            		let l:ret['filepath'] = ""
                            	endif
   38              0.000420 	let l:ret['typed'] = strpart(getline(l:ret['lnum']),0,l:ret['col']-1)
   38              0.000114 	return l:ret

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 13 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
   13              0.000135   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  <SNR>69_on_colorscheme_changed()
Called 1 time
Total time:   0.269587
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000012   0.000006   call s:init()
    1              0.000004   unlet! g:airline#highlighter#normal_fg_hi
    1   0.000038   0.000010   let g:airline_gui_mode = airline#init#gui_mode()
    1              0.000003   if !s:theme_in_vimrc
                                call airline#switch_matching_theme()
                              endif
                            
                              " couldn't find a match, or theme was defined, just refresh
    1   0.269524   0.000011   call airline#load_theme()

FUNCTION  8()
Called 8 times
Total time:   0.000736
 Self time:   0.000463

count  total (s)   self (s)
    8              0.000038     let prependCWD = 0
    8   0.000209   0.000056     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
    8              0.000083         let prependCWD = a:str !~# '^/'
    8              0.000015     endif
                            
    8              0.000027     let toReturn = a:str
    8              0.000017     if prependCWD
    5   0.000214   0.000094         let toReturn = getcwd() . s:Path.Slash() . a:str
    5              0.000010     endif
                            
    8              0.000023     return toReturn

FUNCTION  <SNR>156_ApplyPartialTimer()
Called 2 times
Total time:   0.001204
 Self time:   0.000100

count  total (s)   self (s)
    2              0.000043     let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    2   0.001156   0.000051     call call(l:Callback, [a:timer_id] + l:args)

FUNCTION  ale#sign#SetSigns()
Called 4 times
Total time:   0.003373
 Self time:   0.000367

count  total (s)   self (s)
    4              0.000024     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
    4   0.002097   0.000059     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    4   0.000247   0.000054     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    4   0.000193   0.000046     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    4   0.000318   0.000047     let l:sign_map = s:BuildSignMap(l:current_sign_list, l:grouped_items)
                            
    4   0.000414   0.000056     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
    4              0.000013     for l:command in l:command_list
                                    silent! execute l:command
                                endfor

FUNCTION  ale#linter#GetExecutable()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000016     return has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable

FUNCTION  airline#util#exec_funcrefs()
Called 28 times
Total time:   0.043826
 Self time:   0.002904

count  total (s)   self (s)
  154              0.000382     for Fn in a:list
  153   0.042431   0.001509       let code = call(Fn, a:000)
  153              0.000348       if code != 0
   27              0.000044         return code
                                  endif
  126              0.000159     endfor
    1              0.000002     return 0

FUNCTION  RailsDetect()
Called 3 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
    3              0.000015   if exists('b:rails_root')
                                return 1
                              endif
    3              0.000062   let fn = fnamemodify(a:0 ? a:1 : expand('%'), ':p')
    3              0.000036   if fn =~# ':[\/]\{2\}'
    2              0.000006     return 0
                              endif
    1              0.000005   if !isdirectory(fn)
    1              0.000004     let fn = fnamemodify(fn, ':h')
    1              0.000001   endif
    1              0.000061   let file = findfile('config/environment.rb', escape(fn, ', ').';')
    1              0.000005   if !empty(file) && isdirectory(fnamemodify(file, ':p:h:h') . '/app')
                                let b:rails_root = fnamemodify(file, ':p:h:h')
                                return 1
                              endif

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 3 times
Total time:   0.000097
 Self time:   0.000041

count  total (s)   self (s)
    3   0.000094   0.000039   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  ale#util#ClockMilliseconds()
Called 909 times
Total time:   0.012497
 Self time:   0.012497

count  total (s)   self (s)
  909              0.010853     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  gitgutter#async#handle_diff_job_nvim()
Called 6 times
Total time:   0.001913
 Self time:   0.000812

count  total (s)   self (s)
    6   0.000560   0.000113   call gitgutter#debug#log('job_id: '.a:job_id.', event: '.a:event.', buffer: '.self.buffer)
                            
    6              0.000030   let job_bufnr = self.buffer
    6              0.000027   if bufexists(job_bufnr)
    6   0.000084   0.000055     let current_buffer = gitgutter#utility#bufnr()
    6   0.000178   0.000053     call gitgutter#utility#set_buffer(job_bufnr)
                            
    6              0.000027     if a:event == 'stdout'
                                  " a:data is a list
                                  call s:job_finished(a:job_id)
                                  if gitgutter#utility#is_active()
                                    call gitgutter#handle_diff(gitgutter#utility#stringify(a:data))
                                  endif
                            
                                elseif a:event == 'exit'
                                  " If the exit event is triggered without a preceding stdout event,
                                  " the diff was empty.
    3   0.000059   0.000035       if s:is_job_started(a:job_id)
                                    if gitgutter#utility#is_active()
                                      call gitgutter#handle_diff("")
                                    endif
                                    call s:job_finished(a:job_id)
                                  endif
                            
    3              0.000005     else  " a:event is stderr
    3   0.000328   0.000021       call gitgutter#hunk#reset()
    3   0.000089   0.000040       call s:job_finished(a:job_id)
                            
    3              0.000004     endif
                            
    6   0.000170   0.000051     call gitgutter#utility#set_buffer(current_buffer)
    6              0.000013   else
                                call s:job_finished(a:job_id)
                              endif

FUNCTION  <SNR>140_create()
Called 12 times
Total time:   0.003372
 Self time:   0.002941

count  total (s)   self (s)
   12              0.000039   let _ = ''
   24              0.000096   for idx in range(len(a:parts))
   12   0.000210   0.000122     let part = airline#parts#get(a:parts[idx])
   12              0.000031     let val = ''
   12              0.000056     let add_sep = get(l:, 'add_sep', 0)
                            
   12              0.000050     if exists('part.function')
   12              0.000048       let func = (part.function).'()'
   12              0.000027     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
   12              0.000059     let minwidth = get(part, 'minwidth', 0)
                            
   12              0.000038     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                else
   12              0.000123       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
   12              0.000056       let add_sep = 0
   12              0.000015     endif
                            
   12              0.000041     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
   12   0.000460   0.000117     let val .= s:wrap_accent(part, partval)
   12              0.000053     let _ .= val
   12              0.000024   endfor
   12              0.000027   return _

FUNCTION  <SNR>102_ALELintImpl()
Called 2 times
Total time:   0.004794
 Self time:   0.000159

count  total (s)   self (s)
    2   0.000278   0.000014     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Use the filetype from the buffer
    2   0.000650   0.000020     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
    2              0.000006     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
    2              0.000009     if has_key(s:should_lint_file_for_buffer, a:buffer)
    2              0.000009         unlet s:should_lint_file_for_buffer[a:buffer]
                                    " Lint files if they exist.
    2              0.000056         let l:should_lint_file = filereadable(expand('#' . a:buffer . ':p'))
    2              0.000003     endif
                            
    2   0.003768   0.000026     call ale#engine#RunLinters(a:buffer, l:linters, l:should_lint_file)

FUNCTION  <SNR>172_is_job_started()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000020   return has_key(s:jobs, a:id)

FUNCTION  <SNR>185_UpdateLineNumbers()
Called 4 times
Total time:   0.000193
 Self time:   0.000193

count  total (s)   self (s)
    4              0.000017     let l:line_map = {}
    4              0.000015     let l:line_numbers_changed = 0
                            
    4              0.000017     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
    4              0.000010     for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
                                endfor
                            
                                " When the line numbers change, sort the list again
    4              0.000011     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  <SNR>155_StopCursorTimer()
Called 463 times
Total time:   0.007934
 Self time:   0.007934

count  total (s)   self (s)
  463              0.001995     if s:cursor_timer != -1
  428              0.002350         call timer_stop(s:cursor_timer)
  428              0.001652         let s:cursor_timer = -1
  428              0.000627     endif

FUNCTION  <SNR>68_fnameescape()
Called 7 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
    7              0.000054   if exists('*fnameescape')
    7              0.000124     return fnameescape(a:file)
                              else
                                return escape(a:file," \t\n*?[{`$\\%#'\"|!<")
                              endif

FUNCTION  airline#statusline()
Called 1308 times
Total time:   0.039757
 Self time:   0.039757

count  total (s)   self (s)
 1308              0.015979   if has_key(s:contexts, a:winnr)
 1308              0.019840     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 1308 times
Total time:   2.049419
 Self time:   0.250083

count  total (s)   self (s)
 1308              0.007554   if !exists("s:airline_run")
                                let s:airline_run = 0
                              endif
 1308              0.005687   let s:airline_run += 1
                            
 1308              0.007238   let context = s:contexts[a:winnr]
                            
 1308              0.006545   if get(w:, 'airline_active', 1)
 1264              0.005372     let l:m = mode()
 1264              0.009135     if exists("*term_list") && index(term_list(), bufnr('')) > -1
                                  let l:m = "t"
                                endif
 1264              0.003461     if l:m ==# "i"
  262              0.000993       let l:mode = ['insert']
  262              0.000533     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
   42              0.000171       let l:mode = ['visual']
   42              0.000075     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
  960              0.003465       let l:mode = ['normal']
  960              0.001230     endif
 1264              0.010147     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
 1264              0.001918   else
   44              0.000150     let l:mode = ['inactive']
   44              0.000285     let w:airline_current_mode = get(g:airline_mode_map, '__')
   44              0.000066   endif
                            
 1308              0.006952   if g:airline_detect_modified && &modified
  836              0.004475     call add(l:mode, 'modified')
  836              0.001261   endif
                            
 1308              0.004205   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
 1308              0.023135   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
 1308              0.004910   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
 1308              0.004234   if &readonly || ! &modifiable
   57              0.000273     call add(l:mode, 'readonly')
   57              0.000077   endif
                            
 1308              0.009668   let mode_string = join(l:mode)
 1308              0.004080   if s:airline_run < 3
                                " skip this round.
                                " When this function is run too early after startup,
                                " it forces a redraw by vim which will remove the intro screen.
                                let w:airline_lastmode = mode_string
                                return ''
                              endif
 1308              0.007795   if get(w:, 'airline_lastmode', '') != mode_string
   21   0.005450   0.000262     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   21   1.794518   0.000370     call airline#highlighter#highlight(l:mode, context.bufnr)
   21              0.000122     let w:airline_lastmode = mode_string
   21              0.000030   endif
                            
 1308              0.002213   return ''

FUNCTION  <SNR>3_load_plugin()
Called 60 times
Total time:   0.023243
 Self time:   0.000685

count  total (s)   self (s)
   60   0.023202   0.000644   call s:source(s:rtp(a:spec), 'plugin/**/*.vim', 'after/plugin/**/*.vim')

FUNCTION  <SNR>74_softRefreshNerdTree()
Called 1 time
Total time:   0.078627
 Self time:   0.000077

count  total (s)   self (s)
    1   0.000105   0.000015   if g:webdevicons_enable_nerdtree == 1 && g:NERDTree.IsOpen()
    1   0.029968   0.000033     NERDTreeToggle
    1   0.048550   0.000026     NERDTreeToggle
    1              0.000001   endif

FUNCTION  airline#util#append()
Called 7482 times
Total time:   0.153266
 Self time:   0.153266

count  total (s)   self (s)
 7482              0.034937   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 7482              0.043521   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 7482              0.041046   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>82_Setup()
Called 2 times
Total time:   0.001314
 Self time:   0.000041

count  total (s)   self (s)
    2   0.001295   0.000023   call s:Detect(a:path)
    2              0.000008   if exists('b:rake_root')
                                silent doautocmd User Rake
                              endif

FUNCTION  <SNR>81_FindBundlerLock()
Called 2 times
Total time:   0.000924
 Self time:   0.000887

count  total (s)   self (s)
    2   0.000223   0.000186   let path = s:shellslash(a:path)
    2              0.000042   let fn = fnamemodify(path,':s?[\/]$??')
    2              0.000007   let ofn = ""
    2              0.000006   let nfn = fn
   17              0.000049   while fn != ofn
   15              0.000109     if filereadable(fn.'/Gemfile.lock')
                                  return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/Gemfile.lock')
                                elseif filereadable(fn.'/gems.locked')
                                  return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','/gems.locked')
                                endif
   15              0.000043     let ofn = fn
   15              0.000069     let fn = fnamemodify(ofn,':h')
   15              0.000027   endwhile
    2              0.000004   return ''

FUNCTION  <SNR>3_parse_options()
Called 8 times
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
    8              0.000039   let opts = copy(s:base_spec)
    8              0.000026   let type = type(a:arg)
    8              0.000020   if type == s:TYPE.string
                                let opts.tag = a:arg
                              elseif type == s:TYPE.dict
    8              0.000032     call extend(opts, a:arg)
    8              0.000023     if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(expand(opts.dir))
                                endif
    8              0.000007   else
                                throw 'Invalid argument type (expected: string or dictionary)'
                              endif
    8              0.000013   return opts

FUNCTION  <SNR>140_wrap_accent()
Called 12 times
Total time:   0.000343
 Self time:   0.000263

count  total (s)   self (s)
   12              0.000058   if exists('a:part.accent')
   12   0.000194   0.000113     call airline#highlighter#add_accent(a:part.accent)
   12              0.000071     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  <SNR>158_check_changes()
Called 254 times
Total time:   0.032195
 Self time:   0.020267

count  total (s)   self (s)
                            
  254   0.008646   0.003888     if s:should_skip()
                                    return
                                endif
                            
  254   0.004631   0.002452 	let l:tick = s:changetick()
                            
  254              0.001356 	if l:tick!=s:lasttick
   42              0.000173 		let s:lasttick = l:tick
                            
   42              0.000151         if g:cm_complete_start_delay == 0
   42   0.001297   0.000265             call s:on_changed()
   42              0.000053         else
                                        if s:complete_start_timer
                                            call timer_stop(s:complete_start_timer)
                                        endif
                                        let s:complete_start_timer = timer_start(g:cm_complete_start_delay, function('s:complete_start_timer_handler'), {'repeat': 1})
                                    endif
   42              0.000055 	endif
                            
  254   0.005967   0.002008 	call cm#snippet#check_and_inject()

FUNCTION  <SNR>3_remove_rtp()
Called 1 time
Total time:   0.004900
 Self time:   0.002922

count  total (s)   self (s)
   61   0.000259   0.000109   for name in s:loaded_names()
   60   0.001795   0.000387     let rtp = s:rtp(g:plugs[name])
   60   0.001424   0.001031     execute 'set rtp-='.s:escrtp(rtp)
   60              0.000725     let after = globpath(rtp, 'after')
   60              0.000219     if isdirectory(after)
    4   0.000108   0.000081       execute 'set rtp-='.s:escrtp(after)
    4              0.000005     endif
   60              0.000065   endfor

FUNCTION  <SNR>68_cpath()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000007   if exists('+fileignorecase') && &fileignorecase
                                return tolower(a:path)
                              else
    1              0.000003     return a:path
                              endif

FUNCTION  ale#linter#ResolveFiletype()
Called 4 times
Total time:   0.000272
 Self time:   0.000072

count  total (s)   self (s)
    4   0.000239   0.000039     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    4              0.000016     if type(l:filetype) != type([])
    4              0.000009         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>3_glob()
Called 130 times
Total time:   0.009979
 Self time:   0.008650

count  total (s)   self (s)
  130   0.009903   0.008573   return s:lines(globpath(a:from, a:pattern))

FUNCTION  <SNR>146_add_section()
Called 121 times
Total time:   0.013799
 Self time:   0.005559

count  total (s)   self (s)
  121              0.001016     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  121   0.001818   0.000954     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    2              0.000002       return
                                endif
  119              0.000200     if condition
                                  call a:builder.add_raw('%(')
                                endif
  119   0.008943   0.001567     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  119              0.000256     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  <SNR>141_exec_separator()
Called 915 times
Total time:   0.839578
 Self time:   0.063187

count  total (s)   self (s)
  915              0.003186   if pumvisible()
                                return
                              endif
  915   0.217465   0.008551   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  915   0.212894   0.008895   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  915              0.005826   let group = a:from.'_to_'.a:to.a:suffix
  915              0.002116   if a:inverse
  408              0.003587     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  408              0.000771   else
  507              0.004389     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  507              0.000823   endif
  915              0.005389   let a:dict[group] = colors
  915   0.373127   0.009647   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>61_FileUpdate()
Called 7 times
Total time:   0.940486
 Self time:   0.000823

count  total (s)   self (s)
    7              0.000038     if g:NERDTreeUpdateOnWrite != 1
                                    return
                                endif
                            
    7   0.000714   0.000065     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
    7              0.000036     let l:winnr = winnr()
    7              0.000032     let l:altwinnr = winnr('#')
                            
    7   0.006395   0.000053     call g:NERDTree.CursorToTreeWin()
    6  11.143579  11.114006     let l:node = b:NERDTree.root.findNode(g:NERDTreePath.New(a:fname))
    2              0.000006     if l:node == {}
                                    return
                                endif
    2   0.841378   0.000021     call l:node.refreshFlags()
    2              0.000010     let l:node = l:node.parent
    8              0.000026     while !empty(l:node)
    6   0.005795   0.000042         call l:node.refreshDirFlags()
    6              0.000024         let l:node = l:node.parent
    6              0.000009     endwhile
                            
    2   0.055561   0.000015     call NERDTreeRender()
                            
    2              0.000019     exec l:altwinnr . 'wincmd w'
    2              0.000075     exec l:winnr . 'wincmd w'

FUNCTION  <SNR>132_check_mixed_indent()
Called 6 times
Total time:   0.024958
 Self time:   0.024958

count  total (s)   self (s)
    6              0.000045   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    6              0.000016   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    6              0.024787     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>145_get_seperator()
Called 144 times
Total time:   0.182983
 Self time:   0.003073

count  total (s)   self (s)
  144   0.060907   0.001350   if s:should_change_group(a:prev_group, a:group)
  134   0.121801   0.001448     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
   10              0.000046     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>103_startup()
Called 1 time
Total time:   0.000280
 Self time:   0.000268

count  total (s)   self (s)
    1              0.000008     if get(g:,'cm_smart_enable',1)
    1   0.000021   0.000009         call cm#_auto_enable_check()
    1              0.000009         augroup cm_smart_enable
    1              0.000211             au!
    1              0.000012             au BufEnter * call cm#_auto_enable_check()
    1              0.000011             au OptionSet buftype call cm#_auto_enable_check()
    1              0.000002         augroup end
    1              0.000002     endif

FUNCTION  <SNR>68_repo_git_command()
Called 11 times
Total time:   0.001602
 Self time:   0.000589

count  total (s)   self (s)
   11   0.000672   0.000186   let git = s:git_command() . ' --git-dir='.s:shellesc(self.git_dir)
   11   0.000898   0.000372   return git.join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')

FUNCTION  ale#statusline#Count()
Called 2494 times
Total time:   0.112960
 Self time:   0.033140

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
 2494   0.108357   0.028537     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>130_init_buffer()
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000006   let b:buffer_vcs_config = {}
    3              0.000011   for vcs in keys(s:vcs_config)
    2              0.000017     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
    2              0.000004   endfor
    1              0.000003   unlet! b:airline_head

FUNCTION  <SNR>68_RehighlightBlame()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000006   for [hash, cterm] in items(s:hash_colors)
                                if !empty(cterm) || has('gui_running') || has('termguicolors') && &termguicolors
                                  exe 'hi FugitiveblameHash'.hash.' guifg=#'.hash.get(s:hash_colors, hash, '')
                                else
                                  exe 'hi link FugitiveblameHash'.hash.' Identifier'
                                endif
                              endfor

FUNCTION  <SNR>68_shellesc()
Called 63 times
Total time:   0.001623
 Self time:   0.001610

count  total (s)   self (s)
   63              0.001245   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   62              0.000232     return a:arg
                              elseif s:winshell()
                                return '"'.s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"').'"'
                              else
    1              0.000006     return shellescape(a:arg)
                              endif

FUNCTION  ale#sign#FindCurrentSigns()
Called 4 times
Total time:   0.002038
 Self time:   0.000095

count  total (s)   self (s)
    4   0.000283   0.000044     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    4   0.001747   0.000043     return ale#sign#ParseSigns(l:line_list)

FUNCTION  284()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000011   if s:selections[a:reg].owner > 0
    1              0.000006     return s:selections[a:reg].data
                              end
                              return s:try_cmd(s:paste[a:reg])

FUNCTION  gitgutter#highlight#get_background_colors()
Called 1 time
Total time:   0.000166
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000008   redir => highlight
    1              0.000025   silent execute 'silent highlight ' . a:group
    1              0.000005   redir END
                            
    1              0.000025   let link_matches = matchlist(highlight, 'links to \(\S\+\)')
    1              0.000004   if len(link_matches) > 0 " follow the link
                                return gitgutter#highlight#get_background_colors(link_matches[1])
                              endif
                            
    1   0.000053   0.000016   let ctermbg = gitgutter#highlight#match_highlight(highlight, 'ctermbg=\([0-9A-Za-z]\+\)')
    1   0.000034   0.000009   let guibg   = gitgutter#highlight#match_highlight(highlight, 'guibg=\([#0-9A-Za-z]\+\)')
    1              0.000003   return [guibg, ctermbg]

FUNCTION  <SNR>102_ALEQueueImpl()
Called 2 times
Total time:   0.006243
 Self time:   0.000191

count  total (s)   self (s)
    2              0.000011     if a:linting_flag isnot# '' && a:linting_flag isnot# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
    2              0.000007     if type(a:buffer) != type(0)
                                    throw 'buffer_number must be a Number'
                                endif
                            
    2   0.000374   0.000012     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
    2              0.000006     if a:linting_flag is# 'lint_file'
    2              0.000014         let s:should_lint_file_for_buffer[bufnr('%')] = 1
    2              0.000003     endif
                            
    2              0.000004     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
    2   0.000762   0.000031     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    2              0.000006     if empty(l:linters)
                                    " If we have some previous buffer data, then stop any jobs currently
                                    " running and clear everything.
                                    if has_key(g:ale_buffer_info, a:buffer)
                                        call ale#engine#RunLinters(a:buffer, [], 1)
                                    endif
                            
                                    return
                                endif
                            
    2              0.000004     if a:delay > 0
                                    let s:queued_buffer_number = a:buffer
                                    let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
                                else
    2   0.004977   0.000017         call ale#Lint(-1, a:buffer)
    2              0.000002     endif

FUNCTION  airline#highlighter#add_accent()
Called 12 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   12              0.000068   let s:accents[a:accent] = 1

FUNCTION  <SNR>3_reload_plugins()
Called 1 time
Total time:   0.024023
 Self time:   0.000639

count  total (s)   self (s)
   61   0.000255   0.000114   for name in s:loaded_names()
   60   0.023667   0.000424     call s:load_plugin(g:plugs[name])
   60              0.000074   endfor

FUNCTION  <SNR>68_repo_head_ref()
Called 1247 times
Total time:   0.110180
 Self time:   0.083070

count  total (s)   self (s)
 1247   0.042505   0.027353   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
 1247   0.060854   0.048896   return readfile(self.dir('HEAD'))[0]

FUNCTION  ale#highlight#UpdateHighlights()
Called 9 times
Total time:   0.000764
 Self time:   0.000604

count  total (s)   self (s)
    9              0.000081     let l:item_list = g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    9   0.000231   0.000071     call ale#highlight#RemoveHighlights()
                            
    9              0.000028     for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:line = l:item.lnum
                                    let l:col = l:item.col
                                    let l:end_line = get(l:item, 'end_lnum', l:line)
                                    let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
                                    call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
                                endfor

FUNCTION  <SNR>68_repo_rev_parse()
Called 1 time
Total time:   0.337469
 Self time:   0.000082

count  total (s)   self (s)
    1   0.337408   0.000021   let hash = self.git_chomp('rev-parse','--verify',a:rev)
    1              0.000036   if hash =~ '\<\x\{40\}$'
    1              0.000022     return matchstr(hash,'\<\x\{40\}$')
                              endif
                              call s:throw('rev-parse '.a:rev.': '.hash)

FUNCTION  <SNR>68_winshell()
Called 12 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   12              0.000214   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  airline#parts#filetype()
Called 1251 times
Total time:   0.012576
 Self time:   0.012576

count  total (s)   self (s)
 1251              0.010930   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 14 times
Total time:   0.000457
 Self time:   0.000457

count  total (s)   self (s)
   14              0.000117   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 1247 times
Total time:   0.015336
 Self time:   0.015336

count  total (s)   self (s)
 1247              0.006479   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
 1247              0.001705   return ''

FUNCTION  <SNR>68_ReplaceCmd()
Called 1 time
Total time:   0.402030
 Self time:   0.302037

count  total (s)   self (s)
    1              0.000015   let fn = expand('%:p')
    1              0.000006   let tmp = tempname()
    1              0.000002   let prefix = ''
    1              0.000003   try
    1              0.000002     if a:0 && a:1 != ''
                                  if s:winshell()
                                    let old_index = $GIT_INDEX_FILE
                                    let $GIT_INDEX_FILE = a:1
                                  else
                                    let prefix = 'env GIT_INDEX_FILE='.s:shellesc(a:1).' '
                                  endif
                                endif
    1              0.000003     let redir = ' > '.tmp
    1              0.000010     if &shellpipe =~ '2>&1'
    1              0.000004       let redir .= ' 2>&1'
    1              0.000001     endif
    1   0.000017   0.000005     if s:winshell()
                                  let cmd_escape_char = &shellxquote == '(' ?  '^' : '^^^'
                                  call system('cmd /c "'.prefix.s:gsub(a:cmd,'[<>]', cmd_escape_char.'&').redir.'"')
                                elseif &shell =~# 'fish'
                                  call system(' begin;'.prefix.a:cmd.redir.';end ')
                                else
    1              0.300193       call system(' ('.prefix.a:cmd.redir.') ')
    1              0.000014     endif
    1              0.000004   finally
    1              0.000014     if exists('old_index')
                                  let $GIT_INDEX_FILE = old_index
                                endif
    1              0.000002   endtry
    1              0.000224   silent exe 'keepalt file '.tmp
    1              0.000005   try
    1              0.001100     silent edit!
    1              0.000002   finally
    1              0.000002     try
    1   0.000213   0.000189       silent exe 'keepalt file '.s:fnameescape(fn)
    1              0.000003     catch /^Vim\%((\a\+)\)\=:E302/
                                endtry
    1              0.000060     call delete(tmp)
    1              0.000014     if fnamemodify(bufname('$'), ':p') ==# tmp
    1              0.000051       silent execute 'bwipeout '.bufnr('$')
    1              0.000001     endif
    1   0.100009   0.000052     silent exe 'doau BufReadPost '.s:fnameescape(fn)
    1              0.000002   endtry

FUNCTION  <SNR>68_repo_head()
Called 1247 times
Total time:   0.269681
 Self time:   0.072679

count  total (s)   self (s)
 1247   0.179248   0.017372     let head = s:repo().head_ref()
                            
 1247              0.014720     if head =~# '^ref: '
 1247   0.050248   0.015122       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
 1247              0.003728     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
 1247              0.002706     return branch

FUNCTION  gitgutter#highlight#define_highlights()
Called 1 time
Total time:   0.000489
 Self time:   0.000323

count  total (s)   self (s)
    1   0.000183   0.000017   let [guibg, ctermbg] = gitgutter#highlight#get_background_colors('SignColumn')
                            
                              " Highlights used by the signs.
                            
    1              0.000022   execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
    1              0.000018   execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
    1              0.000018   execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
    1              0.000018   highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
                            
    1              0.000021   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000019   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000018   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000018   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisble
                            
    1              0.000018   highlight default link GitGutterAdd          GitGutterAddDefault
    1              0.000018   highlight default link GitGutterChange       GitGutterChangeDefault
    1              0.000018   highlight default link GitGutterDelete       GitGutterDeleteDefault
    1              0.000018   highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
                            
                              " Highlights used for the whole line.
                            
    1              0.000019   highlight default link GitGutterAddLine          DiffAdd
    1              0.000018   highlight default link GitGutterChangeLine       DiffChange
    1              0.000019   highlight default link GitGutterDeleteLine       DiffDelete
    1              0.000018   highlight default link GitGutterChangeDeleteLine GitGutterChangeLine

FUNCTION  gitgutter#utility#use_known_shell()
Called 23 times
Total time:   0.001018
 Self time:   0.001018

count  total (s)   self (s)
   23              0.000127   if has('unix')
   23              0.000081     if &shell !=# 'sh'
   23              0.000122       let s:shell = &shell
   23              0.000112       let s:shellcmdflag = &shellcmdflag
   23              0.000080       let s:shellredir = &shellredir
   23              0.000143       let &shell = 'sh'
   23              0.000128       set shellcmdflag=-c
   23              0.000079       set shellredir=>%s\ 2>&1
   23              0.000030     endif
   23              0.000026   endif

FUNCTION  <SNR>3_to_a()
Called 7 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    7              0.000043   return type(a:v) == s:TYPE.list ? a:v : [a:v]

FUNCTION  <SNR>158_check_rtp()
Called 15 times
Total time:   0.001564
 Self time:   0.001531

count  total (s)   self (s)
   15              0.001336     if s:old_rtp != &rtp
    1              0.000008         let s:old_rtp = &rtp
    1   0.000040   0.000007         call s:notify_core_channel('cm_detect_modules')
    1              0.000001     endif

FUNCTION  gitgutter#process_buffer()
Called 23 times
Total time:   0.026770
 Self time:   0.002505

count  total (s)   self (s)
   23   0.001212   0.000194   call gitgutter#utility#use_known_shell()
                            
   23   0.000771   0.000187   call gitgutter#utility#set_buffer(a:bufnr)
   23   0.001251   0.000149   if gitgutter#utility#is_active()
    4              0.000013     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
    4              0.000008     try
    4   0.000060   0.000023       if !a:realtime || gitgutter#utility#has_fresh_changes()
    4   0.019019   0.000078         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
    3              0.000012         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
    3              0.000003       endif
    3              0.000005     catch /diff failed/
    1   0.000056   0.000008       call gitgutter#debug#log('diff failed')
    1   0.000074   0.000005       call gitgutter#hunk#reset()
    1              0.000003     endtry
    4   0.000502   0.000409     execute "silent doautocmd" s:nomodeline "User GitGutter"
    4              0.000008   else
   19   0.001811   0.000117     call gitgutter#hunk#reset()
   19              0.000031   endif
                            
   23   0.000831   0.000154   call gitgutter#utility#restore_shell()

FUNCTION  <SNR>186_FixList()
Called 2 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000010     let l:new_list = []
                            
    2              0.000008     for l:item in a:list
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        let l:fixed_item = copy(l:item)
                                        call remove(l:fixed_item, 'bufnr')
                                    else
                                        " Don't copy the Dictionary if we do not need to.
                                        let l:fixed_item = l:item
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
                                endfor
                            
    2              0.000006     return l:new_list

FUNCTION  ale#linter#GetAll()
Called 4 times
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
    4              0.000014     let l:combined_linters = []
                            
    8              0.000018     for l:filetype in a:filetypes
                                    " Load linter defintions from files if we haven't loaded them yet.
    4              0.000016         if !has_key(s:linters, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        " Always set an empty List for the loaded linters if we don't find
                                        " any. This will prevent us from executing the runtime command
                                        " many times, redundantly.
                                        if !has_key(s:linters, l:filetype)
                                            let s:linters[l:filetype] = []
                                        endif
                                    endif
                            
    4              0.000032         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    4              0.000006     endfor
                            
    4              0.000009     return l:combined_linters

FUNCTION  AirlineWebDevIcons()
Called 14 times
Total time:   0.001457
 Self time:   0.000744

count  total (s)   self (s)
   14              0.000120   let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
   14              0.000066   let w:airline_section_x .= ' %{WebDevIconsGetFileTypeSymbol()} '
   14   0.000833   0.000120   let hasFileFormatEncodingPart = airline#parts#ffenc() != ''
   14              0.000062   if g:webdevicons_enable_airline_statusline_fileformat_symbols && hasFileFormatEncodingPart
   14              0.000317     let w:airline_section_y = ' %{&fenc . " " . WebDevIconsGetFileFormatSymbol()} '
   14              0.000020   endif

FUNCTION  <SNR>186_ShouldOpen()
Called 4 times
Total time:   0.000325
 Self time:   0.000130

count  total (s)   self (s)
    4   0.000242   0.000047     let l:val = ale#Var(a:buffer, 'open_list')
    4              0.000030     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    4              0.000022     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>68_buffer_type()
Called 1 time
Total time:   0.000092
 Self time:   0.000076

count  total (s)   self (s)
    1   0.000018   0.000010   if self.getvar('fugitive_type') != ''
    1   0.000017   0.000009     let type = self.getvar('fugitive_type')
    1              0.000005   elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
                                let type = 'file'
                              endif
    1              0.000002   if a:0
    1              0.000015     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  <SNR>130_update_hg_branch()
Called 1247 times
Total time:   0.048590
 Self time:   0.048590

count  total (s)   self (s)
 1247              0.004357   if s:has_lawrencium
                                let stl=lawrencium#statusline()
                                if !empty(stl) && s:has_async
                                  call s:get_mq_async('LC_ALL=C hg qtop', expand('%:p'))
                                endif
                                if exists("s:mq") && !empty(s:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.s:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
 1247              0.005758     let s:vcs_config['mercurial'].branch = ''
 1247              0.001858   endif

FUNCTION  <SNR>68_repo_dir()
Called 2495 times
Total time:   0.027123
 Self time:   0.027123

count  total (s)   self (s)
 2495              0.024144   return join([self.git_dir]+a:000,'/')

FUNCTION  UltiSnips#map_keys#MapKeys()
Called 1 time
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
    1              0.000005     if g:UltiSnipsExpandTrigger == g:UltiSnipsJumpForwardTrigger
                                    exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippetOrJump()<cr>"
                                    exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippetOrJump()<cr>"
                                else
    1              0.000033         exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=UltiSnips#ExpandSnippet()<cr>"
    1              0.000023         exec "snoremap <silent> " . g:UltiSnipsExpandTrigger . " <Esc>:call UltiSnips#ExpandSnippet()<cr>"
    1              0.000001     endif
    1              0.000022     exec "xnoremap <silent> " . g:UltiSnipsExpandTrigger. " :call UltiSnips#SaveLastVisualSelection()<cr>gvs"
    1              0.000017     exec "inoremap <silent> " . g:UltiSnipsListSnippets . " <C-R>=UltiSnips#ListSnippets()<cr>"
    1              0.000020     exec "snoremap <silent> " . g:UltiSnipsListSnippets . " <Esc>:call UltiSnips#ListSnippets()<cr>"
                            
    1              0.000014     snoremap <silent> <BS> <c-g>c
    1              0.000013     snoremap <silent> <DEL> <c-g>c
    1              0.000012     snoremap <silent> <c-h> <c-g>c
    1              0.000012     snoremap <c-r> <c-g>"_c<c-r>

FUNCTION  fugitive#detect()
Called 1 time
Total time:   0.001685
 Self time:   0.000356

count  total (s)   self (s)
    1              0.000015   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    1              0.000005   if !exists('b:git_dir')
                                let dir = fugitive#extract_git_dir(a:path)
                                if dir !=# ''
                                  let b:git_dir = dir
                                  if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
                                endif
                              endif
    1              0.000004   if exists('b:git_dir')
    1              0.000014     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    1              0.000005     if !exists('g:fugitive_no_maps')
    1              0.000043       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    1              0.000024       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    1              0.000002     endif
    1   0.000086   0.000015     let buffer = fugitive#buffer()
    1              0.000012     if expand('%:p') =~# '://'
    1   0.000072   0.000030       call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
    1              0.000002     endif
    1   0.000025   0.000015     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    1              0.000015       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000013       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000001     endif
    1              0.000002     try
    1              0.000019       let [save_mls, &modelines] = [&mls, 0]
    1   0.000697   0.000019       call s:define_commands()
    1   0.000537   0.000010       doautocmd User Fugitive
    1              0.000002     finally
    1              0.000014       let &mls = save_mls
    1              0.000003     endtry
    1              0.000001   endif

FUNCTION  airline#extensions#apply()
Called 27 times
Total time:   0.008049
 Self time:   0.002191

count  total (s)   self (s)
   27              0.000137   let s:active_winnr = winnr()
                            
   27   0.002206   0.000174   if s:is_excluded_window()
                                return -1
                              endif
                            
   27              0.000072   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   27              0.000044   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   27              0.000288   if has_key(s:filetype_overrides, &ft)
   12              0.000131     let args = s:filetype_overrides[&ft]
   12   0.003962   0.000135     call airline#extensions#apply_left_override(args[0], args[1])
   12              0.000017   endif
                            
   27              0.000134   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  airline#extensions#tabline#buflist#list()
Called 256 times
Total time:   0.005376
 Self time:   0.005376

count  total (s)   self (s)
  256              0.001475   if exists('s:current_buffer_list')
  252              0.000751     return s:current_buffer_list
                              endif
                            
    4              0.000025   let excludes = get(g:, 'airline#extensions#tabline#excludes', [])
    4              0.000025   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    4              0.000042   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    4              0.000011   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
  108              0.000171   for nr in list
  104              0.000260     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) buffername matches exclude pattern
                                  " 2) buffer is a quickfix buffer
                                  " 3) exclude preview windows (if 'bufhidden' == wipe
                                  "    and 'buftype' == nofile
   23              0.000331       if (!empty(excludes) && match(bufname(nr), join(excludes, '\|')) > -1) || (getbufvar(nr, 'current_syntax') == 'qf') ||  (exclude_preview && getbufvar(nr, '&bufhidden') == 'wipe'  && getbufvar(nr, '&buftype') == 'nofile')
                                    continue
                                  endif
   23              0.000082       call add(buffers, nr)
   23              0.000029     endif
  104              0.000126   endfor
                            
    4              0.000018   let s:current_buffer_list = buffers
    4              0.000008   return buffers

FUNCTION  ctrlp#utils#readfile()
Called 1 time
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
    1              0.000023 	if filereadable(a:file)
    1              0.000183 		let data = readfile(a:file)
    1              0.000008 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    1              0.000002 		retu data
                            	en
                            	retu []

FUNCTION  77()
Called 1 time
Total time:   0.003224
 Self time:   0.000455

count  total (s)   self (s)
   53   0.000102   0.000092     for i in s:KeyMap.All()
   52   0.003027   0.000268         call i.bind()
   52              0.000070     endfor

FUNCTION  <SNR>186_BufWinId()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000025     return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0

FUNCTION  10()
Called 1478 times
Total time:   0.148068
 Self time:   0.093045

count  total (s)   self (s)
 1478   0.049783   0.012888     let self.cachedDisplayString = self.getLastPathComponent(1)
                            
 1478              0.003471     if self.isExecutable
   90              0.000387         let self.cachedDisplayString = self.cachedDisplayString . '*'
   90              0.000119     endif
                            
 1478              0.005327     let self._bookmarkNames = []
 1478   0.028944   0.010816     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
 1478              0.006695     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
 1478              0.002995     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
 1478              0.002765     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif

FUNCTION  <SNR>74_CursorHoldUpdate()
Called 16 times
Total time:   1.335510
 Self time:   0.001864

count  total (s)   self (s)
   16              0.000067   if g:NERDTreeUpdateOnCursorHold != 1
                                return
                              endif
                            
   16   0.001275   0.000143   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
                                return
                              endif
                            
                              " Do not update when a special buffer is selected
   16              0.000064   if !empty(&l:buftype)
    1              0.000001     return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
   15              0.000060   let l:winnr = winnr()
   15              0.000059   let l:altwinnr = winnr('#')
                            
   15   0.003419   0.000089   call g:NERDTree.CursorToTreeWin()
   15   0.829846   0.000135   call b:NERDTree.root.refreshFlags()
   15   0.499573   0.000101   call NERDTreeRender()
                            
   15              0.000305   exec l.altwinnr . 'wincmd w'
   15              0.000568   exec l:winnr . 'wincmd w'

FUNCTION  109()
Called 1 time
Total time:   0.096114
 Self time:   0.000029

count  total (s)   self (s)
    1   0.096113   0.000028     call self.open(a:0 ? a:1 : {})

FUNCTION  ale#ShouldDoNothing()
Called 909 times
Total time:   0.174386
 Self time:   0.050147

count  total (s)   self (s)
                                " Do nothing for blacklisted files
                                " OR if ALE is running in the sandbox
  909   0.171355   0.047116     return index(g:ale_filetype_blacklist, &filetype) >= 0   || (exists('*getcmdwintype') && !empty(getcmdwintype()))   || ale#util#InSandbox()   || !ale#Var(a:buffer, 'enabled')   || ale#FileTooLarge()   || getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'

FUNCTION  ale#highlight#BufferHidden()
Called 2 times
Total time:   0.000060
 Self time:   0.000023

count  total (s)   self (s)
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
    2   0.000054   0.000018     call ale#highlight#RemoveHighlights()

FUNCTION  airline#extensions#po#apply()
Called 14 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
   14              0.000113   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  <SNR>158_on_changed()
Called 54 times
Total time:   0.001348
 Self time:   0.000793

count  total (s)   self (s)
                            
   54   0.000891   0.000336     if s:should_skip()
   12              0.000027         return
                                endif
                            
   42              0.000109 	if g:cm_auto_popup==0
   42              0.000057 		return
                            	endif
                            
                            	call s:notify_core_channel('cm_refresh',g:_cm_sources,cm#context(),0)

FUNCTION  cm#snippet#check_and_inject()
Called 254 times
Total time:   0.003959
 Self time:   0.003959

count  total (s)   self (s)
                            
  254              0.002783     if empty(v:completed_item) || !has_key(v:completed_item,'info') || empty(v:completed_item.info) || has_key(v:completed_item, 'is_snippet')
  254              0.000553 		return ''
                            	endif
                            
                            	let l:last_line = split(v:completed_item.info,'\n')[-1]
                            	if l:last_line[0:len('snippet@')-1]!='snippet@'
                                    let v:completed_item.is_snippet = 0
                            		return ''
                            	endif
                            
                            	let l:snippet_id = str2nr(l:last_line[len('snippet@'):])
                            	if l:snippet_id>=len(g:cm#snippet#snippets) || l:snippet_id<0
                                    let v:completed_item.is_snippet = 0
                            		return ''
                            	endif
                            
                            	" neosnippet recognize the snippet field of v:completed_item. Also useful
                            	" for checking. Kind of a hack.
                                " TODO: skip empty g:cm#snippet#snippets[l:snippet_id]['snippet']
                            	let v:completed_item.snippet = g:cm#snippet#snippets[l:snippet_id]['snippet']
                                let v:completed_item.snippet_word = g:cm#snippet#snippets[l:snippet_id]['word']
                                let v:completed_item.is_snippet = 1
                            
                                if v:completed_item.snippet == ''
                                    return ''
                                endif
                            
                            	if g:cm_completed_snippet_engine == 'ultisnips'
                            
                                    call s:ultisnips_inject()
                            
                                " elseif g:cm_completed_snippet_engine == 'snipmate'
                                    " nothing needs to be done for snipmate
                            
                                elseif g:cm_completed_snippet_engine == 'neosnippet'
                            
                                    call s:neosnippet_inject()
                            
                            	endif
                            
                                return ''

FUNCTION  airline#extensions#tabline#formatters#webdevicons#format()
Called 256 times
Total time:   0.118292
 Self time:   0.007756

count  total (s)   self (s)
                              " Call original formatter.
  256   0.033825   0.004128   let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
  256   0.083891   0.003052   return originalFormatter . ' ' . WebDevIconsGetFileTypeSymbol(bufname(a:bufnr))

FUNCTION  20()
Called 1 time
Total time:   0.026667
 Self time:   0.001230

count  total (s)   self (s)
    1   0.026663   0.001226     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  21()
Called 8 times
Total time:   0.000405
 Self time:   0.000298

count  total (s)   self (s)
    8   0.000160   0.000053     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
    8              0.000044         let self.drive = ''
    8              0.000012     endif
                            

FUNCTION  23()
Called 1 time
Total time:   0.000021
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000015   0.000005     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
                                endif
                            
    1              0.000002     return " \\`\|\"#%&,?()\*^<>[]$"

FUNCTION  26()
Called 5097 times
Total time:   0.115701
 Self time:   0.115701

count  total (s)   self (s)
 5097              0.021628     if empty(self.pathSegments)
                                    return ''
                                endif
 5097              0.024236     let toReturn = self.pathSegments[-1]
 5097              0.016018     if a:dirSlash && self.isDirectory
  996              0.003741         let toReturn = toReturn . '/'
  996              0.001364     endif
 5097              0.011447     return toReturn

FUNCTION  <SNR>61_NERDTreeGetIndicator()
Called 1485 times
Total time:   0.045150
 Self time:   0.045150

count  total (s)   self (s)
 1485              0.007595     if exists('g:NERDTreeIndicatorMapCustom')
                                    let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
                                    if l:indicator !=# ''
                                        return l:indicator
                                    endif
                                endif
 1485              0.009508     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
 1485              0.004017     if l:indicator !=# ''
  133              0.000309         return l:indicator
                                endif
 1352              0.001862     return ''

FUNCTION  115()
Called 512 times
Total time:   0.034899
 Self time:   0.006397

count  total (s)   self (s)
  512   0.034496   0.005993     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  117()
Called 9 times
Total time:   0.002979
 Self time:   0.000101

count  total (s)   self (s)
    9   0.002938   0.000060     if a:path.equals(self.path)
    3              0.000006         return self
                                endif
    6              0.000008     return {}

FUNCTION  <SNR>3_dirpath()
Called 252 times
Total time:   0.003871
 Self time:   0.003871

count  total (s)   self (s)
  252              0.003690     return substitute(a:path, '[/\\]*$', '/', '')

FUNCTION  <SNR>158_on_insert_enter()
Called 12 times
Total time:   0.002443
 Self time:   0.000744

count  total (s)   self (s)
   12   0.001406   0.000126     call s:check_rtp()
                            
   12              0.000046 	if s:change_timer!=-1
                            		return
                            	endif
   12   0.000221   0.000120 	let s:lasttick = s:changetick()
                            	" check changes every 30ms, which is 0.03s, it should be fast enough
   12              0.000224 	let s:change_timer = timer_start(30,function('s:check_changes'),{'repeat':-1})
                            
   12   0.000419   0.000102 	call s:on_changed()

FUNCTION  airline#util#system()
Called 6 times
Total time:   1.977464
 Self time:   1.977297

count  total (s)   self (s)
    6              0.000095     let l:config = { 'buf': '', 'on_stdout': function('s:system_job_handler'), }
    6              0.034325     let l:id = jobstart(a:cmd, l:config)
    6              0.000077     if l:id < 1
                                  return system(a:cmd)
                                endif
    6   1.942738   1.942570     call jobwait([l:id])
    6              0.000108     return l:config.buf

FUNCTION  gitgutter#utility#exists_file()
Called 20 times
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
   20              0.000266   return filereadable(s:file)

FUNCTION  32()
Called 3616 times
Total time:   0.592292
 Self time:   0.264512

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
 3616   0.037711   0.022630     if a:nerdtree.ui.isIgnoreFilterEnabled()
 7232              0.019756         for i in g:NERDTreeIgnore
 3616   0.264145   0.023286             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
 3616              0.005253         endfor
                            
 3616   0.070998   0.025479         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
 3616              0.004065     endif
                            
                                "dont show hidden files unless instructed to
 3616   0.039777   0.026460     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
 3616   0.038049   0.025044     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
 3616              0.004459     return 0

FUNCTION  33()
Called 3616 times
Total time:   0.240859
 Self time:   0.162120

count  total (s)   self (s)
 3616              0.014457     let pat = a:pattern
 3616              0.022249     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
 3616   0.112419   0.033679     return self.getLastPathComponent(0) =~# pat

FUNCTION  37()
Called 63 times
Total time:   0.019642
 Self time:   0.000667

count  total (s)   self (s)
   63   0.019606   0.000632     return self.str() ==# a:path.str()

FUNCTION  38()
Called 8 times
Total time:   0.003667
 Self time:   0.000719

count  total (s)   self (s)
    8              0.000518     let newPath = copy(self)
                            
    7   3.883361   3.880801     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
    3              0.000010     let newPath.cachedDisplayString = ""
    3   0.000079   0.000028     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    3              0.000006     return newPath

FUNCTION  39()
Called 8863 times
Total time:   0.169074
 Self time:   0.056848

count  total (s)   self (s)
 8863   0.163405   0.051179     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  ale#engine#RemoveManagedFiles()
Called 4 times
Total time:   0.000308
 Self time:   0.000236

count  total (s)   self (s)
    4              0.000030     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
    4   0.000094   0.000023     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
    4              0.000018     if has_key(l:info, 'temporary_file_list')
    4              0.000015         for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
    4              0.000015         let l:info.temporary_file_list = []
    4              0.000005     endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
    4              0.000016     if has_key(l:info, 'temporary_directory_list')
    4              0.000013         for l:directory in l:info.temporary_directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
    4              0.000014         let l:info.temporary_directory_list = []
    4              0.000005     endif

FUNCTION  <SNR>145_get_prev_group()
Called 249 times
Total time:   0.005250
 Self time:   0.005250

count  total (s)   self (s)
  249              0.001042   let x = a:i - 1
  276              0.000679   while x >= 0
  237              0.001142     let group = a:sections[x][0]
  237              0.000850     if group != '' && group != '|'
  210              0.000390       return group
                                endif
   27              0.000076     let x = x - 1
   27              0.000044   endwhile
   39              0.000055   return ''

FUNCTION  122()
Called 1 time
Total time:   0.017512
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000004     try
    1   0.006319   0.000018         let path = b:NERDTree.ui.getPath(line("."))
    1              0.000003         if path ==# {}
                                        return {}
                                    endif
    1   0.011176   0.000011         return b:NERDTree.root.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  126()
Called 1 time
Total time:   0.096085
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000004     let opts = a:0 ? a:1 : {}
    1   0.000089   0.000010     let opener = g:NERDTreeOpener.New(self.path, opts)
    1   0.095990   0.000011     call opener.open(self)

FUNCTION  <SNR>146_build_sections()
Called 35 times
Total time:   0.016882
 Self time:   0.003083

count  total (s)   self (s)
  170              0.000378   for key in a:keys
  135              0.000598     if (key == 'warning' || key == 'error') && !a:context.active
   14              0.000030       continue
                                endif
  121   0.014803   0.001004     call s:add_section(a:builder, a:context, key)
  121              0.000175   endfor

FUNCTION  <SNR>3_define_commands()
Called 1 time
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    1              0.000015   command! -nargs=+ -bar Plug call plug#(<args>)
    1              0.000033   if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
                              endif
    1              0.000014   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
    1              0.000011   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
    1              0.000007   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
    1              0.000009   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
    1              0.000005   command! -nargs=0 -bar PlugStatus  call s:status()
    1              0.000007   command! -nargs=0 -bar PlugDiff    call s:diff()
    1              0.000010   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)

FUNCTION  <SNR>186_CloseWindowIfNeeded()
Called 2 times
Total time:   0.000277
 Self time:   0.000041

count  total (s)   self (s)
    2   0.000269   0.000034     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    2              0.000004         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  40()
Called 6 times
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
    6              0.000093     let tmp = resolve(a:path)
    6              0.000110     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  41()
Called 8 times
Total time:   0.002162
 Self time:   0.001242

count  total (s)   self (s)
    8   0.000475   0.000070     call self.extractDriveLetter(a:fullpath)
                            
    8   0.000267   0.000076     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    8              0.000115     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
    8              0.000309     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
    8              0.000044     let self.isReadOnly = 0
    8              0.000058     if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
    3              0.000016         let self.isDirectory = 0
    3              0.000031         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    3              0.000005     else
    4              3.881470         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
    3              0.000014     let self.isExecutable = 0
    3              0.000007     if !self.isDirectory
    3              0.000030         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    3              0.000005     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    3   0.000092   0.000025     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    3   0.000202   0.000043     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    3   0.000134   0.000035     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    3              0.000008     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  43()
Called 1478 times
Total time:   7.807168
 Self time:   0.026604

count  total (s)   self (s)
 1478   7.648535   0.016039     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
 1478   0.157107   0.009038     call self.cacheDisplayString()

FUNCTION  45()
Called 3724 times
Total time:   0.614998
 Self time:   0.286745

count  total (s)   self (s)
 3724              0.017701     let options = a:0 ? a:1 : {}
 3724              0.009046     let toReturn = ""
                            
 3724              0.013516     if has_key(options, 'format')
   34              0.000131         let format = options['format']
   34              0.000159         if has_key(self, '_strFor' . format)
   34   0.001155   0.000414             exec 'let toReturn = self._strFor' . format . '()'
   34              0.000051         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
   34              0.000036     else
 3690   0.326200   0.025392         let toReturn = self._str()
 3690              0.006651     endif
                            
 3724   0.052185   0.025759     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
 3724              0.012543     if has_key(options, 'truncateTo')
   32              0.000129         let limit = options['truncateTo']
   32              0.000185         if len(toReturn) > limit-1
                                        let toReturn = toReturn[(len(toReturn)-limit+1):]
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
   32              0.000036     endif
                            
 3724              0.007727     return toReturn

FUNCTION  46()
Called 33 times
Total time:   0.000741
 Self time:   0.000741

count  total (s)   self (s)
   33              0.000273     let toReturn = '/' . join(self.pathSegments, '/')
   33              0.000145     if self.isDirectory && toReturn != '/'
   33              0.000143         let toReturn  = toReturn . '/'
   33              0.000048     endif
   33              0.000067     return toReturn

FUNCTION  48()
Called 1 time
Total time:   0.000207
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000182   0.000023     let p = escape(self.str(), self._escChars())
                            
                                "make it relative
    1              0.000009     let p = fnamemodify(p, ':.')
                            
                                "handle the edge case where the file begins with a + (vim interprets
                                "the +foo in `:e +foo` as an option to :edit)
    1              0.000004     if p[0] == "+"
                                    let p = '\' . p
                                endif
                            
    1              0.000002     if p ==# ''
                                    let p = '.'
                                endif
                            
    1              0.000001     return p

FUNCTION  <SNR>125_is_excluded_window()
Called 27 times
Total time:   0.002032
 Self time:   0.002032

count  total (s)   self (s)
   27              0.000113   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  108              0.000227   for matchw in g:airline_exclude_filenames
   81              0.000721     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   81              0.000102   endfor
                            
   27              0.000096   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   27              0.000037   return 0

FUNCTION  ale#history#Add()
Called 2 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    2              0.000007     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
    2              0.000013     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    2              0.000009     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
    2              0.000020     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    2              0.000011     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>74_isDarwin()
Called 1251 times
Total time:   0.011046
 Self time:   0.011046

count  total (s)   self (s)
 1251              0.005868   if exists('s:is_darwin')
 1251              0.003179     return s:is_darwin
                              endif
                            
                              if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
                              endif
                            
                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif
                            
                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif
                            
                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif
                            
                              return s:is_darwin

FUNCTION  132()
Called 482 times
Total time:   1.538786
 Self time:   0.005518

count  total (s)   self (s)
  482   1.538392   0.005124     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  134()
Called 32 times
Total time:   1.025226
 Self time:   0.000459

count  total (s)   self (s)
   32   1.025189   0.000422     return self._renderToString(0, 0)

FUNCTION  135()
Called 1568 times
Total time:   1.833873
 Self time:   1.616970

count  total (s)   self (s)
 1568              0.005274     let output = ""
 1568              0.003935     if a:drawText ==# 1
                            
 1536              0.008418         let treeParts = repeat('  ', a:depth - 1)
                            
 1536              0.004731         if !self.path.isDirectory
  512              0.001776             let treeParts = treeParts . '  '
  512              0.000681         endif
                            
 1536   0.324061   0.012460         let line = treeParts . self.displayString()
                            
 1536              0.006737         let output = output . line . "\n"
 1536              0.002148     endif
                            
                                "if the node is an open dir, draw its children
 1568              0.005635     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   96   0.291907   0.000797         let childNodesToDraw = self.getVisibleChildren()
                            
   96   0.290271   0.000844         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
 1632              0.002973             for i in childNodesToDraw
 1536              0.013238                 let output = output . i._renderToString(a:depth + 1, 1)
 1536              0.002707             endfor
   96              0.000105         endif
   96              0.000092     endif
                            
 1568              0.003348     return output

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 256 times
Total time:   0.125443
 Self time:   0.005851

count  total (s)   self (s)
  256   0.003577   0.002277   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
  256   0.121490   0.003198   return airline#extensions#tabline#formatters#{s:formatter}#format(a:nr, buffers)

FUNCTION  <SNR>3_esc()
Called 51 times
Total time:   0.000366
 Self time:   0.000366

count  total (s)   self (s)
   51              0.000315   return escape(a:path, ' ')

FUNCTION  50()
Called 3690 times
Total time:   0.300807
 Self time:   0.113308

count  total (s)   self (s)
 3690   0.097602   0.024873     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
 3690   0.068307   0.021484     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
 3690   0.108626   0.040680     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  51()
Called 3 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    3              0.000044     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  52()
Called 1 time
Total time:   0.000253
 Self time:   0.000118

count  total (s)   self (s)
    1   0.000141   0.000006     let str = self.str()
    3              0.000008     for t in range(tabpagenr('$'))
    6              0.000015         for b in tabpagebuflist(t+1)
    4              0.000049             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
    4              0.000004         endfor
    2              0.000002     endfor
    1              0.000001     return 0

FUNCTION  <SNR>68_buffer_repo()
Called 1 time
Total time:   0.000072
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000072   0.000016   return s:repo(self.getvar('git_dir'))

FUNCTION  <SNR>3_infer_properties()
Called 67 times
Total time:   0.004761
 Self time:   0.003194

count  total (s)   self (s)
   67              0.000202   let repo = a:repo
   67   0.000840   0.000345   if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(expand(repo)) }
                              else
   67              0.000234     if repo =~ ':'
                                  let uri = repo
                                else
   67              0.000182       if repo !~ '/'
    1              0.000003         let repo = 'vim-scripts/'. repo
    1              0.000001       endif
   67              0.000331       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
   67              0.000282       let uri = printf(fmt, repo)
   67              0.000079     endif
   67   0.001711   0.000639     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif

FUNCTION  142()
Called 1024 times
Total time:   0.276702
 Self time:   0.072664

count  total (s)   self (s)
 1024              0.003573     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
 1024              0.002383     let l:label = ''
 1024   0.160173   0.006949     let l:cascade = self.getCascade()
 2048              0.005125     for l:dirNode in l:cascade
 1024   0.021905   0.008809         let l:label .= l:dirNode.path.displayString()
 1024              0.001744     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
 1024              0.004219     if l:cascade[-1].isOpen
   64              0.000266         let l:symbol = g:NERDTreeDirArrowCollapsible
   64              0.000081     else
  960              0.003400         let l:symbol = g:NERDTreeDirArrowExpandable
  960              0.001239     endif
                            
 1024   0.046781   0.009063     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
 1024              0.007945     let l:result = l:symbol . ' ' . l:flags . l:label
 1024              0.002254     return l:result

FUNCTION  143()
Called 54 times
Total time:   0.085162
 Self time:   0.019676

count  total (s)   self (s)
   54   0.017097   0.000334     if a:path.equals(self.path)
                                    return self
                                endif
   54   0.016305   0.000672     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   45              0.000078         return {}
                                endif
                            
    9              0.000021     if self.path.isDirectory
   60              0.000139         for i in self.children
   60   0.003390   0.000411             let retVal = i.findNode(a:path)
   60              0.000155             if retVal != {}
    9              0.000014                 return retVal
                                        endif
   51              0.000069         endfor
                                endif
                                return {}

FUNCTION  144()
Called 1024 times
Total time:   0.153224
 Self time:   0.009544

count  total (s)   self (s)
 1024   0.149637   0.005957     if !self.isCascadable()
 1024              0.002502         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  19()
Called 1536 times
Total time:   0.019087
 Self time:   0.019087

count  total (s)   self (s)
 1536              0.005704     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
 1536              0.004380     return self.cachedDisplayString

FUNCTION  airline#extensions#tabline#ctrlspace#invalidate()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000004   let s:current_bufnr = -1
    1              0.000003   let s:current_tabnr = -1

FUNCTION  gitgutter#utility#filename()
Called 6 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    6              0.000027   return fnamemodify(s:file, ':t')

FUNCTION  plug#begin()
Called 1 time
Total time:   0.000344
 Self time:   0.000182

count  total (s)   self (s)
    1              0.000005   if a:0 > 0
    1              0.000004     let s:plug_home_org = a:1
    1   0.000071   0.000029     let home = s:path(fnamemodify(expand(a:1), ':p'))
    1              0.000003   elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
                              endif
                            
    1              0.000004   let g:plug_home = home
    1              0.000084   let g:plugs = {}
    1              0.000012   let g:plugs_order = []
    1              0.000005   let s:triggers = {}
                            
    1   0.000132   0.000011   call s:define_commands()
    1              0.000002   return 1

FUNCTION  ale#engine#InitBufferInfo()
Called 4 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    4              0.000025     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'active_linter_list': [],   'loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],}
                            
                                    return 1
                                endif
                            
    4              0.000006     return 0

FUNCTION  <SNR>141_get_syn()
Called 11426 times
Total time:   0.716461
 Self time:   0.716461

count  total (s)   self (s)
11426              0.058006   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
11426              0.027117   let color = ''
11426              0.114467   if hlexists(a:group)
10622              0.155408     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
10622              0.015932   endif
11426              0.044147   if empty(color) || color == -1
                                " should always exists
 2311              0.049312     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
 2311              0.009670     if empty(color) || color == -1
 1133              0.002753       let color = 'NONE'
 1133              0.001463     endif
 2311              0.002721   endif
11426              0.022885   return color

FUNCTION  airline#extensions#tabline#new_builder()
Called 12 times
Total time:   0.001214
 Self time:   0.000746

count  total (s)   self (s)
   12              0.000250   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
   12              0.000053   if get(g:, 'airline_powerline_fonts', 0)
   12              0.000091     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
   12              0.000082     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
   12              0.000016   else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
                              endif
                            
   12   0.000591   0.000123   return airline#builder#new(builder_context)

FUNCTION  <SNR>58_activateFileNode()
Called 1 time
Total time:   0.096132
 Self time:   0.000017

count  total (s)   self (s)
    1   0.096130   0.000016     call a:node.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  NERDTreeHighlightFile()
Called 23 times
Total time:   0.000802
 Self time:   0.000802

count  total (s)   self (s)
   23              0.000470 exec 'autocmd FileType nerdtree highlight ' . a:extension .' ctermbg='. a:bg .' ctermfg='. a:fg .' guibg='. a:guibg .' guifg='. a:guifg
   23              0.000301 exec 'autocmd FileType nerdtree syn match ' . a:extension .' #^\s\+.*'. a:extension .'$#'

FUNCTION  airline#section#create()
Called 12 times
Total time:   0.003492
 Self time:   0.000121

count  total (s)   self (s)
   12   0.003482   0.000110   return s:create(a:parts, 0)

FUNCTION  152()
Called 1216 times
Total time:   0.702016
 Self time:   0.096146

count  total (s)   self (s)
 1216              0.004258     let toReturn = []
 4832              0.010675     for i in self.children
 3616   0.642501   0.036631         if i.path.ignore(self.getNerdtree()) ==# 0
 3616              0.016513             call add(toReturn, i)
 3616              0.005070         endif
 3616              0.004440     endfor
 1216              0.002496     return toReturn

FUNCTION  154()
Called 1120 times
Total time:   0.433107
 Self time:   0.022201

count  total (s)   self (s)
 1120              0.004233     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
 1120   0.418246   0.007340     let c = self.getVisibleChildren()
 1120              0.005362     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  EasyMotion#highlight#init()
Called 1 time
Total time:   0.000929
 Self time:   0.000128

count  total (s)   self (s)
    1   0.000148   0.000023     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_target, s:target_hl_defaults)
    1   0.000155   0.000014     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_first_group_target, s:target_hl2_first_defaults)
    1   0.000125   0.000016     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_second_group_target, s:target_hl2_second_defaults)
    1   0.000118   0.000013     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_shade,  s:shade_hl_defaults)
    1   0.000119   0.000012     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_search, s:target_hl_inc)
    1   0.000121   0.000014     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_cursor, s:target_hl_inc_cursor)
    1   0.000118   0.000012     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_move, s:target_hl_move)
    1              0.000015     if exists(':CSApprox') == 2 && g:EasyMotion_force_csapprox
                                    "TODO: better solution or remove completly
                                    CSApprox!
                                endif

FUNCTION  <SNR>145_get_accented_line()
Called 210 times
Total time:   0.014964
 Self time:   0.014964

count  total (s)   self (s)
  210              0.000809   if a:self._context.active
  164              0.000468     let contents = []
  164              0.001567     let content_parts = split(a:contents, '__accent')
  333              0.000827     for cpart in content_parts
  169              0.001885       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  169              0.000799       call add(contents, cpart)
  169              0.000263     endfor
  164              0.000971     let line = join(contents, a:group)
  164              0.001562     let line = substitute(line, '__restore__', a:group, 'g')
  164              0.000257   else
   46              0.000807     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   46              0.000444     let line = substitute(line, '%#__restore__#', '', 'g')
   46              0.000075   endif
  210              0.000408   return line

FUNCTION  <SNR>129_get_hunks_gitgutter()
Called 1247 times
Total time:   0.094456
 Self time:   0.026390

count  total (s)   self (s)
 1247   0.027239   0.013519   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    1              0.000002     return ''
                              endif
 1246   0.061302   0.006955   return GitGutterGetHunkSummary()

FUNCTION  airline#extensions#default#apply()
Called 27 times
Total time:   0.021686
 Self time:   0.002216

count  total (s)   self (s)
   27              0.000163   let winnr = a:context.winnr
   27              0.000085   let active = a:context.active
                            
   27   0.000430   0.000251   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   20   0.008020   0.000211     call s:build_sections(a:builder, a:context, s:layout[0])
   20              0.000026   else
    7   0.000490   0.000062     let text = s:get_section(winnr, 'c')
    7              0.000020     if empty(text)
                                  let text = ' %f%m '
                                endif
    7   0.000118   0.000064     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    7              0.000010   endif
                            
   27   0.002148   0.000384   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   27   0.000350   0.000187   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   15   0.009229   0.000155     call s:build_sections(a:builder, a:context, s:layout[1])
   15              0.000018   endif
                            
   27              0.000039   return 1

FUNCTION  ale#FileTooLarge()
Called 902 times
Total time:   0.054383
 Self time:   0.016606

count  total (s)   self (s)
  902   0.047507   0.009730     let l:max = ale#Var(bufnr(''), 'maximum_file_size')
                            
  902              0.005336     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>177_GetCounts()
Called 2494 times
Total time:   0.079820
 Self time:   0.070748

count  total (s)   self (s)
 2494              0.021871     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
  824   0.014337   0.005266         return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
 1670              0.009620     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
 1670              0.007121     return g:ale_buffer_info[a:buffer].count

FUNCTION  75()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000008     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    2              0.000003     return s:keyMaps

FUNCTION  76()
Called 1 time
Total time:   0.000093
 Self time:   0.000084

count  total (s)   self (s)
    8   0.000027   0.000017     for i in s:KeyMap.All()
    8              0.000039          if i.key ==# a:key && i.scope ==# a:scope
    1              0.000001             return i
                                    endif
    7              0.000008     endfor
                                return {}

FUNCTION  78()
Called 52 times
Total time:   0.002759
 Self time:   0.002759

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
   52              0.000175     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
   52              0.000350     if self.key =~# specialNotationRegex
   14              0.000175         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
   14              0.000021     else
   38              0.000109         let keymapInvokeString = self.key
   38              0.000042     endif
                            
   52              0.000183     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
   52              0.001250     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  <SNR>82_Detect()
Called 2 times
Total time:   0.001273
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000010   if !exists('b:rake_root')
    2   0.001245   0.000023     let dir = s:find_root(a:path)
    2              0.000005     if dir !=# ''
                                  let b:rake_root = dir
                                endif
    2              0.000002   endif

FUNCTION  <SNR>81_Setup()
Called 2 times
Total time:   0.001078
 Self time:   0.000032

count  total (s)   self (s)
    2   0.001067   0.000021   if s:Detect(a:path)
                                silent doautocmd User Bundler
                              endif

FUNCTION  ale#engine#IsCheckingBuffer()
Called 10 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
   10              0.000075     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   10              0.000064     return !empty(get(l:info, 'active_linter_list', []))

FUNCTION  NERDTreeRender()
Called 32 times
Total time:   1.050216
 Self time:   0.000262

count  total (s)   self (s)
   32   1.050182   0.000228     call nerdtree#renderView()

FUNCTION  164()
Called 990 times
Total time:   8.647225
 Self time:   6.977900

count  total (s)   self (s)
  990   6.284152   0.010258     call self.path.refreshFlags(self.getNerdtree())
 2430              0.006466     for i in self.children
 1440   0.705174   0.007744         call i.refreshFlags()
 1440              0.002105     endfor

FUNCTION  165()
Called 6 times
Total time:   0.005753
 Self time:   0.000073

count  total (s)   self (s)
    6   0.005748   0.000068     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  gitgutter#utility#bufnr()
Called 59 times
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
   59              0.000166   return s:bufnr

FUNCTION  ale#events#EnterEvent()
Called 5 times
Total time:   0.000460
 Self time:   0.000135

count  total (s)   self (s)
    5              0.000038     let l:filetype = getbufvar(a:buffer, '&filetype')
    5              0.000035     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
    5   0.000371   0.000046     call s:LintOnEnter(a:buffer)

FUNCTION  airline#highlighter#get_highlight()
Called 5713 times
Total time:   1.114844
 Self time:   0.331840

count  total (s)   self (s)
 5713   0.404747   0.047106   let fg = s:get_syn(a:group, 'fg')
 5713   0.405376   0.046556   let bg = s:get_syn(a:group, 'bg')
 5713              0.167278   let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 5713   0.128011   0.061468   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  airline#parts#get()
Called 12 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
   12              0.000074   return get(s:parts, a:key, {})

FUNCTION  NERDTreeWebDevIconsRefreshListener()
Called 1478 times
Total time:   0.478809
 Self time:   0.206554

count  total (s)   self (s)
 1478              0.006763   let path = a:event.subject
 1478              0.005449   let padding = g:WebDevIconsNerdTreeAfterGlyphPadding
 1478              0.003599   let prePadding = ''
 1478   0.034872   0.014899   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
 1478              0.010448   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
                            
 1478              0.004860   if g:WebDevIconsUnicodeGlyphDoubleWidth == 0
                                let padding = ''
                              endif
                            
 1478              0.004400   if hasGitFlags && g:WebDevIconsUnicodeGlyphDoubleWidth == 1
  126              0.001803     let prePadding = ' '
  126              0.000173   endif
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
 1478              0.006221   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
 1352              0.004742     let prePadding .= '  '
 1352              0.001787   endif
                            
 1478              0.003334   if !path.isDirectory
  482   0.232515   0.007467     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . padding
  482              0.001780   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                let directoryOpened = 0
                            
                                if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
                                endif
                            
                                if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . padding
                                  else
                                    let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory, 0) . padding
                                  endif
                                else
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . padding
                                  else
                                    let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . padding
                                  endif
                                endif
                              else
  996              0.002350     let flag = ''
  996              0.001345   endif
                            
 1478   0.023099   0.012520   call path.flagSet.clearFlags('webdevicons')
                            
 1478              0.004353   if flag !=? ''
  482   0.020242   0.003587     call path.flagSet.addFlag('webdevicons', flag)
  482              0.000579   endif
                            

FUNCTION  airline#extensions#ale#get()
Called 2494 times
Total time:   0.309323
 Self time:   0.183897

count  total (s)   self (s)
 2494              0.015606   if !exists(':ALELint')
                                return ''
                              endif
                            
 2494              0.011120   let is_err = a:type ==# 'error'
 2494              0.012085   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
 2494              0.008740   let is_err = a:type ==# 'error'
 2494   0.134985   0.022024   let counts = ale#statusline#Count(bufnr(''))
 2494              0.013005   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
 2494              0.016896   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
 2494              0.012870     let errors = counts.error + counts.style_error
 2494              0.012541     let num = is_err ? errors : counts.total - errors
 2494              0.003596   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
 2494   0.032844   0.020378   return s:airline_ale_count(num, symbol)

FUNCTION  80()
Called 1 time
Total time:   0.096167
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000009     let Callback = function(self.callback)
    1              0.000002     if a:0
    1   0.096147   0.000015         call Callback(a:1)
    1              0.000002     else
                                    call Callback()
                                endif

FUNCTION  81()
Called 1 time
Total time:   0.113881
 Self time:   0.000097

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    1   0.000030   0.000017     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
    1   0.017542   0.000030     let node = g:NERDTreeFileNode.GetSelected()
    1              0.000003     if !empty(node)
                            
                                    "try file node
    1              0.000002         if !node.path.isDirectory
    1   0.000103   0.000010             let km = s:KeyMap.FindFor(a:key, "FileNode")
    1              0.000003             if !empty(km)
    1   0.096181   0.000014                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "DirNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  86()
Called 1478 times
Total time:   0.018129
 Self time:   0.018129

count  total (s)   self (s)
 1478              0.007616     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
 1478              0.003249     return g:NERDTreeBookmarks

FUNCTION  gitgutter#utility#set_buffer()
Called 35 times
Total time:   0.000828
 Self time:   0.000828

count  total (s)   self (s)
   35              0.000157   let s:bufnr = a:bufnr
   35              0.000599   let s:file = resolve(bufname(a:bufnr))

FUNCTION  airline#util#wrap()
Called 10041 times
Total time:   0.112535
 Self time:   0.112535

count  total (s)   self (s)
10041              0.048998   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
10041              0.021723   return a:text

FUNCTION  gitgutter#debug#log()
Called 10 times
Total time:   0.000701
 Self time:   0.000701

count  total (s)   self (s)
   10              0.000044   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  172()
Called 2 times
Total time:   0.000044
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000006     if self._keepopen
                                    return
                                endif
                            
    2              0.000008     if (a:newtab && self._where == 't') || !a:newtab
    1   0.000018   0.000009         call g:NERDTree.CloseIfQuitOnOpen()
    1              0.000001     endif

FUNCTION  174()
Called 1 time
Total time:   0.068624
 Self time:   0.000061

count  total (s)   self (s)
    1   0.000013   0.000008     if b:NERDTree.isWinTree()
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
    1   0.000020   0.000007         call self._checkToCloseTree(1)
                            
    1              0.000002         if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
    1   0.068522   0.000008             call self._previousWindow()
    1              0.000001         endif
                            
    1   0.000037   0.000007         call self._checkToCloseTree(0)
    1              0.000001     endif

FUNCTION  175()
Called 2 times
Total time:   0.052525
 Self time:   0.000103

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    2              0.000007     if winnr("$") ==# 1
                                    return 0
                                endif
                            
    2              0.000006     let oldwinnr = winnr()
    2   0.032046   0.000015     call nerdtree#exec(a:winnumber . "wincmd p")
    2              0.000020     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
    2              0.000007     let modified = &modified
    2   0.020407   0.000016     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    2              0.000005     if specialWindow
                                    return 0
                                endif
                            
    2              0.000003     if &hidden
    2              0.000002         return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  179()
Called 1 time
Total time:   0.095980
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                else
    1   0.095971   0.000010         call self._openFile()
    1              0.000001     endif

FUNCTION  <SNR>160_RunLinter()
Called 2 times
Total time:   0.000365
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000008     if !empty(a:linter.lsp)
                                    return s:CheckWithLSP(a:buffer, a:linter)
                                else
    2   0.000042   0.000022         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    2   0.000285   0.000021         if ale#engine#IsExecutable(a:buffer, l:executable)
                                        return s:InvokeChain(a:buffer, a:linter, 0, [])
                                    endif
    2              0.000002     endif
                            
    2              0.000002     return 0

FUNCTION  <SNR>69_init()
Called 14 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   14              0.000042   if s:airline_initialized
   14              0.000019     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  <SNR>68_BufReadIndexFile()
Called 1 time
Total time:   0.740466
 Self time:   0.000162

count  total (s)   self (s)
    1              0.000004   try
    1              0.000005     let b:fugitive_type = 'blob'
    1   0.000240   0.000016     let b:git_dir = s:repo().dir()
    1              0.000003     try
    1   0.740162   0.000082       call s:ReplaceCmd(s:repo().git_command('cat-file','blob',s:buffer().sha1()))
    1              0.000003     finally
    1              0.000004       if &bufhidden ==# ''
    1              0.000008         setlocal bufhidden=delete
    1              0.000002       endif
    1              0.000009       setlocal noswapfile
    1              0.000002     endtry
    1              0.000002     return ''
                              catch /^fugitive: rev-parse/
                                silent exe 'doau BufNewFile '.s:fnameescape(expand('%:p'))
                                return ''
                              catch /^fugitive:/
                                return 'echoerr v:errmsg'
                              endtry

FUNCTION  <SNR>19_LoadIndent()
Called 2 times
Total time:   0.001402
 Self time:   0.001329

count  total (s)   self (s)
    2              0.000011     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    2              0.000010     let s = expand("<amatch>")
    2              0.000006     if s != ""
    2              0.000007       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000019       for name in split(s, '\.')
    2   0.001308   0.001235 	exe 'runtime! indent/' . name . '.vim'
    2              0.000004       endfor
    2              0.000002     endif

FUNCTION  <SNR>68_sub()
Called 1254 times
Total time:   0.035501
 Self time:   0.035501

count  total (s)   self (s)
 1254              0.033819   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  airline#extensions#tabline#get()
Called 64 times
Total time:   0.120836
 Self time:   0.004294

count  total (s)   self (s)
   64              0.000605   let curtabcnt = tabpagenr('$')
   64              0.000274   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
   64              0.000454   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
   64              0.000129   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif s:show_buffers && curtabcnt == 1 || !s:show_tabs
                                return airline#extensions#tabline#buffers#get()
                              else
   64   0.117219   0.000676     return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  176()
Called 1 time
Total time:   0.000080
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000012     let newObj = copy(self)
                            
    1              0.000003     let newObj._path = a:path
    1   0.000013   0.000007     let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
                            
    1              0.000003     if has_key(a:opts, 'reuse')
    1              0.000003         let newObj._reuse = a:opts['reuse']
    1              0.000001     else
                                    let newObj._reuse = ''
                                endif
                            
    1   0.000012   0.000006     let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    1              0.000005     let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    1              0.000003     let newObj._nerdtree = b:NERDTree
    1   0.000015   0.000006     call newObj._saveCursorPos()
                            
    1              0.000002     return newObj

FUNCTION  <SNR>3_is_local_plug()
Called 67 times
Total time:   0.000495
 Self time:   0.000495

count  total (s)   self (s)
   67              0.000441     return a:repo[0] =~ '[/$~]'

FUNCTION  <SNR>182_GetLinterNames()
Called 4 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   16              0.000051     for l:dict in [   get(b:, 'ale_linters', {}),   g:ale_linters,   s:default_ale_linters,]
   12              0.000044         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
   12              0.000012     endfor
                            
    4              0.000005     return 'all'

FUNCTION  <SNR>41_addtomrufs()
Called 17 times
Total time:   0.003067
 Self time:   0.003067

count  total (s)   self (s)
   17              0.000372 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
   17              0.000220 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
   17              0.000157 	let abs_fn = fnamemodify(fn,':p')
   17              0.001991 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
   13              0.000034 		retu
                            	en
    4              0.000047 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    4              0.000009 	if idx
    1              0.000014 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    1              0.000006 		cal insert(s:mrufs, fn)
    1              0.000004 		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
    1              0.000001 	en

FUNCTION  180()
Called 1 time
Total time:   0.095961
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000631   0.000008     if self._reuseWindow()
                                    return
                                endif
                            
    1   0.068634   0.000009     call self._gotoTargetWin()
    1   0.026679   0.000012     call self._path.edit()
    1              0.000005     if self._stay
                                    call self._restoreCursorPos()
                                endif

FUNCTION  182()
Called 1 time
Total time:   0.068514
 Self time:   0.000057

count  total (s)   self (s)
    1   0.026637   0.000012     if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
    1              0.000002         try
    1   0.025908   0.000009             if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
                                        else
    1   0.015939   0.000007                 call nerdtree#exec('wincmd p')
    1              0.000002             endif
    1              0.000002         catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
    1              0.000001     endif

FUNCTION  185()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005     let self._bufnr = bufnr("")
    1              0.000003     let self._tabnr = tabpagenr()

FUNCTION  186()
Called 1 time
Total time:   0.003371
 Self time:   0.000147

count  total (s)   self (s)
                                "make <cr> do the same as the activate node mapping
    1              0.000070     nnoremap <silent> <buffer> <cr> :call nerdtree#ui_glue#invokeKeyMap(g:NERDTreeMapActivateNode)<cr>
                            
    1   0.003232   0.000008     call g:NERDTreeKeyMap.BindAll()
                            
    1              0.000009     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
    1              0.000011     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
    1              0.000008     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
    1              0.000007     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
    1              0.000007     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
    1              0.000008     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
    1              0.000009     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
    1              0.000005     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()

FUNCTION  <SNR>135_update_tabline()
Called 1 time
Total time:   0.000219
 Self time:   0.000111

count  total (s)   self (s)
    1              0.000008   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
    1              0.000009   let match = expand('<afile>')
    1              0.000004   if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match) || match(match, s:ignore_bufadd_pat) > -1 || isdirectory(expand("<afile>"))
                                return
                              endif
    1   0.000123   0.000015   doautocmd User BufMRUChange

FUNCTION  airline#extensions#apply_left_override()
Called 12 times
Total time:   0.003826
 Self time:   0.000334

count  total (s)   self (s)
   12              0.000065   let w:airline_section_a = a:section1
   12              0.000047   let w:airline_section_b = a:section2
   12   0.003609   0.000117   let w:airline_section_c = airline#section#create(['readonly'])
   12              0.000044   let w:airline_render_left = 1
   12              0.000038   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
Called 233 times
Total time:   0.001536
 Self time:   0.001536

count  total (s)   self (s)
  233              0.001328     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#tabline#buffers#invalidate()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000009   let s:current_bufnr = -1

FUNCTION  gitgutter#highlight#define_sign_column_highlight()
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000004   if g:gitgutter_override_sign_column_highlight
                                highlight! link SignColumn LineNr
                              else
    1              0.000025     highlight default link SignColumn LineNr
    1              0.000001   endif

FUNCTION  ale#CallWithCooldown()
Called 909 times
Total time:   0.346713
 Self time:   0.061581

count  total (s)   self (s)
  909   0.023795   0.011299     let l:now = ale#util#ClockMilliseconds()
                            
  909              0.010444     if l:now < get(s:timestamp_map, a:timestamp_key, -1)
                                    return 0
                                endif
                            
  909              0.008950     let s:timestamp_map[a:timestamp_key] = l:now + s:error_delay_ms
                            
  909   0.280009   0.018606     let l:return_value = call(a:func, a:arglist)
                            
  909              0.005435     let s:timestamp_map[a:timestamp_key] = -1
                            
  909              0.002356     return l:return_value

FUNCTION  airline#extensions#tabline#title()
Called 128 times
Total time:   0.077400
 Self time:   0.009592

count  total (s)   self (s)
  128              0.000535   let title = ''
  128              0.000313   if s:taboo
                                let title = TabooTabTitle(a:n)
                              endif
                            
  128              0.000747   if empty(title) && exists('*gettabvar')
  128              0.000805     let title = gettabvar(a:n, 'title')
  128              0.000201   endif
                            
  128              0.000330   if empty(title)
  128              0.000684     let buflist = tabpagebuflist(a:n)
  128              0.000563     let winnr = tabpagewinnr(a:n)
  128   0.005193   0.001117     let all_buffers = airline#extensions#tabline#buflist#list()
  128   0.066791   0.003058     return airline#extensions#tabline#get_buffer_name( buflist[winnr - 1], filter(buflist, 'index(all_buffers, v:val) != -1'))
                              endif
                            
                              return title

FUNCTION  196()
Called 1 time
Total time:   0.048200
 Self time:   0.000281

count  total (s)   self (s)
                                "create the nerd tree window
    1              0.000006     let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    1              0.000003     let splitSize = g:NERDTreeWinSize
                            
    1              0.000004     if !exists('t:NERDTreeBufName')
                                    let t:NERDTreeBufName = self._nextBufferName()
                                    silent! exec splitLocation . 'vertical ' . splitSize . ' new'
                                    silent! exec "edit " . t:NERDTreeBufName
                                else
    1   0.013855   0.000167         silent! exec splitLocation . 'vertical ' . splitSize . ' split'
    1   0.010728   0.000069         silent! exec "buffer " . t:NERDTreeBufName
    1              0.000001     endif
                            
    1   0.000008   0.000007     setlocal winfixwidth
    1   0.023581   0.000010     call self._setCommonBufOptions()

FUNCTION  198()
Called 2 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000041     let newCreator = copy(self)
    2              0.000006     return newCreator

FUNCTION  283()
Called 7 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
    7              0.000058   if self.owner == a:jobid
                                let self.owner = 0
                              endif

FUNCTION  airline#themes#patch()
Called 1 time
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    8              0.000017   for mode in keys(a:palette)
    7              0.000027     if !has_key(a:palette[mode], 'airline_warning')
    1              0.000006       let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
    1              0.000001     endif
    7              0.000024     if !has_key(a:palette[mode], 'airline_error')
    1              0.000005       let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
    1              0.000001     endif
    7              0.000007   endfor
                            
    1              0.000007   let a:palette.accents = get(a:palette, 'accents', {})
    1              0.000004   let a:palette.accents.none = [ '', '', '', '', '' ]
    1              0.000004   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    1              0.000003   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    1              0.000003   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    1              0.000003   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
    1              0.000003   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
    1              0.000003   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
    1              0.000003   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
    1              0.000003   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif

FUNCTION  <SNR>68_shellslash()
Called 5 times
Total time:   0.000165
 Self time:   0.000096

count  total (s)   self (s)
    5   0.000106   0.000037   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
    5              0.000013     return a:path
                              endif

FUNCTION  <SNR>27_SetupPasta()
Called 2 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
    2              0.000014   if exists("g:pasta_enabled_filetypes")
                                if index(g:pasta_enabled_filetypes, &ft) == -1
                                  return
                                endif
                              elseif exists("g:pasta_disabled_filetypes") && index(g:pasta_disabled_filetypes, &ft) != -1
    1              0.000002     return
                              endif
                            
    1              0.000062   exe "nmap <buffer> " . g:pasta_paste_before_mapping . " <Plug>BeforePasta"
    1              0.000028   exe "xmap <buffer> " . g:pasta_paste_before_mapping . " <Plug>VisualPasta"
                            
    1              0.000028   exe "nmap <buffer> " . g:pasta_paste_after_mapping . " <Plug>AfterPasta"
    1              0.000026   exe "xmap <buffer> " . g:pasta_paste_after_mapping . " <Plug>VisualPasta"

FUNCTION  285()
Called 7 times
Total time:   0.043322
 Self time:   0.043322

count  total (s)   self (s)
    7              0.000043   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
    7              0.000021   if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                return 0
                              end
                            
    7              0.000048   let selection = s:selections[a:reg]
    7              0.000023   if selection.owner > 0
                                " The previous provider instance should exit when the new one takes
                                " ownership, but kill it to be sure we don't fill up the job table.
    7              0.000056     call jobstop(selection.owner)
    7              0.000012   end
    7              0.000055   let selection.data = [a:lines, a:regtype]
    7              0.000099   let argv = split(s:copy[a:reg], " ")
    7              0.000051   let selection.detach = s:cache_enabled
    7              0.000036   let selection.cwd = "/"
    7              0.042083   let jobid = jobstart(argv, selection)
    7              0.000134   if jobid <= 0
                                echohl WarningMsg
                                echo "clipboard: error when invoking provider"
                                echohl None
                                return 0
                              endif
    7              0.000192   call jobsend(jobid, a:lines)
    7              0.000042   call jobclose(jobid, 'stdin')
    7              0.000040   let selection.owner = jobid

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 256 times
Total time:   0.008209
 Self time:   0.008209

count  total (s)   self (s)
  256              0.001704   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
  256              0.002380   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
  256              0.001735   if getbufvar(a:bufnr, '&modified') == 1
   58              0.000293     let _ .= s:buf_modified_symbol
   58              0.000087   endif
  256              0.000519   return _

FUNCTION  <SNR>111_Highlight_Matching_Pair()
Called 566 times
Total time:   0.084486
 Self time:   0.084486

count  total (s)   self (s)
                              " Remove any previous match.
  566              0.004856   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  566              0.003757   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  566              0.002703   let c_lnum = line('.')
  566              0.002341   let c_col = col('.')
  566              0.001585   let before = 0
                            
  566              0.002890   let text = getline(c_lnum)
  566              0.013408   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  566              0.002473   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  566              0.004415     let [c_before, c] = matches[1:2]
  566              0.001091   endif
  566              0.012186   let plist = split(&matchpairs, '.\zs[:,]')
  566              0.003760   let i = index(plist, c)
  566              0.001553   if i < 0
                                " not found, in Insert mode try character before the cursor
  566              0.003054     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   86              0.000411       let before = strlen(c_before)
   86              0.000245       let c = c_before
   86              0.000379       let i = index(plist, c)
   86              0.000142     endif
  566              0.001285     if i < 0
                                  " not found, nothing to do
  566              0.000948       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  ale#Queue()
Called 2 times
Total time:   0.006445
 Self time:   0.000077

count  total (s)   self (s)
    2              0.000006     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
    2              0.000010     let l:linting_flag = get(a:000, 0, '')
    2              0.000010     let l:buffer = get(a:000, 1, bufnr(''))
                            
    2   0.006403   0.000036     return ale#CallWithCooldown(   'dont_queue_until',   function('s:ALEQueueImpl'),   [a:delay, l:linting_flag, l:buffer],)

FUNCTION  <SNR>68_BufWriteIndexFile()
Called 5 times
Total time:   4.970165
 Self time:   1.755120

count  total (s)   self (s)
    5              0.000069   let tmp = tempname()
    5              0.000018   try
    5              0.000182     let path = matchstr(expand('<amatch>'),'//\d/\zs.*')
    5              0.000083     let stage = matchstr(expand('<amatch>'),'//\zs\d')
    5   1.658985   0.045531     silent execute 'write !'.s:repo().git_command('hash-object','-w','--stdin').' > '.tmp
    5              0.000750     let sha1 = readfile(tmp)[0]
    5   1.594236   0.000348     let old_mode = matchstr(s:repo().git_chomp('ls-files','--stage',path),'^\d\+')
    5              0.000031     if old_mode == ''
                                  let old_mode = executable(s:repo().tree(path)) ? '100755' : '100644'
                                endif
    5              0.000048     let info = old_mode.' '.sha1.' '.stage."\t".path
    5              0.001011     call writefile([info],tmp)
    5   0.000228   0.000054     if s:winshell()
                                  let error = system('type '.s:gsub(tmp,'/','\\').'|'.s:repo().git_command('update-index','--index-info'))
                                else
    5   1.704557   1.703656       let error = system(s:repo().git_command('update-index','--index-info').' < '.tmp)
    5              0.000060     endif
    5              0.000040     if v:shell_error == 0
    5              0.000155       setlocal nomodified
    5              0.000083       if exists('#BufWritePost')
    5   0.007326   0.000700         execute 'doautocmd BufWritePost '.s:fnameescape(expand('%:p'))
                                  endif
                                  call fugitive#reload_status()
                                  return ''
                                else
                                  return 'echoerr '.string('fugitive: '.error)
                                endif
                              finally
    5              0.000384     call delete(tmp)
    4             14.271231   endtry

FUNCTION  <SNR>185_GroupLoclistItems()
Called 4 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
    4              0.000017     let l:grouped_items = []
    4              0.000012     let l:last_lnum = -1
                            
    4              0.000012     for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
                                endfor
                            
    4              0.000010     return l:grouped_items

FUNCTION  fugitive#extract_git_dir()
Called 1 time
Total time:   0.000136
 Self time:   0.000070

count  total (s)   self (s)
    1   0.000075   0.000036   if s:shellslash(a:path) =~# '^fugitive://.*//'
    1   0.000060   0.000032     return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
                              if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
                                let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
                              endif
                              let root = s:shellslash(resolve(path))
                              let previous = ""
                              while root !=# previous
                                if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
                                if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
                                if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
                                if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
                                let dir = s:sub(root, '[\/]$', '') . '/.git'
                                let type = getftype(dir)
                                if type ==# 'dir' && fugitive#is_git_dir(dir)
                                  return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''

FUNCTION  gitgutter#utility#directory_of_file()
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000013   return fnamemodify(s:file, ':h')

FUNCTION  airline#highlighter#load_theme()
Called 1 time
Total time:   0.238027
 Self time:   0.000091

count  total (s)   self (s)
    1              0.000003   if pumvisible()
                                return
                              endif
    2              0.000013   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
    1   0.000456   0.000008     call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
    1              0.000001   endfor
    1   0.118508   0.000012   call airline#highlighter#highlight(['inactive'])
    1              0.000013   if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
                              else
    1   0.119013   0.000023     call airline#highlighter#highlight(['normal'])
    1              0.000001   endif

FUNCTION  fugitive#head()
Called 1247 times
Total time:   0.359867
 Self time:   0.031091

count  total (s)   self (s)
 1247              0.006407   if !exists('b:git_dir')
                                return ''
                              endif
                            
 1247   0.347244   0.018468   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  ctrlp#utils#mkdir()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000014 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    1              0.000003 	retu a:dir

FUNCTION  ale#engine#IsExecutable()
Called 2 times
Total time:   0.000265
 Self time:   0.000177

count  total (s)   self (s)
    2              0.000013     if has_key(s:executable_cache_map, a:executable)
                                    return 1
                                endif
                            
    2              0.000005     let l:result = 0
                            
    2              0.000100     if executable(a:executable)
                                    let s:executable_cache_map[a:executable] = 1
                            
                                    let l:result = 1
                                endif
                            
    2              0.000005     if g:ale_history_enabled
    2   0.000112   0.000024         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    2              0.000003     endif
                            
    2              0.000004     return l:result

FUNCTION  airline#extensions#branch#get_head()
Called 1247 times
Total time:   2.959185
 Self time:   0.045357

count  total (s)   self (s)
 1247   2.923998   0.010170   let head = airline#extensions#branch#head()
 1247              0.008892   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
 1247              0.009039   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
 1247              0.014100   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 3 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000013   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
    3              0.000006   return s:using_xolox_shell

FUNCTION  nerdtree#runningWindows()
Called 14056 times
Total time:   0.177378
 Self time:   0.177378

count  total (s)   self (s)
14056              0.166128     return has("win16") || has("win32") || has("win64")

FUNCTION  280()
Called 210 times
Total time:   0.001724
 Self time:   0.001724

count  total (s)   self (s)
  210              0.001526   call add(self._sections, [a:group, a:contents])

FUNCTION  ale#events#FileTypeEvent()
Called 2 times
Total time:   0.000122
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000016     let l:filetype = getbufvar(a:buffer, 'ale_original_filetype', '')
                            
                                " If we're setting the filetype for the first time after it was blank,
                                " and the option for linting on enter is off, then we should set this
                                " filetype as the original filetype. Otherwise ALE will still appear to
                                " lint files because of the BufEnter event, etc.
    2   0.000069   0.000016     if empty(l:filetype) && !ale#Var(a:buffer, 'lint_on_enter')
    1              0.000009         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
    1              0.000003     elseif a:new_filetype isnot# l:filetype
                                    call ale#Queue(300, 'lint_file', a:buffer)
                                endif

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 24 times
Total time:   0.000981
 Self time:   0.000981

count  total (s)   self (s)
   24              0.000119   let cur = bufnr('%')
   24              0.000064   if cur == a:bufnr
   12              0.000067     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    4              0.000011       let group = 'airline_tabmod'
    4              0.000005     else
    8              0.000020       let group = 'airline_tabsel'
    8              0.000010     endif
   12              0.000012   else
   12              0.000068     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
   12              0.000033       let group = 'airline_tab'
   12              0.000014     else
                                  let group = 'airline_tabhid'
                                endif
   12              0.000013   endif
   24              0.000049   return group

FUNCTION  <SNR>64_update_oldfiles()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000008   if g:startify_locked || !exists('v:oldfiles')
                                return
                              endif
    1              0.000008   let idx = index(v:oldfiles, a:file)
    1              0.000003   if idx != -1
    1              0.000006     call remove(v:oldfiles, idx)
    1              0.000002   endif
    1              0.000006   call insert(v:oldfiles, a:file, 0)

FUNCTION  <SNR>155_FindItemAtCursor()
Called 416 times
Total time:   0.027287
 Self time:   0.019254

count  total (s)   self (s)
  416              0.001986     let l:buf = bufnr('')
  416              0.002868     let l:info = get(g:ale_buffer_info, l:buf, {})
  416              0.002403     let l:loclist = get(l:info, 'loclist', [])
  416              0.001752     let l:pos = getcurpos()
  416   0.013200   0.005167     let l:index = ale#util#BinarySearch(l:loclist, l:buf, l:pos[1], l:pos[2])
  416              0.002081     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
  416              0.001477     return [l:info, l:loc]

FUNCTION  airline#highlighter#highlight()
Called 23 times
Total time:   2.031635
 Self time:   0.217269

count  total (s)   self (s)
   23              0.000113   let bufnr = a:0 ? a:1 : ''
   23              0.000133   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   23              0.000374   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   23              0.000125   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   59              0.000160   for mode in mapped
   36              0.000151     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
   36              0.000308     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   23              0.000148       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  913              0.003098       for kvp in items(dict)
  890              0.004119         let mode_colors = kvp[1]
  890              0.006582         let name = kvp[0]
  890              0.004385         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    3              0.000014           let name = 'airline_c'.bufnr
    3              0.000005         endif
  890   0.375682   0.009920         call airline#highlighter#exec(name.suffix, mode_colors)
                            
 2670              0.008522         for accent in keys(s:accents)
 1780              0.008245           if !has_key(p.accents, accent)
                                        continue
                                      endif
 1780              0.010438           let colors = copy(mode_colors)
 1780              0.009563           if p.accents[accent][0] != ''
  890              0.005010             let colors[0] = p.accents[accent][0]
  890              0.001324           endif
 1780              0.007082           if p.accents[accent][2] != ''
  890              0.004398             let colors[2] = p.accents[accent][2]
  890              0.001268           endif
 1780              0.005415           if len(colors) >= 5
 1780              0.011158             let colors[4] = get(p.accents[accent], 4, '')
 1780              0.002688           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
 1780   0.766389   0.021821           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
 1780              0.002973         endfor
  890              0.001240       endfor
                            
                                  " TODO: optimize this
  777              0.002473       for sep in items(s:separators)
  754   0.716677   0.012642         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  754              0.001303       endfor
   23              0.000093     endif
   36              0.000045   endfor

FUNCTION  <SNR>145_section_is_empty()
Called 249 times
Total time:   0.004385
 Self time:   0.004385

count  total (s)   self (s)
  249              0.000824   let start=1
                            
                              " do not check for inactive windows or the tabline
  249              0.000797   if a:self._context.active == 0
   59              0.000095     return 0
                              elseif get(a:self._context, 'tabline', 0)
   96              0.000151     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   94              0.000366   if get(g:, 'airline_skip_empty_sections', 0) == 0
   94              0.000138     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  GetVimIndent()
Called 5 times
Total time:   0.001783
 Self time:   0.000389

count  total (s)   self (s)
    5              0.000096   let ignorecase_save = &ignorecase
    5              0.000024   try
    5   0.000103   0.000087     let &ignorecase = 0
    5   0.001446   0.000073     return GetVimIndentIntern()
                              finally
    5   0.000054   0.000048     let &ignorecase = ignorecase_save
    5              0.000016   endtry

FUNCTION  airline#parts#ffenc()
Called 14 times
Total time:   0.000713
 Self time:   0.000713

count  total (s)   self (s)
   14              0.000082   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   14              0.000058   let bomb     = &l:bomb ? '[BOM]' : ''
   14              0.000252   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   14              0.000138   if expected is# &fenc.bomb.ff
                                return ''
                              else
   14              0.000106     return &fenc.bomb.ff
                              endif

FUNCTION  ale#Var()
Called 1818 times
Total time:   0.086193
 Self time:   0.086193

count  total (s)   self (s)
 1818              0.012448     let l:nr = str2nr(a:buffer)
 1818              0.012497     let l:full_name = 'ale_' . a:variable_name
                            
 1818              0.007316     if bufexists(l:nr)
 1818              0.011734         let l:vars = getbufvar(l:nr, '')
 1818              0.005793     elseif has_key(g:, 'ale_fix_buffer_data')
                                    let l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
                                else
                                    let l:vars = {}
                                endif
                            
 1818              0.013157     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>30_init_settings()
Called 2 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
   10              0.000028   for [key, value] in items(a:settings)
    8              0.000014     let sub = ''
    8              0.000021     if type(value) == 0
    4              0.000007       let sub = '%d'
    4              0.000008     elseif type(value) == 1
    4              0.000007       let sub = '"%s"'
    4              0.000004     endif
    8              0.000039     let fmt = printf("let g:multi_cursor_%%s=get(g:, 'multi_cursor_%%s', %s)", sub)
    8              0.000084     exec printf(fmt, key, key, value)
    8              0.000011   endfor

FUNCTION  gitgutter#utility#shellescape()
Called 12 times
Total time:   0.000312
 Self time:   0.000240

count  total (s)   self (s)
   12              0.000135   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    9              0.000022     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    3              0.000011     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>112_LocalBrowse()
Called 5 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    5              0.000024   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    5              0.000034   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    5              0.000006   endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  gitgutter#async#available()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000011   return s:available

FUNCTION  <SNR>130_check_in_path()
Called 1 time
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    1              0.000006   if !exists('b:airline_file_in_root')
    1              0.000009     let root = get(b:, 'git_dir', get(b:, 'mercurial_dir', ''))
    1              0.000024     let bufferpath = resolve(fnamemodify(expand('%'), ':p'))
                            
    1              0.000009     if !filereadable(root) "not a file
                                  " if .git is a directory, it's the old submodule format
    1              0.000015       if match(root, '\.git$') >= 0
    1              0.000018         let root = expand(fnamemodify(root, ':h'))
    1              0.000002       else
                                    " else it's the newer format, and we need to guesstimate
                                    " 1) check for worktrees
                                    if match(root, 'worktrees') > -1
                                      " worktree can be anywhere, so simply assume true here
                                      return 1
                                    endif
                                    " 2) check for submodules
                                    let pattern = '\.git[\\/]\(modules\)[\\/]'
                                    if match(root, pattern) >= 0
                                      let root = substitute(root, pattern, '', '')
                                    endif
                                  endif
    1              0.000001     endif
                            
    1              0.000010     let b:airline_file_in_root = stridx(bufferpath, root) > -1
    1              0.000002   endif
    1              0.000003   return b:airline_file_in_root

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 1 time
Total time:   0.000037
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000036   0.000010   return getbufvar(s:bufnr, 'changedtick') != gitgutter#utility#getbufvar(s:bufnr, 'last_tick')

FUNCTION  <SNR>160_RemoveProblemsForDisabledLinters()
Called 4 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
    4              0.000015     let l:name_map = {}
                            
    6              0.000015     for l:linter in a:linters
    2              0.000009         let l:name_map[l:linter.name] = 1
    2              0.000003     endfor
                            
    4              0.000052     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  airline#extensions#tabline#tabs#get()
Called 64 times
Total time:   0.116543
 Self time:   0.007303

count  total (s)   self (s)
   64              0.000417   let curbuf = bufnr('%')
   64              0.000253   let curtab = tabpagenr()
   64   0.001215   0.000543   call airline#extensions#tabline#tabs#map_keys()
   64              0.000320   if curbuf == s:current_bufnr && curtab == s:current_tabnr
   60              0.000560     if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
   52              0.000218       return s:current_tabline
                                endif
    8              0.000009   endif
                            
   12   0.001310   0.000096   let b = airline#extensions#tabline#new_builder()
                            
   36              0.000131   for i in range(1, tabpagenr('$'))
   24              0.000068     if i == curtab
   12              0.000033       let group = 'airline_tabsel'
   12              0.000030       if g:airline_detect_modified
   36              0.000096         for bi in tabpagebuflist(i)
   24              0.000113           if getbufvar(bi, '&modified')
    4              0.000010             let group = 'airline_tabmod'
    4              0.000005           endif
   24              0.000032         endfor
   12              0.000013       endif
   12              0.000083       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
   12              0.000016     else
   12              0.000032       let group = 'airline_tab'
   12              0.000014     endif
   24              0.000050     let val = '%('
   24              0.000049     if s:show_tab_nr
   24              0.000053       if s:tab_nr_type == 0
   24              0.000185         let val .= (g:airline_symbols.space).'%{len(tabpagebuflist('.i.'))}'
   24              0.000054       elseif s:tab_nr_type == 1
                                    let val .= (g:airline_symbols.space).i
                                  else "== 2
                                    let val .= (g:airline_symbols.space).i.'.%{len(tabpagebuflist('.i.'))}'
                                  endif
   24              0.000026     endif
   24   0.000588   0.000274     call b.add_section(group, val.'%'.i.'T %{airline#extensions#tabline#title('.i.')} %)')
   24              0.000045   endfor
                            
   12   0.000168   0.000079   call b.add_section('airline_tabfill', '')
   12   0.000151   0.000066   call b.split()
   12   0.000154   0.000072   call b.add_section('airline_tabfill', '')
                            
   12              0.000034   if s:show_close_button
   12   0.000179   0.000092     call b.add_section('airline_tab_right', ' %999X'.s:close_symbol.' ')
   12              0.000019   endif
                            
   12              0.000032   if s:show_splits == 1
   12              0.000066     let buffers = tabpagebuflist(curtab)
   36              0.000082     for nr in buffers
   24   0.001240   0.000259       let group = airline#extensions#tabline#group_of_bufnr(buffers, nr) . "_right"
   24   0.000803   0.000229       call b.add_section_spaced(group, '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)')
   24              0.000046     endfor
   12              0.000025   elseif s:show_tab_type == 1
                                call b.add_section_spaced('airline_tabtype', s:tabs_label)
                              endif
                            
   12              0.000078   let s:current_bufnr = curbuf
   12              0.000037   let s:current_tabnr = curtab
   12   0.105294   0.000153   let s:current_tabline = b.build()
   12              0.000040   return s:current_tabline

FUNCTION  WebDevIconsGetFileTypeSymbol()
Called 1989 times
Total time:   0.620259
 Self time:   0.620259

count  total (s)   self (s)
 1989              0.009575   let appendArtifactFix = 1
 1989              0.005105   if a:0 == 0
 1251              0.006838     let fileNodeExtension = expand('%:e')
 1251              0.005406     let fileNode = expand('%:t')
 1251              0.003647     let isDirectory = 0
 1251              0.001719   else
  738              0.004223     let fileNodeExtension = fnamemodify(a:1, ':e')
  738              0.003816     let fileNode = fnamemodify(a:1, ':t')
  738              0.001665     if a:0 > 1
                                  let isDirectory = a:2
                                else
  738              0.001908       let isDirectory = 0
  738              0.000973     endif
                            
  738              0.001320     if a:0 == 3
                                  let appendArtifactFix = a:3
                                endif
  738              0.000866   endif
                            
 1989              0.006879   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
 1989              0.008362     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
 1989              0.010389     let fileNodeExtension = tolower(fileNodeExtension)
 1989              0.008729     let fileNode = tolower(fileNode)
                            
17901              0.069466     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
15912              0.173591       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
                                  endif
15912              0.021029     endfor
                            
 1989              0.008989     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
 1989              0.010439       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
   30              0.000157         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
   30              0.000215       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
 1707              0.009698         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
 1707              0.006351       elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                                  endif
 1989              0.002316     endif
                            
 1989              0.002201   else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                              endif
                            
                              " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
                              " actual font patcher)
 1989              0.004698   if appendArtifactFix == 1
 1989              0.006814     let artifactFix = "\u00A0"
 1989              0.002644   else
                                let artifactFix = ""
                              endif
                            
 1989              0.006357   return symbol . artifactFix
                            

FUNCTION  <SNR>68_buffer_rev()
Called 1 time
Total time:   0.000114
 Self time:   0.000058

count  total (s)   self (s)
    1   0.000093   0.000038   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
    1              0.000009   if rev =~ '^\x/'
    1              0.000009     return ':'.rev[0].':'.rev[2:-1]
                              elseif rev =~ '.'
                                return s:sub(rev,'/',':')
                              elseif self.spec() =~ '\.git/index$'
                                return ':'
                              elseif self.spec() =~ '\.git/refs/\|\.git/.*HEAD$'
                                return self.spec()[strlen(self.repo().dir())+1 : -1]
                              else
                                return self.path('/')
                              endif

FUNCTION  expand_region#init()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000006   if exists('g:expand_region_init') && g:expand_region_init
    1              0.000001     return
                              endif
                              let g:expand_region_init = 1
                            
                              " Dictionary of text objects that are supported by default. Note that some of
                              " the text objects are not available in vanilla vim. '1' indicates that the
                              " text object is recursive (think of nested parens or brackets)
                              let g:expand_region_text_objects = get(g:, 'expand_region_text_objects', { 'iw'  :0, 'iW'  :0, 'i"'  :0, 'i''' :0, 'i]'  :1, 'ib'  :1, 'iB'  :1, 'il'  :0, 'ip'  :0, 'ie'  :0,})
                            
                              " Option to default to the select mode when selecting a new region
                              let g:expand_region_use_select_mode = get(g:, 'expand_region_use_select_mode', 0)

FUNCTION  184()
Called 1 time
Total time:   0.000624
 Self time:   0.000239

count  total (s)   self (s)
    1              0.000004     if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
    1   0.000318   0.000186     let winnr = bufwinnr('^' . self._path.str() . '$')
    1              0.000003     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
    1              0.000003     if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
    1   0.000264   0.000011     let tabnr = self._path.tabnr()
    1              0.000002     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec('normal! ' . tabnr . 'gt')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
    1              0.000001     return 0

FUNCTION  <SNR>141_Get()
Called 11004 times
Total time:   0.137435
 Self time:   0.137435

count  total (s)   self (s)
11004              0.067867   if get(a:dict, a:key, a:default) isnot# a:default
 6523              0.028826     return a:prefix. get(a:dict, a:key)
                              else
 4481              0.006561     return ''
                              endif

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 256 times
Total time:   0.029697
 Self time:   0.021489

count  total (s)   self (s)
  256              0.001948   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
  256              0.000679   let _ = ''
                            
  256              0.001187   let name = bufname(a:bufnr)
  256              0.000815   if empty(name)
                                let _ .= '[No Name]'
                              else
  256              0.000678     if s:fnamecollapse
  256              0.006276       let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
  256              0.000538     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
  256              0.001745     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
  256              0.000327   endif
                            
  256   0.010746   0.002537   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  airline#load_theme()
Called 1 time
Total time:   0.269513
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000009   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
    1              0.000005   let palette = g:airline#themes#{g:airline_theme}#palette
    1   0.000210   0.000012   call airline#themes#patch(palette)
                            
    1              0.000004   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    1   0.238039   0.000013   call airline#highlighter#load_theme()
    1   0.007962   0.000019   call airline#extensions#load_theme()
    1   0.023272   0.000009   call airline#update_statusline()

FUNCTION  <SNR>3_source()
Called 65 times
Total time:   0.021709
 Self time:   0.005938

count  total (s)   self (s)
   65              0.000229   let found = 0
  195              0.000384   for pattern in a:000
  181   0.010893   0.000914     for vim in s:glob(a:from, pattern)
   51   0.008172   0.002380       execute 'source' s:esc(vim)
   51              0.000173       let found = 1
   51              0.000077     endfor
  130              0.000143   endfor
   65              0.000117   return found

FUNCTION  airline#parts#paste()
Called 1247 times
Total time:   0.008530
 Self time:   0.008530

count  total (s)   self (s)
 1247              0.007278   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>81_Detect()
Called 2 times
Total time:   0.001046
 Self time:   0.000122

count  total (s)   self (s)
    2              0.000010   if !exists('b:bundler_lock')
    2   0.000949   0.000025     let lock = s:FindBundlerLock(a:path)
    2              0.000007     if !empty(lock)
                                  let b:bundler_lock = lock
                                  unlet! b:bundler_gem
                                elseif !empty(getbufvar('#', 'bundler_lock'))
                                  let lock = getbufvar('#', 'bundler_lock')
                                  for [gem, path] in items(s:project(lock).paths())
                                    if strpart(a:path, 0, len(path)) ==# path
                                      let b:bundler_lock = lock
                                      let b:bundler_gem = gem
                                      break
                                    endif
                                  endfor
                                endif
    2              0.000003   endif
    2              0.000008   return exists('b:bundler_lock')

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 1 time
Total time:   0.113908
 Self time:   0.000027

count  total (s)   self (s)
    1   0.113905   0.000024     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  <SNR>41_savetofile()
Called 1 time
Total time:   0.000796
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000795   0.000020 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  airline#update_statusline()
Called 14 times
Total time:   0.203227
 Self time:   0.001931

count  total (s)   self (s)
   14   0.000225   0.000121   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   27              0.000206   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
   13   0.000189   0.000093     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
   13              0.000071     call setwinvar(nr, 'airline_active', 0)
   13              0.000097     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   13   0.070780   0.000185     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   13              0.000021   endfor
                            
   14              0.000060   unlet! w:airline_render_left w:airline_render_right
   14              0.000299   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
   14              0.000047   let w:airline_active = 1
   14              0.000106   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   14   0.130702   0.000201   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  UltiSnips#TrackChange()
Called 43 times
Total time:   0.156382
 Self time:   0.156382

count  total (s)   self (s)
   43              0.156331     exec g:_uspy "UltiSnips_Manager._track_change()"

FUNCTION  gitgutter#utility#restore_shell()
Called 23 times
Total time:   0.000677
 Self time:   0.000677

count  total (s)   self (s)
   23              0.000093   if has('unix')
   23              0.000085     if exists('s:shell')
   23              0.000151       let &shell = s:shell
   23              0.000116       let &shellcmdflag = s:shellcmdflag
   23              0.000104       let &shellredir = s:shellredir
   23              0.000032     endif
   23              0.000026   endif

FUNCTION  GetVimIndentIntern()
Called 5 times
Total time:   0.001373
 Self time:   0.001373

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    5              0.000052   let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
    5              0.000033   let cur_text = getline(v:lnum)
    5              0.000095   if cur_text !~ '^\s*\\'
    5              0.000065     while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
    5              0.000008   endif
                            
                              " At the start of the file use zero indent.
    5              0.000013   if lnum == 0
                                return 0
                              endif
    5              0.000026   let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
    5              0.000025   let ind = indent(lnum)
    5              0.000045   if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
    5              0.000049     if prev_text !~ '^\s*au\%[tocmd]'
    3              0.000152       let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
    3              0.000012       if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
    3              0.000004     endif
    5              0.000007   endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
    5              0.000120   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
    5              0.000022   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
    5              0.000108   if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
    5              0.000015   return ind

FUNCTION  <SNR>132_check_mixed_indent_file()
Called 6 times
Total time:   0.001713
 Self time:   0.001713

count  total (s)   self (s)
    6              0.000058   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    6              0.000070   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    6              0.000016     let head_spc = '\v(^ +)'
    6              0.000009   endif
    6              0.001193   let indent_tabs = search('\v(^\t+)', 'nw')
    6              0.000245   let indent_spc  = search(head_spc, 'nw')
    6              0.000024   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    6              0.000009     return ''
                              endif

FUNCTION  airline#extensions#ale#get_error()
Called 1247 times
Total time:   0.159150
 Self time:   0.011646

count  total (s)   self (s)
 1247   0.158110   0.010606   return airline#extensions#ale#get('error')

FUNCTION  ale#events#SaveEvent()
Called 2 times
Total time:   0.006616
 Self time:   0.000089

count  total (s)   self (s)
    2              0.000020     call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    2   0.000103   0.000020     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    2              0.000005     if g:ale_fix_on_save
                                    let l:will_fix = ale#fix#Fix('save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
    2              0.000003     if l:should_lint
    2   0.006464   0.000020         call ale#Queue(0, 'lint_file', a:buffer)
    2              0.000002     endif

FUNCTION  airline#parts#readonly()
Called 1308 times
Total time:   0.019439
 Self time:   0.019439

count  total (s)   self (s)
 1308              0.008975   if &readonly && &modifiable && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
 1308              0.004425     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>186_SetListsImpl()
Called 2 times
Total time:   0.001104
 Self time:   0.000495

count  total (s)   self (s)
    2              0.000062     let l:title = expand('#' . a:buffer . ':p')
                            
    2              0.000009     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but is better than nothing.
    2   0.000057   0.000029         let l:win_id = s:BufWinId(a:buffer)
                            
    2              0.000023         if has('nvim')
    2   0.000124   0.000043             call setloclist(l:win_id, s:FixList(a:loclist), ' ', l:title)
    2              0.000004         else
                                        call setloclist(l:win_id, s:FixList(a:loclist))
                                        call setloclist(l:win_id, [], 'r', {'title': l:title})
                                    endif
    2              0.000003     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    2   0.000213   0.000028     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            execute 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        execute 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    2   0.000058   0.000020     if !ale#engine#IsCheckingBuffer(bufnr(''))
    2   0.000318   0.000042         call s:CloseWindowIfNeeded(a:buffer)
    2              0.000003     endif

FUNCTION  <SNR>3_assoc()
Called 12 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   12              0.000085   let a:dict[a:key] = add(get(a:dict, a:key, []), a:val)

FUNCTION  <SNR>74_setSyntax()
Called 1 time
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
    1              0.000008   if g:webdevicons_enable_nerdtree == 1 && g:webdevicons_conceal_nerdtree_brackets == 1
    1              0.000004     augroup webdevicons_conceal_nerdtree_brackets
    1              0.000168       au!
    1              0.000013       autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\]" contained conceal containedin=ALL
    1              0.000008       autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\[" contained conceal containedin=ALL
    1              0.000005       autocmd FileType nerdtree setlocal conceallevel=3
    1              0.000005       autocmd FileType nerdtree setlocal concealcursor=nvic
    1              0.000002     augroup END
    1              0.000002   endif

FUNCTION  ctrlp#utils#writecache()
Called 1 time
Total time:   0.000775
 Self time:   0.000750

count  total (s)   self (s)
    1   0.000044   0.000019 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.000725 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000003 	en

FUNCTION  ale#engine#RunLinters()
Called 4 times
Total time:   0.007979
 Self time:   0.000438

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    4   0.000131   0.000046     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
    4   0.000348   0.000047     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
    4   0.000177   0.000050     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    4   0.000109   0.000046     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    6              0.000017     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
    2              0.000006         if !l:linter.lint_file || a:should_lint_file
    2   0.000382   0.000016             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
                                        endif
    2              0.000002         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
    2              0.000002     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    4              0.000011     if l:can_clear_results
    4   0.006640   0.000040         call ale#engine#SetResults(a:buffer, [])
    4              0.000010     elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  gitgutter#utility#setbufvar()
Called 46 times
Total time:   0.001084
 Self time:   0.001084

count  total (s)   self (s)
   46              0.000429   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   46              0.000292   let dict[a:varname] = a:val
   46              0.000288   call setbufvar(a:buffer, 'gitgutter', dict)

FUNCTION  nerdtree#has_opt()
Called 3726 times
Total time:   0.026438
 Self time:   0.026438

count  total (s)   self (s)
 3726              0.023203     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  <SNR>3_lines()
Called 130 times
Total time:   0.001330
 Self time:   0.001330

count  total (s)   self (s)
  130              0.001209   return split(a:msg, "[\r\n]")

FUNCTION  <SNR>130_reset_untracked_cache()
Called 2 times
Total time:   0.000281
 Self time:   0.000191

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    2              0.000020   if !s:has_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
                              endif
                            
    2              0.000041   let l:file = expand("%:p")
    6              0.000017   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    4   0.000124   0.000034     call s:update_untracked_in_buffer_config(l:file, l:vcs)
    4              0.000022     let s:vcs_config[vcs].untracked = {}
    4              0.000007   endfor

FUNCTION  <SNR>68_buffer_commit()
Called 1 time
Total time:   0.000098
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000097   0.000035   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  airline#highlighter#exec()
Called 3615 times
Total time:   1.485827
 Self time:   0.432307

count  total (s)   self (s)
 3615              0.012073   if pumvisible()
                                return
                              endif
 3615              0.011387   let colors = a:colors
 3615              0.008685   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 3615   0.698720   0.030487   let old_hi = airline#highlighter#get_highlight(a:group)
 3615              0.015060   if len(colors) == 4
  915              0.003824     call add(colors, '')
  915              0.001354   endif
 3615              0.009995   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
 3615              0.038862     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
 3615              0.006339   endif
 3615   0.220478   0.028275   let colors = s:CheckDefined(colors)
 3615   0.086734   0.031086   if old_hi != new_hi || !s:hl_group_exists(a:group)
 1572   0.208149   0.070713     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg=', ''), s:Get(colors, 1, 'guibg=', ''), s:Get(colors, 2, 'ctermfg=', ''), s:Get(colors, 3, 'ctermbg=', ''), s:Get(colors, 4, 'gui=', ''), s:Get(colors, 4, 'cterm=', ''), s:Get(colors, 4, 'term=', ''))
 1572              0.026725     exe cmd
 1572              0.002426   endif

FUNCTION  ale#linter#Get()
Called 4 times
Total time:   0.001360
 Self time:   0.000686

count  total (s)   self (s)
    4              0.000018     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-seperated filetypes.
    8              0.000045     for l:original_filetype in split(a:original_filetypes, '\.')
    4   0.000313   0.000041         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    4   0.000221   0.000038         let l:linter_names = s:GetLinterNames(l:original_filetype)
    4   0.000253   0.000033         let l:all_linters = ale#linter#GetAll(l:filetype)
    4              0.000013         let l:filetype_linters = []
                            
    4              0.000022         if type(l:linter_names) == type('') && l:linter_names is# 'all'
    4              0.000016             let l:filetype_linters = l:all_linters
    4              0.000011         elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
    4              0.000018         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    4              0.000006     endfor
                            
    4              0.000010     let l:name_list = []
    4              0.000010     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
    8              0.000023     for l:linter in reverse(l:possibly_duplicated_linters)
    4              0.000018         if index(l:name_list, l:linter.name) < 0
    4              0.000018             call add(l:name_list, l:linter.name)
    4              0.000015             call add(l:combined_linters, l:linter)
    4              0.000004         endif
    4              0.000004     endfor
                            
    4              0.000013     return reverse(l:combined_linters)

FUNCTION  <SNR>61_NERDTreeGetFileGitStatusKey()
Called 30 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
   30              0.000167     if a:us ==# '?' && a:them ==# '?'
   15              0.000031         return 'Untracked'
                                elseif a:us ==# ' ' && a:them ==# 'M'
    9              0.000017         return 'Modified'
                                elseif a:us =~# '[MAC]'
    6              0.000014         return 'Staged'
                                elseif a:us ==# 'R'
                                    return 'Renamed'
                                elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
                                    return 'Unmerged'
                                elseif a:them ==# 'D'
                                    return 'Deleted'
                                elseif a:us ==# '!'
                                    return 'Ignored'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  airline#themes#get_highlight()
Called 1830 times
Total time:   0.412912
 Self time:   0.020452

count  total (s)   self (s)
 1830   0.411514   0.019054   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#extensions#whitespace#check()
Called 1247 times
Total time:   0.283190
 Self time:   0.225023

count  total (s)   self (s)
 1247              0.009753   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
 1247              0.012850   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
 1247              0.006112   if !exists('b:airline_whitespace_check')
    6              0.000026     let b:airline_whitespace_check = ''
    6              0.000058     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    6              0.000015     let trailing = 0
    6              0.000028     if index(checks, 'trailing') > -1
    6              0.000016       try
    6              0.000032         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    6              0.017024         let trailing = search(regexp, 'nw')
    6              0.000021       catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    6              0.000008     endif
                            
    6              0.000017     let mixed = 0
    6              0.000015     let check = 'indent'
    6              0.000117     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    6   0.025039   0.000081       let mixed = s:check_mixed_indent()
    6              0.000020     endif
                            
    6              0.000020     let mixed_file = ''
    6              0.000017     let check = 'mixed-indent-file'
    6              0.000110     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    6   0.001792   0.000079       let mixed_file = s:check_mixed_indent_file()
    6              0.000010     endif
                            
    6              0.000015     let long = 0
    6              0.000029     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    6              0.000034     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    6              0.000008   endif
 1247   0.042441   0.010945   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  NERDTreeGitStatusRefresh()
Called 15 times
Total time:   6.192886
 Self time:   6.184577

count  total (s)   self (s)
   15              0.000126     let b:NERDTreeCachedGitFileStatus = {}
   15              0.000070     let b:NERDTreeCachedGitDirtyDir   = {}
   15              0.000053     let b:NOT_A_GIT_REPOSITORY        = 1
                            
   15   0.003110   0.000161     let l:root = b:NERDTree.root.path.str()
   15              0.000059     let l:gitcmd = 'git -c color.status=false status -s'
   15              0.000042     if g:NERDTreeShowIgnoredStatus
                                    let l:gitcmd = l:gitcmd . ' --ignored'
                                endif
   15              0.000076     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
                                endif
   15              6.176682     let l:statusesStr = system(l:gitcmd . ' ' . l:root)
   15              0.000729     let l:statusesSplit = split(l:statusesStr, '\n')
   15              0.000395     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
                                endif
   15              0.000070     let b:NOT_A_GIT_REPOSITORY = 0
                            
   45              0.000205     for l:statusLine in l:statusesSplit
                                    " cache git status of files
   30              0.000585         let l:pathStr = substitute(l:statusLine, '...', '', '')
   30              0.000305         let l:pathSplit = split(l:pathStr, ' -> ')
   30              0.000151         if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
                                    else
   30              0.000176             let l:pathStr = l:pathSplit[0]
   30              0.000045         endif
   30   0.001284   0.000523         let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
   30              0.000287         if l:pathStr =~# '\.\./.*'
                                        continue
                                    endif
   30   0.000870   0.000448         let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
   30              0.000421         let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
   30              0.000109         if l:statusKey == 'Ignored'
                                        if isdirectory(l:pathStr)
                                            let b:NERDTreeCachedGitDirtyDir[fnameescape(l:pathStr)] = l:statusKey
                                        endif
                                    else
   30   0.004467   0.000290             call s:NERDTreeCacheDirtyDir(l:pathStr)
   30              0.000043         endif
   30              0.000037     endfor

FUNCTION  <SNR>41_chop()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000016 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000003 	retu a:mrufs

FUNCTION  nerdtree#exec()
Called 46 times
Total time:   0.101234
 Self time:   0.018901

count  total (s)   self (s)
   46              0.000719     let old_ei = &ei
   46   0.000849   0.000843     set ei=BufEnter,BufLeave,VimEnter
   46   0.098893   0.016574     exec a:cmd
   46   0.000652   0.000643     let &ei = old_ei

FUNCTION  <SNR>61_NERDTreeTrimDoubleQuotes()
Called 60 times
Total time:   0.001455
 Self time:   0.001455

count  total (s)   self (s)
   60              0.000649     let l:toReturn = substitute(a:pathStr, '^"', '', '')
   60              0.000489     let l:toReturn = substitute(l:toReturn, '"$', '', '')
   60              0.000182     return l:toReturn

FUNCTION  ale#engine#Cleanup()
Called 8 times
Total time:   0.004379
 Self time:   0.000142

count  total (s)   self (s)
    8              0.000057     if !has_key(g:ale_buffer_info, a:buffer)
    6              0.000011         return
                                endif
                            
    2   0.004259   0.000022     call ale#engine#RunLinters(a:buffer, [], 1)
                            
    2              0.000026     call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>149_reset_summary()
Called 23 times
Total time:   0.000866
 Self time:   0.000300

count  total (s)   self (s)
   23   0.000843   0.000277   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'summary', [0,0,0])

FUNCTION  <SNR>144_system_job_handler()
Called 3 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
    3              0.000072     if a:event == 'stdout'
    3              0.000058       let self.buf .=  join(a:data)
    3              0.000011     endif

FUNCTION  ale#util#StartPartialTimer()
Called 4 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    4              0.000057     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    4              0.000034     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    4              0.000011     return l:timer_id

FUNCTION  <SNR>141_hl_group_exists()
Called 2043 times
Total time:   0.055648
 Self time:   0.055648

count  total (s)   self (s)
 2043              0.017924   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
 2043              0.002908   return 1

FUNCTION  airline#builder#new()
Called 39 times
Total time:   0.001400
 Self time:   0.001400

count  total (s)   self (s)
   39              0.000340   let builder = copy(s:prototype)
   39              0.000152   let builder._context = a:context
   39              0.000116   let builder._sections = []
                            
   39              0.000581   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   39              0.000090   return builder

FUNCTION  <SNR>18_LoadFTPlugin()
Called 2 times
Total time:   0.007415
 Self time:   0.006678

count  total (s)   self (s)
    2              0.000010     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    2              0.000010     let s = expand("<amatch>")
    2              0.000005     if s != ""
    2              0.000029       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000020       for name in split(s, '\.')
    2   0.007291   0.006554 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000006       endfor
    2              0.000003     endif

FUNCTION  <SNR>172_job_started()
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000010   if a:0  " vim
                                let s:jobs[a:id] = {'output': [], 'buffer': a:1}
                              else    " nvim
    3              0.000016     let s:jobs[a:id] = 1
    3              0.000004   endif

FUNCTION  <SNR>68_buffer()
Called 4 times
Total time:   0.000222
 Self time:   0.000185

count  total (s)   self (s)
    4              0.000040   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    4              0.000071   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    4   0.000086   0.000049   if buffer.getvar('git_dir') !=# ''
    4              0.000012     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>131_airline_ale_count()
Called 2494 times
Total time:   0.012466
 Self time:   0.012466

count  total (s)   self (s)
 2494              0.010142   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  plug#()
Called 67 times
Total time:   0.010191
 Self time:   0.004385

count  total (s)   self (s)
   67              0.000164   if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
                              endif
                            
   67              0.000106   try
   67   0.001172   0.000398     let repo = s:trim(a:repo)
   67   0.000698   0.000426     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
   67              0.000626     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
   67   0.005393   0.000632     let spec = extend(s:infer_properties(name, repo), opts)
   67              0.000255     if !has_key(g:plugs, name)
   67              0.000255       call add(g:plugs_order, name)
   67              0.000080     endif
   67              0.000239     let g:plugs[name] = spec
   67              0.000357     let s:loaded[name] = get(s:loaded, name, 0)
   67              0.000085   catch
                                return s:err(v:exception)
                              endtry

FUNCTION  <SNR>146_get_section()
Called 169 times
Total time:   0.009305
 Self time:   0.008313

count  total (s)   self (s)
  169              0.000843   if has_key(s:section_truncate_width, a:key)
   95              0.000473     if winwidth(a:winnr) < s:section_truncate_width[a:key]
   17              0.000027       return ''
                                endif
   78              0.000085   endif
  152              0.000524   let spc = g:airline_symbols.space
  152              0.000905   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
  152   0.002643   0.001650   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  152              0.001407   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  152              0.000937   return empty(text) ? '' : prefix.text.suffix

FUNCTION  ctrlp#mrufiles#cachefile()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000009 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
    1              0.000003 	retu s:cafile

FUNCTION  120()
Called 5094 times
Total time:   0.019251
 Self time:   0.019251

count  total (s)   self (s)
 5094              0.015107     return self._nerdtree

FUNCTION  gitgutter#utility#not_git_dir()
Called 4 times
Total time:   0.000186
 Self time:   0.000103

count  total (s)   self (s)
    4   0.000182   0.000098   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 4 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    4              0.000079   return fnamemodify(s:file, ':p:h')

FUNCTION  <SNR>141_get_array()
Called 5713 times
Total time:   0.066543
 Self time:   0.066543

count  total (s)   self (s)
 5713              0.060883   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', join(a:opts, ',') ] : [ '', '', a:fg, a:bg, join(a:opts, ',') ]

FUNCTION  <SNR>158_change_tick_stop()
Called 12 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
   12              0.000053 	if s:change_timer==-1
                            		return
                            	endif
   12              0.000077 	call timer_stop(s:change_timer)
   12              0.000060 	let s:lasttick = []
   12              0.000043 	let s:change_timer = -1

FUNCTION  nerdtree#renderView()
Called 32 times
Total time:   1.049954
 Self time:   0.000320

count  total (s)   self (s)
   32   1.049920   0.000286     call b:NERDTree.render()

FUNCTION  <SNR>3_path()
Called 1 time
Total time:   0.000041
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000040   0.000012     return s:trim(a:path)

FUNCTION  <SNR>69_on_window_changed()
Called 22 times
Total time:   0.181440
 Self time:   0.001399

count  total (s)   self (s)
   22              0.000112   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   22              0.000363   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
   22              0.000441   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    9              0.000020     return
                              endif
   13              0.000065   let g:airline_last_window_changed = l:key
   13   0.000167   0.000091   call s:init()
   13   0.180053   0.000089   call airline#update_statusline()

FUNCTION  <SNR>155_EchoImpl()
Called 437 times
Total time:   0.127773
 Self time:   0.025098

count  total (s)   self (s)
  437   0.079677   0.004290     if ale#ShouldDoNothing(bufnr(''))
    2              0.000004         return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  435              0.001596     if mode() isnot# 'n'
   19              0.000025         return
                                endif
                            
  416   0.031852   0.004565     let [l:info, l:loc] = s:FindItemAtCursor()
                            
  416              0.001403     if !empty(l:loc)
                                    let l:msg = s:GetMessage(l:loc.linter_name, l:loc.type, l:loc.text)
                                    call ale#cursor#TruncatedEcho(l:msg)
                                    let l:info.echoed = 1
                                elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    echo
                                    let l:info.echoed = 0
                                endif

FUNCTION  <SNR>160_StopCurrentJobs()
Called 4 times
Total time:   0.000301
 Self time:   0.000301

count  total (s)   self (s)
    4              0.000034     let l:info = get(g:ale_buffer_info, a:buffer, {})
    4              0.000015     let l:new_job_list = []
    4              0.000014     let l:new_active_linter_list = []
                            
    4              0.000024     for l:job_id in get(l:info, 'job_list', [])
                                    let l:job_info = get(s:job_info_map, l:job_id, {})
                            
                                    if !empty(l:job_info)
                                        if a:include_lint_file_jobs || !l:job_info.linter.lint_file
                                            call ale#job#Stop(l:job_id)
                                            call remove(s:job_info_map, l:job_id)
                                        else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
                                    endif
                                endfor
                            
                                " Remove duplicates from the active linter list.
    4              0.000023     call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
    4              0.000029     let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
    4              0.000019     let l:info.active_linter_list = l:new_active_linter_list

FUNCTION  ale#statusline#Update()
Called 4 times
Total time:   0.000478
 Self time:   0.000371

count  total (s)   self (s)
    4              0.000034     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
    4              0.000032     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    4   0.000139   0.000032     let l:count = s:CreateCountDict()
    4              0.000021     let l:count.total = len(l:loclist)
                            
    4              0.000013     for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
                                            let l:count.warning += 1
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
                                        let l:count.error += 1
                                    endif
                                endfor
                            
                                " Set keys for backwards compatibility.
    4              0.000027     let l:count[0] = l:count.error + l:count.style_error
    4              0.000024     let l:count[1] = l:count.total - l:count[0]
                            
    4              0.000040     let g:ale_buffer_info[a:buffer].count = l:count

FUNCTION  airline#parts#spell()
Called 1247 times
Total time:   0.054754
 Self time:   0.054754

count  total (s)   self (s)
 1247              0.022267   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
 1247              0.005977   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
 1247              0.001894   return ''

FUNCTION  ale#Lint()
Called 2 times
Total time:   0.004959
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000005     if a:0 > 1
                                    " Use the buffer number given as the optional second argument.
    2              0.000005         let l:buffer = a:2
    2              0.000004     elseif a:0 > 0 && a:1 == s:lint_timer
                                    " Use the buffer number for the buffer linting was queued for.
                                    let l:buffer = s:queued_buffer_number
                                else
                                    " Use the current buffer number.
                                    let l:buffer = bufnr('')
                                endif
                            
    2   0.004926   0.000023     return ale#CallWithCooldown(   'dont_lint_until',   function('s:ALELintImpl'),   [l:buffer],)

FUNCTION  gitgutter#hunk#summary()
Called 1246 times
Total time:   0.043416
 Self time:   0.016788

count  total (s)   self (s)
 1246   0.041921   0.015293   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>158_start_core_channel()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000010 	if s:channel_started
    3              0.000005 		return
                            	endif
                            	let s:channel_started = 1
                            
                            	let g:_cm_py3 = get(g:,'python3_host_prog','')
                                if g:_cm_py3 == '' && has('python3')
                                    " heavy weight
                                    " but better support for python detection
                                    python3 import sys
                                    let g:_cm_py3 = py3eval('sys.executable')
                                endif
                                if g:_cm_py3 == ''
                                    let g:_cm_py3 = 'python3'
                                endif
                            
                            	let s:channel_jobid = call(s:jobstart,[[g:_cm_py3, g:_cm_start_py_path, 'core', g:_cm_servername], { 'on_exit' : function('s:on_core_channel_exit'), 'on_stderr' : function('s:on_core_channel_error'), 'detach'  : 1, }])

FUNCTION  cm#register_source()
Called 4 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                            
    4              0.000029 	let l:name = a:info['name']
                            
                            	" if registered before, ignore this call
    4              0.000020 	if has_key(g:_cm_sources,l:name)
    4              0.000006 		return
                            	endif
                            
                            	if has_key(g:cm_sources_override,l:name)
                            		" override source default options
                            		call extend(a:info,g:cm_sources_override[l:name])
                            	endif
                            
                            	let a:info['enable'] = get(a:info,'enable',g:cm_sources_enable)
                            
                                " the name cm_refresh_min_word_len is deprecated, it will be removed
                                " in the future
                                if has_key(a:info, 'cm_refresh_min_word_len')
                                    let a:info['cm_refresh_length'] = a:info['cm_refresh_min_word_len']
                                endif
                            
                            	if !has_key(a:info,'cm_refresh_length')
                            		if type(g:cm_refresh_length)==type(1)
                            			let a:info['cm_refresh_length'] = g:cm_refresh_length
                            		else
                            			" format: [ [ minimal priority, min length ], []]
                            			"
                            			" Configure by min priority level. Use the max priority setting
                            			" available
                            			let l:max = -1
                            			for l:e in g:cm_refresh_length
                            				if (a:info['priority'] >= l:e[0]) && (l:e[0] > l:max)
                            					let a:info['cm_refresh_length'] = l:e[1]
                            					let l:max = l:e[0]
                            				endif
                            			endfor
                            		endif
                            	endif
                            
                            	" wether or not use the framework's standard sorting
                            	let a:info['sort'] = get(a:info,'sort',1)
                            
                            	" similar to g:cm_auto_popup
                            	let a:info['auto_popup'] = get(a:info,'auto_popup',1)
                            
                            	let a:info['early_cache'] = get(a:info,'early_cache', 0)
                            
                            	let g:_cm_sources[l:name] = a:info
                            
                            	call s:notify_core_channel('cm_start_channels',g:_cm_sources,cm#context())
                            

FUNCTION  <SNR>3_loaded_names()
Called 3 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
    3              0.000428   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

FUNCTION  airline#extensions#tabline#load_theme()
Called 1 time
Total time:   0.005278
 Self time:   0.000210

count  total (s)   self (s)
    1              0.000003   if pumvisible()
                                return
                              endif
    1              0.000005   let colors    = get(a:palette, 'tabline', {})
                              " Theme for tabs on the left
    1              0.000006   let l:tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    1              0.000005   let l:tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    1              0.000005   let l:tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    1              0.000004   let l:tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    1              0.000004   let l:tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    1              0.000004   let l:tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    1              0.000005   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
    1              0.000005     let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
    1              0.000001   endif
    1   0.000419   0.000008   call airline#highlighter#exec('airline_tab', l:tab)
    1   0.000420   0.000009   call airline#highlighter#exec('airline_tabsel', l:tabsel)
    1   0.000411   0.000009   call airline#highlighter#exec('airline_tabtype', l:tabtype)
    1   0.000445   0.000009   call airline#highlighter#exec('airline_tabfill', l:tabfill)
    1   0.000415   0.000009   call airline#highlighter#exec('airline_tabmod', l:tabmod)
    1   0.000412   0.000009   call airline#highlighter#exec('airline_tabmod_unsel', l:tabmodu)
    1   0.000412   0.000008   call airline#highlighter#exec('airline_tabhid', l:tabhid)
                            
                              " Theme for tabs on the right
    1              0.000006   let l:tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    1              0.000006   let l:tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    1              0.000005   let l:tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    1              0.000005   let l:tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    1              0.000005   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
                                let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
                              else
                                "Fall back to normal airline_c if modified airline_c isn't present
    1              0.000005     let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
    1              0.000001   endif
    1   0.000413   0.000008   call airline#highlighter#exec('airline_tab_right',    l:tab_right)
    1   0.000414   0.000009   call airline#highlighter#exec('airline_tabsel_right', l:tabsel_right)
    1   0.000413   0.000009   call airline#highlighter#exec('airline_tabmod_right', l:tabmod_right)
    1   0.000416   0.000009   call airline#highlighter#exec('airline_tabhid_right', l:tabhid_right)
    1   0.000585   0.000010   call airline#highlighter#exec('airline_tabmod_unsel_right', l:tabmodu_right)

FUNCTION  <SNR>130_update_untracked()
Called 1247 times
Total time:   2.193437
 Self time:   0.173746

count  total (s)   self (s)
 1247              0.019489   let l:file = expand("%:p")
 1247              0.010930   if empty(l:file) || isdirectory(l:file)
                                return
                              endif
                            
 1247              0.004468   let l:needs_update = 1
 3741              0.012085   for vcs in keys(s:vcs_config)
 2494              0.022234     if l:file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
  412              0.001476       let l:needs_update = 0
  412              0.000554     endif
 2494              0.015587     if has_key(s:vcs_config[vcs].untracked, l:file)
 1664              0.005350       let l:needs_update = 0
 1664   0.058930   0.016930       call s:update_untracked_in_buffer_config(l:file, vcs)
 1664              0.002178     endif
 2494              0.003406   endfor
                            
 1247              0.003445   if !l:needs_update
 1244              0.002148     return
                              endif
                            
    9              0.000047   for vcs in keys(s:vcs_config)
    6              0.000034     let l:config = s:vcs_config[vcs]
    6              0.000015     if s:has_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  call s:get_vcs_untracked_async(l:config, l:file)
                                else
    6   1.977651   0.000186       let output = airline#util#system(l:config.cmd . shellescape(l:file))
    6              0.000201       if output =~? ('^' . l:config.untracked_mark)
    3              0.000051         let l:config.untracked[l:file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    3              0.000006       else
    3              0.000023         let l:config.untracked[l:file] = ''
    3              0.000005       endif
    6   0.000355   0.000128       call s:update_untracked_in_buffer_config(l:file, vcs)
    6              0.000008     endif
    6              0.000020   endfor

FUNCTION  <SNR>41_record()
Called 17 times
Total time:   0.004167
 Self time:   0.001101

count  total (s)   self (s)
   17              0.000134 	if s:locked | retu | en
   17              0.000091 	let bufnr = a:bufnr + 0
   17              0.000107 	let bufname = bufname(bufnr)
   17              0.000091 	if bufnr > 0 && !empty(bufname)
   17              0.000282 		cal filter(s:mrbs, 'v:val != bufnr')
   17              0.000092 		cal insert(s:mrbs, bufnr)
   17   0.003268   0.000202 		cal s:addtomrufs(bufname)
   17              0.000026 	en

FUNCTION  <SNR>134_wordcount_update()
Called 496 times
Total time:   0.047212
 Self time:   0.047212

count  total (s)   self (s)
  496              0.002570   if empty(bufname(''))
                                return
                              endif
  496              0.020210   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  <SNR>141_CheckDefined()
Called 3615 times
Total time:   0.192203
 Self time:   0.192203

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 3615              0.020816   if !exists("g:airline#highlighter#normal_fg_hi")
    1              0.000016     let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
    1              0.000001   endif
 3615              0.020374   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
 8672              0.022916   for val in a:colors
 8575              0.031551     if !empty(val) && val !=# 'NONE'
 3518              0.007471       return a:colors
                                endif
 5057              0.006839   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
   97              0.000408   let fg = g:airline#highlighter#normal_fg_hi
   97              0.001917   let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
   97              0.000269   if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
   97              0.001104   return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>3_rtp()
Called 185 times
Total time:   0.004294
 Self time:   0.001495

count  total (s)   self (s)
  185   0.004191   0.001392     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))

FUNCTION  <SNR>3_escrtp()
Called 64 times
Total time:   0.000375
 Self time:   0.000375

count  total (s)   self (s)
   64              0.000330   return escape(a:path, ' ,')

FUNCTION  <SNR>145_should_change_group()
Called 144 times
Total time:   0.059557
 Self time:   0.005406

count  total (s)   self (s)
  144              0.000544   if a:group1 == a:group2
   10              0.000015     return 0
                              endif
  134   0.028803   0.001104   let color1 = airline#highlighter#get_highlight(a:group1)
  134   0.027577   0.001125   let color2 = airline#highlighter#get_highlight(a:group2)
  134              0.000467   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
  134              0.000852     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#extensions#quickfix#apply()
Called 14 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
   14              0.000057   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  203()
Called 1 time
Total time:   0.023571
 Self time:   0.000100

count  total (s)   self (s)
                                "throwaway buffer options
    1   0.000007   0.000006     setlocal noswapfile
    1   0.000032   0.000005     setlocal buftype=nofile
    1   0.000006   0.000004     setlocal bufhidden=hide
    1   0.000006   0.000005     setlocal nowrap
    1   0.000007   0.000006     setlocal foldcolumn=0
    1   0.000004   0.000004     setlocal foldmethod=manual
    1   0.000005   0.000004     setlocal nofoldenable
    1   0.000005   0.000004     setlocal nobuflisted
    1   0.000005   0.000005     setlocal nospell
    1              0.000003     if g:NERDTreeShowLineNumbers
                                    setlocal nu
                                else
    1   0.000007   0.000006         setlocal nonu
    1              0.000003         if v:version >= 703
    1   0.000007   0.000006             setlocal nornu
    1              0.000001         endif
    1              0.000001     endif
                            
    1              0.000002     iabc <buffer>
                            
    1              0.000002     if g:NERDTreeHighlightCursorline
                                    setlocal cursorline
                                endif
                            
    1   0.000020   0.000007     call self._setupStatusline()
    1   0.003379   0.000008     call self._bindMappings()
    1   0.020057   0.000006     setlocal filetype=nerdtree

FUNCTION  204()
Called 1 time
Total time:   0.000013
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003     if g:NERDTreeStatusline != -1
    1   0.000007   0.000006         let &l:statusline = g:NERDTreeStatusline
    1              0.000001     endif

FUNCTION  206()
Called 2 times
Total time:   0.078459
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000069   0.000020     let creator = s:Creator.New()
    2   0.078387   0.000019     call creator.toggleTabTree(a:dir)

FUNCTION  207()
Called 2 times
Total time:   0.078368
 Self time:   0.000112

count  total (s)   self (s)
    2   0.000158   0.000019     if g:NERDTree.ExistsForTab()
    2   0.000183   0.000015         if !g:NERDTree.IsOpen()
    1   0.048210   0.000010             call self._createTreeWin()
    1              0.000003             if !&hidden
                                            call b:NERDTree.render()
                                        endif
    1   0.000095   0.000010             call b:NERDTree.ui.restoreScreenState()
    1              0.000002         else
    1   0.029676   0.000012             call g:NERDTree.Close()
    1              0.000001         endif
    2              0.000002     else
                                    call self.createTabTree(a:dir)
                                endif

FUNCTION  209()
Called 608 times
Total time:   0.020974
 Self time:   0.012921

count  total (s)   self (s)
  608   0.013221   0.005167     let flags = self._flagsForScope(a:scope)
  608              0.002935     if index(flags, a:flag) == -1
  608              0.002949         call add(flags, a:flag)
  608              0.000946     end

FUNCTION  <SNR>129_get_hunks()
Called 1247 times
Total time:   0.151470
 Self time:   0.057015

count  total (s)   self (s)
 1247              0.010202   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000006     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    1              0.000005       let b:source_func = 's:get_hunks_gitgutter'
    1              0.000003     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    1              0.000001   endif
 1247   0.107113   0.012657   return {b:source_func}()

FUNCTION  expand_region#use_select_mode()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000010   return g:expand_region_use_select_mode || index(split(s:saved_selectmode, ','), 'cmd') != -1

FUNCTION  <SNR>82_shellslash()
Called 8 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    8              0.000041   if exists('+shellslash') && !&shellslash
                                return substitute(a:path, '\\', '/', 'g')
                              else
    8              0.000016     return a:path
                              endif

FUNCTION  <SNR>21_SynSet()
Called 2 times
Total time:   0.067514
 Self time:   0.003634

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000032   syn clear
    2              0.000010   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    2              0.000009   let s = expand("<amatch>")
    2              0.000005   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    2              0.000004   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000023     for name in split(s, '\.')
    2   0.067357   0.003477       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000008     endfor
    2              0.000003   endif

FUNCTION  ale#list#SetLists()
Called 4 times
Total time:   0.000235
 Self time:   0.000124

count  total (s)   self (s)
    4              0.000024     if get(g:, 'ale_set_lists_synchronously') == 1
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
    4   0.000174   0.000062         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    4              0.000006     endif

FUNCTION  <SNR>64_extinction()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000017   if get(g:, 'startify_session_persistence') && exists('v:this_session') && filewritable(v:this_session)
                                call startify#session_write(fnameescape(v:this_session))
                              endif

FUNCTION  ale#util#InSandbox()
Called 906 times
Total time:   0.022157
 Self time:   0.022157

count  total (s)   self (s)
  906              0.003625     try
  906              0.005230         function! s:SandboxCheck() abort
                                    endfunction
  906              0.002622     catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
  906              0.001531     return 0

FUNCTION  airline#parts#crypt()
Called 1247 times
Total time:   0.023840
 Self time:   0.023840

count  total (s)   self (s)
 1247              0.022189   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  210()
Called 2956 times
Total time:   0.021740
 Self time:   0.021740

count  total (s)   self (s)
 2956              0.018862     let self._flags[a:scope] = []

FUNCTION  211()
Called 2086 times
Total time:   0.028027
 Self time:   0.028027

count  total (s)   self (s)
 2086              0.010788     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
                                endif
 2086              0.006969     return self._flags[a:scope]

FUNCTION  212()
Called 3 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    3              0.000025     let newObj = copy(self)
    3              0.000015     let newObj._flags = {}
    3              0.000006     return newObj

FUNCTION  214()
Called 1536 times
Total time:   0.060230
 Self time:   0.060230

count  total (s)   self (s)
 1536              0.005246     let flagstring = ""
 4608              0.013813     for i in values(self._flags)
 3072              0.014733         let flagstring .= join(i)
 3072              0.004984     endfor
                            
 1536              0.005393     if len(flagstring) == 0
  960              0.001640         return ""
                                endif
                            
  576              0.001691     return '[' . flagstring . ']'

FUNCTION  217()
Called 1 time
Total time:   0.029664
 Self time:   0.000270

count  total (s)   self (s)
    1   0.000085   0.000007     if !s:NERDTree.IsOpen()
                                    return
                                endif
                            
    1              0.000004     if winnr("$") != 1
    1   0.000073   0.000008         if winnr() == s:NERDTree.GetWinNum()
                                        call nerdtree#exec("wincmd p")
                                        let bufnr = bufnr("")
                                        call nerdtree#exec("wincmd p")
                                    else
    1              0.000005             let bufnr = bufnr("")
    1              0.000002         endif
                            
    1   0.015422   0.000018         call nerdtree#exec(s:NERDTree.GetWinNum() . " wincmd w")
    1   0.013988   0.000187         close
    1   0.000059   0.000012         call nerdtree#exec(bufwinnr(bufnr) . " wincmd w")
    1              0.000001     else
                                    close
                                endif

FUNCTION  218()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005     if g:NERDTreeQuitOnOpen && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
                                endif

FUNCTION  278()
Called 39 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
   39              0.000259   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>130_format_name()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004     return a:name

FUNCTION  <SNR>68_can_diffoff()
Called 10 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   10              0.000122   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#extensions#branch#head()
Called 1247 times
Total time:   2.913828
 Self time:   0.049614

count  total (s)   self (s)
 1247              0.007274   if !exists('b:buffer_vcs_config')
    1   0.000067   0.000016     call s:init_buffer()
    1              0.000002   endif
                            
 1247   0.680177   0.009615   call s:update_branch()
 1247   2.203158   0.009721   call s:update_untracked()
                            
 1247              0.008336   if exists('b:airline_head') && !empty(b:airline_head)
 1246              0.003384     return b:airline_head
                              endif
                            
    1              0.000004   let b:airline_head = ''
    1              0.000009   let l:vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    1              0.000003   let l:heads = {}
    3              0.000007   for vcs in l:vcs_priority
    2              0.000012     if !empty(b:buffer_vcs_config[vcs].branch)
    1              0.000007       let l:heads[vcs] = b:buffer_vcs_config[vcs].branch
    1              0.000002     endif
    2              0.000003   endfor
                            
    2              0.000007   for vcs in keys(l:heads)
    1              0.000004     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    1   0.000034   0.000028     let b:airline_head .= (len(l:heads) > 1 ? s:vcs_config[l:vcs].exe .':' : '') . s:format_name(l:heads[l:vcs])
    1              0.000007     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    1              0.000002   endfor
                            
    1              0.000004   if empty(l:heads)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    1              0.000007   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
    1   0.000146   0.000017   if has_key(l:heads, 'git') && !s:check_in_path()
                                let b:airline_head = ''
                              endif
    1              0.000008   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    1   0.000042   0.000013   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    1              0.000003   return b:airline_head

FUNCTION  airline#extensions#load_theme()
Called 1 time
Total time:   0.007943
 Self time:   0.000016

count  total (s)   self (s)
    1   0.007942   0.000014   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  <SNR>3_reorg_rtp()
Called 1 time
Total time:   0.007656
 Self time:   0.001311

count  total (s)   self (s)
    1              0.000004   if !empty(s:first_rtp)
    1   0.000023   0.000022     execute 'set rtp-='.s:first_rtp
    1   0.000026   0.000025     execute 'set rtp-='.s:last_rtp
    1              0.000001   endif
                            
                              " &rtp is modified from outside
    1              0.000011   if exists('s:prtp') && s:prtp !=# &rtp
    1   0.004910   0.000010     call s:remove_rtp()
    1              0.000004     unlet! s:middle
    1              0.000001   endif
                            
    1              0.000011   let s:middle = get(s:, 'middle', &rtp)
    1   0.001734   0.000293   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
    1              0.000528   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
    1              0.000205   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
    1   0.000118   0.000117   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
    1              0.000008   let s:prtp   = &rtp
                            
    1              0.000003   if !empty(s:first_rtp)
    1   0.000031   0.000030     execute 'set rtp^='.s:first_rtp
    1   0.000028   0.000027     execute 'set rtp+='.s:last_rtp
    1              0.000002   endif

FUNCTION  gitgutter#diff#run_diff()
Called 4 times
Total time:   0.018907
 Self time:   0.000675

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    4              0.000012   let cmd = '('
                            
    4   0.000036   0.000023   let bufnr = gitgutter#utility#bufnr()
    4   0.000116   0.000031   let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
    4              0.000007   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
    4              0.000006     if a:realtime
    1              2.112125       throw 'diff failed'
                                else
    3   0.000133   0.000051       let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
    3              0.000004     endif
    3              0.000003   endif
                            
    3              0.000005   if a:realtime
                                let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
                                let blob_file = s:temp_index
                                let buff_file = s:temp_buffer
                                let extension = gitgutter#utility#extension()
                                if !empty(extension)
                                  let blob_file .= '.'.extension
                                  let buff_file .= '.'.extension
                                endif
                                let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
                                let modified      = getbufvar(bufnr, "&mod")
                                let op_mark_start = getpos("'[")
                                let op_mark_end   = getpos("']")
                            
                                execute 'keepalt noautocmd silent write!' buff_file
                            
                                call setbufvar(bufnr, "&mod", modified)
                                call setpos("'[", op_mark_start)
                                call setpos("']", op_mark_end)
                              endif
                            
    3              0.000011   let cmd .= g:gitgutter_git_executable
    3              0.000006   if s:c_flag
    3              0.000008     let cmd .= ' -c "diff.autorefreshindex=0"'
    3              0.000008     let cmd .= ' -c "diff.noprefix=false"'
    3              0.000003   endif
    3              0.000014   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
    3              0.000005   if a:realtime
                                let cmd .= ' -- '.blob_file.' '.buff_file
                              else
    3   0.000091   0.000036     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
    3              0.000004   endif
                            
    3              0.000009   if !a:preserve_full_diff && s:grep_available
    3   0.000192   0.000025     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
    3              0.000004   endif
                            
    3              0.000010   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
    3              0.000008     let cmd .= ' || exit 0'
    3              0.000003   endif
                            
    3              0.000006   let cmd .= ')'
                            
    3              0.000005   if !tracked
    3              0.000007     let cmd .= ')'
    3              0.000003   endif
                            
    3   0.000125   0.000028   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
    3   0.000074   0.000061   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
    3   0.017777   0.000056     call gitgutter#async#execute(cmd)
    3              0.000014     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  WebDevIconsGetFileFormatSymbol()
Called 1251 times
Total time:   0.081137
 Self time:   0.070091

count  total (s)   self (s)
 1251              0.005084   let fileformat = ''
 1251              0.003095   let bomb = ''
                            
 1251              0.005769   if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
                              endif
                            
 1251              0.003252   if &fileformat ==? 'dos'
                                let fileformat = ''
                              elseif &fileformat ==? 'unix'
 1251   0.019603   0.008557     if s:isDarwin()
                                  let fileformat = ''
                                else
 1251              0.003476       let fileformat = ''
 1251              0.001530     endif
 1251              0.001923   elseif &fileformat ==? 'mac'
                                let fileformat = ''
                              endif
                            
                              " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
                              " actual font patcher)
 1251              0.003613   let artifactFix = "\u00A0"
                            
 1251              0.005591   return bomb . fileformat . artifactFix

FUNCTION  <SNR>182_GetAliasedFiletype()
Called 4 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   16              0.000057     for l:dict in [   get(b:, 'ale_linter_aliases', {}),   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   12              0.000041         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
   12              0.000012     endfor
                            
    4              0.000008     return a:original_filetype

FUNCTION  provider#python#Call()
Called 43 times
Total time:   0.155517
 Self time:   0.155517

count  total (s)   self (s)
   43              0.000209   if s:err != ''
                                return
                              endif
   43              0.000170   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
   43              0.153904   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  220()
Called 38 times
Total time:   0.023494
 Self time:   0.000802

count  total (s)   self (s)
   38   0.003198   0.000225     call g:NERDTree.MustBeOpen()
   38   0.020253   0.000533     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  221()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000010     return exists("b:NERDTree")

FUNCTION  222()
Called 2 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    2              0.000012     if !exists("t:NERDTreeBufName")
                                    return
                                end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
    2              0.000113     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  226()
Called 122 times
Total time:   0.007724
 Self time:   0.007724

count  total (s)   self (s)
  122              0.000726     if exists("t:NERDTreeBufName")
  122              0.006798         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  227()
Called 82 times
Total time:   0.006124
 Self time:   0.000788

count  total (s)   self (s)
   82   0.006043   0.000707     return s:NERDTree.GetWinNum() != -1

FUNCTION  229()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return self._type == "window"

FUNCTION  ale#util#BinarySearch()
Called 416 times
Total time:   0.008033
 Self time:   0.008033

count  total (s)   self (s)
  416              0.001468     let l:min = 0
  416              0.002295     let l:max = len(a:loclist) - 1
                            
  416              0.001097     while 1
  416              0.001133         if l:max < l:min
  416              0.000725             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  GitGutterGetHunkSummary()
Called 1246 times
Total time:   0.054346
 Self time:   0.010930

count  total (s)   self (s)
 1246   0.053215   0.009799   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  <SNR>158_changetick()
Called 266 times
Total time:   0.002281
 Self time:   0.002281

count  total (s)   self (s)
                            	" return [b:changedtick , getcurpos()]
                            	" Note: changedtick is triggered when `<c-x><c-u>` is pressed due to vim's
                            	" bug, use curpos as workaround
  266              0.001435 	return getcurpos()

FUNCTION  airline#parts#mode()
Called 1247 times
Total time:   0.053329
 Self time:   0.017570

count  total (s)   self (s)
 1247   0.051855   0.016096   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  237()
Called 32 times
Total time:   0.007739
 Self time:   0.007423

count  total (s)   self (s)
   32   0.000409   0.000245     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let help .= "\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    silent! put =help
                                elseif !self.isMinimal()
                                    let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
                                    silent! put =help
                                endif

FUNCTION  cm#_auto_enable_check()
Called 7 times
Total time:   0.001150
 Self time:   0.000154

count  total (s)   self (s)
    7              0.000043 	if exists('b:cm_enable') && b:cm_enable!=2
    4              0.000007 		return
                            	endif
    3              0.000035 	if (&buftype=='' &&  line2byte(line("$") + 1)<g:cm_buffer_size_limit) 
                            		" 2 for auto enable
    3   0.001023   0.000027 		call cm#enable_for_buffer(2)
    3              0.000004 	else
                            		call cm#disable_for_buffer()
                            	endif

FUNCTION  <SNR>61_CursorHoldUpdate()
Called 16 times
Total time:   6.687205
 Self time:   0.002394

count  total (s)   self (s)
   16              0.000229     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
                                endif
                            
   16   0.001700   0.000233     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
                                " Do not update when a special buffer is selected
   16              0.000133     if !empty(&l:buftype)
    1              0.000001         return
                                endif
                            
   15              0.000102     let l:winnr = winnr()
   15              0.000068     let l:altwinnr = winnr('#')
                            
   15   0.013772   0.000113     call g:NERDTree.CursorToTreeWin()
   15   6.174716   0.000228     call b:NERDTree.root.refreshFlags()
   15   0.495317   0.000119     call NERDTreeRender()
                            
   15              0.000198     exec l:altwinnr . 'wincmd w'
   15              0.000587     exec l:winnr . 'wincmd w'

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 15 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   15              0.000070   unlet! s:current_buffer_list

FUNCTION  ale#engine#SetResults()
Called 4 times
Total time:   0.006600
 Self time:   0.000749

count  total (s)   self (s)
    4   0.000101   0.000042     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    4              0.000010     if g:ale_set_signs
    4   0.003421   0.000048         call ale#sign#SetSigns(a:buffer, a:loclist)
    4              0.000005     endif
                            
    4              0.000014     if g:ale_set_quickfix || g:ale_set_loclist
    4   0.000273   0.000038         call ale#list#SetLists(a:buffer, a:loclist)
    4              0.000004     endif
                            
    4              0.000019     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    4   0.000516   0.000038         call ale#statusline#Update(a:buffer, a:loclist)
    4              0.000007     endif
                            
    4              0.000010     if g:ale_set_highlights
    4   0.000495   0.000042         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    4              0.000005     endif
                            
    4              0.000009     if g:ale_echo_cursor
                                    " Try and echo the warning now.
                                    " This will only do something meaningful if we're in normal mode.
    4   0.000871   0.000026         call ale#cursor#EchoCursorWarning()
    4              0.000006     endif
                            
    4              0.000009     if l:linting_is_done
                                    " Reset the save event marker, used for opening windows, etc.
    4              0.000025         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    4   0.000346   0.000038         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    4   0.000383   0.000283         silent doautocmd User ALELint
    4              0.000010     endif

FUNCTION  <SNR>68_define_commands()
Called 1 time
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
   28              0.000070   for command in s:commands
   27              0.000538     exe 'command! -buffer '.command
   27              0.000050   endfor

FUNCTION  ale#sign#ParseSigns()
Called 4 times
Total time:   0.001705
 Self time:   0.001705

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
    4              0.000018     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    4              0.000012     let l:result = []
    4              0.000014     let l:is_dummy_sign_set = 0
                            
   29              0.000071     for l:line in a:line_list
   25              0.000881         let l:match = matchlist(l:line, l:pattern)
                            
   25              0.000120         if len(l:match) > 0
    4              0.000019             if l:match[3] is# 'ALEDummySign'
    4              0.000014                 let l:is_dummy_sign_set = 1
    4              0.000005             else
                                            call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
                                        endif
    4              0.000004         endif
   25              0.000040     endfor
                            
    4              0.000018     return [l:is_dummy_sign_set, l:result]

FUNCTION  230()
Called 38 times
Total time:   0.002973
 Self time:   0.000493

count  total (s)   self (s)
   38   0.002735   0.000256     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif

FUNCTION  232()
Called 3616 times
Total time:   0.045519
 Self time:   0.045519

count  total (s)   self (s)
 3616              0.019134     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
 3616              0.008410     return s:NERDTree._PathFilters

FUNCTION  235()
Called 32 times
Total time:   1.049634
 Self time:   0.000284

count  total (s)   self (s)
   32   1.049599   0.000249     call self.ui.render()

FUNCTION  239()
Called 1 time
Total time:   0.006301
 Self time:   0.001537

count  total (s)   self (s)
    1              0.000009     let line = getline(a:ln)
                            
    1   0.000052   0.000013     let rootLine = self.getRootLineNum()
                            
                                "check to see if we have the root node
    1              0.000004     if a:ln == rootLine
                                    return self.nerdtree.root.path
                                endif
                            
    1   0.000017   0.000012     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
    1   0.000093   0.000013     let indent = self._indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
    1   0.000178   0.000015     let curFile = self._stripMarkup(line, 0)
                            
    1              0.000003     let wasdir = 0
    1              0.000005     if curFile =~# '/$'
                                    let wasdir = 1
                                    let curFile = substitute(curFile, '/\?$', '/', "")
                                endif
                            
    1              0.000003     let dir = ""
    1              0.000003     let lnum = a:ln
   20              0.000052     while lnum > 0
   20              0.000081         let lnum = lnum - 1
   20              0.000102         let curLine = getline(lnum)
   20   0.003214   0.000204         let curLineStripped = self._stripMarkup(curLine, 1)
                            
                                    "have we reached the top of the tree?
   20              0.000065         if lnum == rootLine
    1   0.000113   0.000012             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    1              0.000001             break
                                    endif
   19              0.000127         if curLineStripped =~# '/$'
   17   0.001098   0.000181             let lpindent = self._indentLevelFor(curLine)
   17              0.000061             if lpindent < indent
    2              0.000008                 let indent = indent - 1
                            
    2              0.000022                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
    2              0.000007                 continue
                                        endif
   15              0.000019         endif
   17              0.000028     endwhile
    1              0.000005     let curFile = self.nerdtree.root.path.drive . dir . curFile
    1   0.000460   0.000009     let toReturn = g:NERDTreePath.New(curFile)
    1              0.000002     return toReturn

FUNCTION  <SNR>68_repo_git_chomp()
Called 6 times
Total time:   1.930886
 Self time:   1.929806

count  total (s)   self (s)
    6   0.000442   0.000114   let git = g:fugitive_git_executable . ' --git-dir='.s:shellesc(self.git_dir)
    6   0.000674   0.000280   let output = git.join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')
    6   1.929740   1.929383   return s:sub(system(output),'\n$','')

FUNCTION  <SNR>185_BuildSignMap()
Called 4 times
Total time:   0.000271
 Self time:   0.000271

count  total (s)   self (s)
    4              0.000015     let l:sign_map = {}
    4              0.000016     let l:sign_offset = g:ale_sign_offset
                            
    4              0.000015     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_map[l:line] = {   'current_id': l:sign_id,   'current_name': l:name,   'new_id': 0,   'new_name': '',   'items': [],}
                            
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                                endfor
                            
    4              0.000011     for l:group in a:grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id': 0,   'current_name': '',   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    if l:sign_info.current_name isnot# l:sign_info.new_name
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    else
                                        let l:sign_info.new_id = l:sign_info.current_id
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
    4              0.000010     return l:sign_map

FUNCTION  gitgutter#async#execute()
Called 3 times
Total time:   0.017721
 Self time:   0.017454

count  total (s)   self (s)
    3   0.000027   0.000019   let bufnr = gitgutter#utility#bufnr()
                            
    3              0.000020   if has('nvim')
    3              0.000006     if has('unix')
    3              0.000013       let command = ["sh", "-c", a:cmd]
    3              0.000006     elseif has('win32')
                                  let command = ["cmd.exe", "/c", a:cmd]
                                else
                                  throw 'unknown os'
                                endif
                                " Make the job use a shell while avoiding (un)quoting problems.
    3              0.017026     let job_id = jobstart(command, { 'buffer':    bufnr, 'on_stdout': function('gitgutter#async#handle_diff_job_nvim'), 'on_stderr': function('gitgutter#async#handle_diff_job_nvim'), 'on_exit':   function('gitgutter#async#handle_diff_job_nvim') })
    3   0.000364   0.000159     call gitgutter#debug#log('[nvim job: '.job_id.', buffer: '.bufnr.'] '.a:cmd)
    3              0.000008     if job_id < 1
                                  throw 'diff failed'
                                endif
                            
                                " Note that when `cmd` doesn't produce any output, i.e. the diff is empty,
                                " the `stdout` event is not fired on the job handler.  Therefore we keep
                                " track of the jobs ourselves so we can spot empty diffs.
    3   0.000092   0.000039     call s:job_started(job_id)
                            
    3              0.000003   else
                                " Make the job use a shell.
                                "
                                " Pass a handler for stdout but not for stderr so that errors are
                                " ignored (and thus signs are not updated; this assumes that an error
                                " only occurs when a file is not tracked by git).
                            
                                if has('unix')
                                  let command = ["sh", "-c", a:cmd]
                                elseif has('win32')
                                  let command = "cmd.exe /c ".a:cmd
                                else
                                  throw 'unknown os'
                                endif
                            
                                let job = job_start(command, { 'out_cb':   'gitgutter#async#handle_diff_job_vim', 'close_cb': 'gitgutter#async#handle_diff_job_vim_close' })
                                call gitgutter#debug#log('[vim job: '.string(job_info(job)).', buffer: '.bufnr.'] '.a:cmd)
                            
                                call s:job_started(s:channel_id(job_getchannel(job)), bufnr)
                              endif

FUNCTION  airline#extensions#wordcount#apply()
Called 14 times
Total time:   0.000533
 Self time:   0.000533

count  total (s)   self (s)
   14              0.000436   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  airline#highlighter#add_separator()
Called 161 times
Total time:   0.139221
 Self time:   0.003677

count  total (s)   self (s)
  161              0.001511   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  161   0.137560   0.002016   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  241()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000005     let rootLine = 1
    1              0.000022     while getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
                                endwhile
    1              0.000003     return rootLine

FUNCTION  242()
Called 32 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
   32              0.000102     return self._showBookmarks

FUNCTION  243()
Called 3616 times
Total time:   0.013005
 Self time:   0.013005

count  total (s)   self (s)
 3616              0.010252     return self._showFiles

FUNCTION  244()
Called 32 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   32              0.000117     return self._showHelp

FUNCTION  245()
Called 3616 times
Total time:   0.013316
 Self time:   0.013316

count  total (s)   self (s)
 3616              0.010439     return self._showHidden

FUNCTION  246()
Called 18 times
Total time:   0.000996
 Self time:   0.000925

count  total (s)   self (s)
                                "have to do this work around because match() returns bytes, not chars
   18              0.000314     let numLeadBytes = match(a:line, '\M\[^ '.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']')
                                " The next line is a backward-compatible workaround for strchars(a:line(0:numLeadBytes-1]). strchars() is in 7.3+
   18              0.000359     let leadChars = len(split(a:line[0:numLeadBytes-1], '\zs'))
                            
   18   0.000248   0.000177     return leadChars / s:UI.IndentWid()

FUNCTION  247()
Called 18 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   18              0.000051     return 2

FUNCTION  248()
Called 3616 times
Total time:   0.015081
 Self time:   0.015081

count  total (s)   self (s)
 3616              0.012158     return self._ignoreEnabled == 1

FUNCTION  249()
Called 96 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
   96              0.000308     return g:NERDTreeMinimalUI

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000032   return getbufvar(s:bufnr, "&mod")

FUNCTION  EasyMotion#highlight#InitHL()
Called 7 times
Total time:   0.000800
 Self time:   0.000800

count  total (s)   self (s)
    7              0.000046     let group_default = a:group . 'Default'
                            
                                " Prepare highlighting variables
    7              0.000090     let guihl = printf('guibg=%s guifg=%s gui=%s', a:colors.gui[0], a:colors.gui[1], a:colors.gui[2])
    7              0.000131     let ctermhl = &t_Co == 256 ? printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm256[0], a:colors.cterm256[1], a:colors.cterm256[2]) : printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm[0], a:colors.cterm[1], a:colors.cterm[2])
                            
                                " Create default highlighting group
    7              0.000189     execute printf('hi default %s %s %s', group_default, guihl, ctermhl)
                            
                                " Check if the hl group exists
    7              0.000049     if hlexists(a:group)
    7              0.000162         redir => hlstatus | exec 'silent hi ' . a:group | redir END
                            
                                    " Return if the group isn't cleared
    7              0.000055         if hlstatus !~ 'cleared'
    7              0.000015             return
                                    endif
                                endif
                            
                                " No colors are defined for this group, link to defaults
                                execute printf('hi default link %s %s', a:group, group_default)

FUNCTION  cm#enable_for_buffer()
Called 3 times
Total time:   0.000996
 Self time:   0.000689

count  total (s)   self (s)
                            
    3              0.000018 	if has('nvim')==0
                            		let g:_cm_servername = neovim_rpc#serveraddr()
                            	endif
                            
    3              0.000008 	if s:already_setup == 0
                            		let s:already_setup = 1
                                    call cm#snippet#init()
                            		doautocmd User CmSetup
                            	endif
                            
                            	" remove to avoid conflict: #34
                            	" NCM uses cursorpos to detect changes currently, There's no need to keep
                            	" this mapping.
                            	"
                            	" " Notice: Workaround for neovim's bug. When the popup menu is visible, and
                            	" " no item is selected, an enter key will close the popup menu, change and
                            	" " move nothong, and then trigger TextChangedI and CursorMovedI
                            	" " https://github.com/neovim/neovim/issues/5997
                            	" inoremap <expr> <buffer> <CR> (pumvisible() ? "\<c-y>\<cr>" : "\<CR>")
                            
    3              0.000011 	let b:cm_enable = 1
    3              0.000010 	if len(a:000)
    3              0.000009 		let b:cm_enable = a:1
    3              0.000004 	endif
                            
                            	" TODO this override the global options, any way to fix this?
    3              0.000032 	let &completeopt=g:cm_completeopt
    3              0.000023 	if g:cm_completekeys=="\<Plug>(cm_completefunc)"
                            		set completefunc=cm#_completefunc
                            	endif
    3              0.000013 	if g:cm_completekeys=="\<Plug>(cm_omnifunc)"
                            		set omnifunc=cm#_completefunc
                            	endif
                            
    3              0.000013 	augroup cm
    3              0.000308 		autocmd! * <buffer>
    3              0.000026 		autocmd InsertEnter <buffer> call s:notify_core_channel('cm_insert_enter') | call s:on_insert_enter()
    3              0.000016 		autocmd InsertLeave <buffer> call s:change_tick_stop()
    3              0.000016 		autocmd BufEnter    <buffer> let &completeopt=g:cm_completeopt
                            		" working together with timer, the timer is for detecting changes
                            		" popup menu is visible. TextChangedI will not be triggered when popup
                            		" menu is visible, but TextChangedI is more efficient and faster than
                            		" timer when popup menu is not visible.
    3              0.000016 		autocmd TextChangedI <buffer> call s:check_changes()
    3              0.000004 	augroup END
                            
    3   0.000053   0.000029     call s:start_core_channel()
                            
    3   0.000306   0.000023     call s:check_rtp()

FUNCTION  ale#cursor#EchoCursorWarning()
Called 437 times
Total time:   0.172593
 Self time:   0.012462

count  total (s)   self (s)
  437   0.171528   0.011397     return ale#CallWithCooldown('dont_echo_until', function('s:EchoImpl'), [])

FUNCTION  NERDTreeGetGitStatusPrefix()
Called 1478 times
Total time:   6.927550
 Self time:   0.152084

count  total (s)   self (s)
 1478              0.009408     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
   15              0.000070         let s:GitStatusCacheTime = localtime()
   15   6.193087   0.000201         call g:NERDTreeGitStatusRefresh()
   15              0.000025     endif
 1478   0.262367   0.011857     let l:pathStr = a:path.str()
 1478   0.289501   0.020376     let l:cwd = b:NERDTree.root.path.str() . a:path.Slash()
 1478   0.026570   0.008618     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
                                endif
 1478              0.027118     let l:pathStr = substitute(l:pathStr, fnameescape(l:cwd), '', '')
 1478              0.004784     let l:statusKey = ''
 1478              0.004013     if a:path.isDirectory
  996              0.010210         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
  996              0.001446     else
  482              0.004989         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
  482              0.000698     endif
 1478   0.056676   0.011682     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  <SNR>68_repo()
Called 2512 times
Total time:   0.112029
 Self time:   0.111892

count  total (s)   self (s)
 2512   0.031024   0.030888   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
 2512              0.006462   if dir !=# ''
 2512              0.010140     if has_key(s:repos, dir)
 2512              0.013014       let repo = get(s:repos, dir)
 2512              0.003746     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
 2512              0.025029     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>150_LintOnEnter()
Called 5 times
Total time:   0.000325
 Self time:   0.000105

count  total (s)   self (s)
    5   0.000272   0.000053     if ale#Var(a:buffer, 'enabled')&& g:ale_lint_on_enter&& has_key(b:, 'ale_file_changed')
                                    call remove(b:, 'ale_file_changed')
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif

FUNCTION  <SNR>61_AddHighlighting()
Called 1 time
Total time:   0.000632
 Self time:   0.000475

count  total (s)   self (s)
    1   0.000198   0.000041     let l:synmap = { 'NERDTreeGitStatusModified'    : s:NERDTreeGetIndicator('Modified'), 'NERDTreeGitStatusStaged'      : s:NERDTreeGetIndicator('Staged'), 'NERDTreeGitStatusUntracked'   : s:NERDTreeGetIndicator('Untracked'), 'NERDTreeGitStatusRenamed'     : s:NERDTreeGetIndicator('Renamed'), 'NERDTreeGitStatusIgnored'     : s:NERDTreeGetIndicator('Ignored'), 'NERDTreeGitStatusDirDirty'    : s:NERDTreeGetIndicator('Dirty'), 'NERDTreeGitStatusDirClean'    : s:NERDTreeGetIndicator('Clean') }
                            
    8              0.000019     for l:name in keys(l:synmap)
    7              0.000249         exec 'syn match ' . l:name . ' #' . escape(l:synmap[l:name], '~') . '# containedin=NERDTreeFlags'
    7              0.000010     endfor
                            
    1              0.000021     hi def link NERDTreeGitStatusModified Special
    1              0.000017     hi def link NERDTreeGitStatusStaged Function
    1              0.000018     hi def link NERDTreeGitStatusRenamed Title
    1              0.000017     hi def link NERDTreeGitStatusUnmerged Label
    1              0.000017     hi def link NERDTreeGitStatusUntracked Comment
    1              0.000017     hi def link NERDTreeGitStatusDirDirty Tag
    1              0.000018     hi def link NERDTreeGitStatusDirClean DiffAdd
                                " TODO: use diff color
    1              0.000018     hi def link NERDTreeGitStatusIgnored DiffAdd

FUNCTION  <SNR>130_update_untracked_in_buffer_config()
Called 1674 times
Total time:   0.042317
 Self time:   0.042317

count  total (s)   self (s)
 1674              0.012373   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  250()
Called 21 times
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
   21              0.000213     return '^\(['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+\)'

FUNCTION  252()
Called 1 time
Total time:   0.000084
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000005     if !has_key(self, '_screenState')
                                    return
                                endif
    1              0.000009     exec("silent vertical resize " . self._screenState['oldWindowSize'])
                            
    1              0.000004     let old_scrolloff=&scrolloff
    1   0.000006   0.000005     let &scrolloff=0
    1              0.000007     call cursor(self._screenState['oldTopLine'], 0)
    1              0.000034     normal! zt
    1              0.000007     call setpos(".", self._screenState['oldPos'])
    1   0.000007   0.000006     let &scrolloff=old_scrolloff

FUNCTION  253()
Called 1 time
Total time:   0.000237
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000004     let win = winnr()
    1   0.000168   0.000005     call g:NERDTree.CursorToTreeWin()
    1              0.000008     let self._screenState = {}
    1              0.000005     let self._screenState['oldPos'] = getpos(".")
    1              0.000006     let self._screenState['oldTopLine'] = line("w0")
    1              0.000004     let self._screenState['oldWindowSize']= winwidth("")
    1   0.000040   0.000007     call nerdtree#exec(win . "wincmd w")

FUNCTION  255()
Called 21 times
Total time:   0.003173
 Self time:   0.002937

count  total (s)   self (s)
   21              0.000096     let line = a:line
                                "remove the tree parts and the leading space
   21   0.000749   0.000513     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                "strip off any read only flag
   21              0.000286     let line = substitute (line, ' \['.g:NERDTreeGlyphReadOnly.'\]', "","")
                            
                                "strip off any bookmark flags
   21              0.000198     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
   21              0.000189     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                "strip off any generic flags
   21              0.000205     let line = substitute (line, '\[[^]]*\]', "","")
                            
   21              0.000073     let wasdir = 0
   21              0.000132     if line =~# '/$'
   18              0.000065         let wasdir = 1
   18              0.000028     endif
   21              0.000176     let line = substitute (line,' -> .*',"","") " remove link to
   21              0.000067     if wasdir ==# 1
   18              0.000215         let line = substitute (line, '/\?$', '/', "")
   18              0.000038     endif
                            
   21              0.000063     if a:removeLeadingSpaces
   20              0.000222         let line = substitute (line, '^ *', '', '')
   20              0.000039     endif
                            
   21              0.000049     return line

FUNCTION  256()
Called 32 times
Total time:   1.049350
 Self time:   0.011951

count  total (s)   self (s)
   32              0.000435     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
   32              0.000177     let curLine = line(".")
   32              0.000134     let curCol = col(".")
   32              0.000191     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
   32              0.002483     silent 1,$delete _
                            
   32   0.008080   0.000341     call self._dumpHelp()
                            
                                "delete the blank line before the help and add one after it
   32   0.000304   0.000182     if !self.isMinimal()
                                    call setline(line(".")+1, "")
                                    call cursor(line(".")+1, col("."))
                                endif
                            
   32   0.000331   0.000199     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
   32   0.000282   0.000164     if !self.isMinimal()
                                    call setline(line(".")+1, s:UI.UpDirLine())
                                    call cursor(line(".")+1, col("."))
                                endif
                            
                                "draw the header line
   32   0.004510   0.000447     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   32              0.000374     call setline(line(".")+1, header)
   32              0.000237     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
   32   1.027281   0.002055     silent put =self.nerdtree.root.renderToString()
                            
                                "delete the blank line at the top of the buffer
   32              0.000747     silent 1,1delete _
                            
                                "restore the view
   32              0.000243     let old_scrolloff=&scrolloff
   32              0.000432     let &scrolloff=0
   32              0.000203     call cursor(topLine, 1)
   32              0.000942     normal! zt
   32              0.000186     call cursor(curLine, curCol)
   32              0.000233     let &scrolloff = old_scrolloff
                            
   32              0.000250     setlocal nomodifiable

FUNCTION  <SNR>177_CreateCountDict()
Called 828 times
Total time:   0.009179
 Self time:   0.009179

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
  828              0.007051     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  gitgutter#hunk#reset()
Called 23 times
Total time:   0.002072
 Self time:   0.000517

count  total (s)   self (s)
   23   0.000986   0.000297   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', [])
   23   0.001031   0.000165   call s:reset_summary()

FUNCTION  ale#highlight#SetHighlights()
Called 4 times
Total time:   0.000453
 Self time:   0.000126

count  total (s)   self (s)
    4              0.000040     let l:new_list = g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    4              0.000038     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    4   0.000357   0.000030     call ale#highlight#UpdateHighlights()

FUNCTION  gitgutter#utility#is_file_buffer()
Called 23 times
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
   23              0.000191   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  <SNR>81_shellslash()
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000015   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
    2              0.000004     return a:path
                              endif

FUNCTION  <SNR>82_find_root()
Called 2 times
Total time:   0.001222
 Self time:   0.001117

count  total (s)   self (s)
    2   0.000090   0.000060   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
    8              0.000040   for p in [$GEM_HOME] + split($GEM_PATH,':')
    6   0.000152   0.000076     if p !=# '' && s:shellslash(p.'/gems/') ==# (root)[0 : strlen(p)+5]
                                  return simplify(s:shellslash(p.'/gems/')).matchstr(root[strlen(p)+6:-1],'[^\\/]*')
                                endif
    6              0.000009   endfor
    2              0.000006   let previous = ''
   16              0.000061   while root !=# previous && root !=# '/'
   14              0.000171     if filereadable(root.'/Rakefile') || (isdirectory(root.'/lib') && filereadable(root.'/Gemfile'))
                                  if filereadable(root.'/config/environment.rb')
                                    return ''
                                  else
                                    return root
                                  endif
                                elseif root =~# '[\/]gems[\/][0-9.]\+[\/]gems[\/][[:alnum:]._-]\+$'
                                  return root
                                endif
   14              0.000046     let previous = root
   14              0.000075     let root = fnamemodify(root, ':h')
   14              0.000025   endwhile
    2              0.000003   return ''

FUNCTION  gitgutter#utility#is_active()
Called 23 times
Total time:   0.001103
 Self time:   0.000415

count  total (s)   self (s)
   23   0.001075   0.000387   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  webdevicons#softRefresh()
Called 1 time
Total time:   0.078880
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000233   0.000015   call s:setSyntax()
    1   0.078645   0.000018   call s:softRefreshNerdTree()

FUNCTION  264()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return '.. (up a dir)'

FUNCTION  265()
Called 1478 times
Total time:   0.033342
 Self time:   0.033342

count  total (s)   self (s)
 1478              0.008090     let newObj = copy(self)
 1478              0.005790     let newObj.nerdtree = a:nerdtree
 1478              0.004709     let newObj.subject = a:subject
 1478              0.004557     let newObj.action = a:action
 1478              0.004269     let newObj.params = a:params
 1478              0.002901     return newObj

FUNCTION  267()
Called 1478 times
Total time:   7.632496
 Self time:   0.079149

count  total (s)   self (s)
 1478   0.049741   0.016399     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
 4434   0.057170   0.018879     for listener in s:Notifier.GetListenersForEvent(a:event)
 2956   7.509891   0.028177         call {listener}(event)
 2956              0.004665     endfor

FUNCTION  268()
Called 1478 times
Total time:   0.018243
 Self time:   0.018243

count  total (s)   self (s)
 1478              0.007600     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
 1478              0.003515     return s:refreshListenersMap

FUNCTION  269()
Called 1478 times
Total time:   0.038290
 Self time:   0.020047

count  total (s)   self (s)
 1478   0.029205   0.010962     let listenersMap = s:Notifier.GetListenersMap()
 1478              0.007461     return get(listenersMap, a:name, [])

FUNCTION  <SNR>41_mergelists()
Called 1 time
Total time:   0.000845
 Self time:   0.000575

count  total (s)   self (s)
    1   0.000279   0.000030 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000460 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000067 	let mrufs = s:mrufs + diskmrufs
    1   0.000036   0.000015 	retu s:chop(mrufs)

FUNCTION  webdevicons#refresh()
Called 1 time
Total time:   0.078900
 Self time:   0.000020

count  total (s)   self (s)
    1   0.078899   0.000019   call webdevicons#softRefresh()

FUNCTION  <SNR>158_should_skip()
Called 308 times
Total time:   0.005314
 Self time:   0.005314

count  total (s)   self (s)
  308              0.004799     return !get(b:,'cm_enable',0)  || &paste!=0 || g:_cm_lock || mode() != 'i'

FUNCTION  <SNR>130_update_git_branch()
Called 1247 times
Total time:   0.456269
 Self time:   0.096402

count  total (s)   self (s)
 1247              0.004563   if !s:has_fugitive
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
 1247   0.369175   0.009307   let name = fugitive#head(7)
 1247              0.004229   if empty(name)
                                if has_key(s:git_dirs, a:path)
                                  let s:vcs_config['git'].branch = s:git_dirs[a:path]
                                  return
                                endif
                            
                                let dir = fugitive#extract_git_dir(a:path)
                                if empty(dir)
                                  let name = ''
                                else
                                  try
                                    let line = join(readfile(dir . '/HEAD'))
                                    if strpart(line, 0, 16) == 'ref: refs/heads/'
                                      let name = strpart(line, 16)
                                    else
                                      " raw commit hash
                                      let name = strpart(line, 0, 7)
                                    endif
                                  catch
                                    let name = ''
                                  endtry
                                endif
                              endif
                            
 1247              0.007029   let s:git_dirs[a:path] = name
 1247              0.005712   let s:vcs_config['git'].branch = name

FUNCTION  fugitive#buffer()
Called 1 time
Total time:   0.000071
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000070   0.000011   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  provider#clipboard#Call()
Called 8 times
Total time:   0.043844
 Self time:   0.000503

count  total (s)   self (s)
    8   0.043826   0.000484   return call(s:clipboard[a:method],a:args,s:clipboard)

FUNCTION  airline#extensions#ctrlp#load_theme()
Called 1 time
Total time:   0.002576
 Self time:   0.000123

count  total (s)   self (s)
    1              0.000005   if exists('a:palette.ctrlp')
                                let theme = a:palette.ctrlp
                              else
    1              0.000007     let s:color_template = has_key(a:palette, s:color_template) ? s:color_template : 'insert'
    1   0.000046   0.000022     let theme = airline#extensions#ctrlp#generate_color_map( a:palette[s:color_template]['airline_c'], a:palette[s:color_template]['airline_b'], a:palette[s:color_template]['airline_a'])
    1              0.000002   endif
    7              0.000015   for key in keys(theme)
    6   0.002482   0.000053     call airline#highlighter#exec(key, theme[key])
    6              0.000007   endfor

FUNCTION  airline#util#shorten()
Called 2495 times
Total time:   0.067285
 Self time:   0.067285

count  total (s)   self (s)
 2495              0.018926   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
 2495              0.005440     return a:text
                              endif

FUNCTION  <SNR>172_job_finished()
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000022   if has_key(s:jobs, a:id)
    3              0.000016     unlet s:jobs[a:id]
    3              0.000006   endif

FUNCTION  <SNR>68_git_command()
Called 11 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   11              0.000093   return get(g:, 'fugitive_git_command', g:fugitive_git_executable)

FUNCTION  279()
Called 24 times
Total time:   0.000575
 Self time:   0.000396

count  total (s)   self (s)
   24              0.000155   let spc = empty(a:contents) ? '' : g:airline_symbols.space
   24   0.000386   0.000207   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  utils#stripTrailingWhitespaces()
Called 2 times
Total time:   0.000374
 Self time:   0.000374

count  total (s)   self (s)
                              " Preparation: save last search, and cursor position.
    2              0.000024   let l:lastSearch = @/
    2              0.000017   let l:line = line('.')
    2              0.000010   let l:col = col('.')
                            
                              " Do the business:
    2              0.000275   execute '%s/\s\+$//e'
                            
                              " Clean up: restore previous search history, and cursor position
    2              0.000011   let @/ = l:lastSearch
    2              0.000015   call cursor(l:line, l:col)

FUNCTION  <SNR>68_buffer_getvar()
Called 9 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    9              0.000069   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>3_trim()
Called 68 times
Total time:   0.000802
 Self time:   0.000802

count  total (s)   self (s)
   68              0.000749   return substitute(a:str, '[\/]\+$', '', '')

FUNCTION  <SNR>61_NERDTreeCacheDirtyDir()
Called 30 times
Total time:   0.004177
 Self time:   0.003483

count  total (s)   self (s)
                                " cache dirty dir
   30   0.001026   0.000332     let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
   30              0.000210     if l:dirtyPath =~# '\.\./.*'
                                    return
                                endif
   30              0.000520     let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
   60              0.001157     while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
   30              0.000314         let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
   30              0.000384         let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
   30              0.000070     endwhile

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 22 times
Total time:   0.005636
 Self time:   0.001117

count  total (s)   self (s)
   22              0.000208   if getbufvar(a:bufnr, '&modified')
   10              0.000142     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   10              0.000015   else
   12              0.000179     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   12              0.000019   endif
                            
   22              0.000069   if !empty(colors)
   12   0.004686   0.000167     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   12              0.000013   endif

FUNCTION  gitgutter#highlight#match_highlight()
Called 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000041   let matches = matchlist(a:highlight, a:pattern)
    2              0.000007   if len(matches) == 0
                                return 'NONE'
                              endif
    2              0.000006   return matches[1]

FUNCTION  airline#init#gui_mode()
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000027   return ((has('nvim') && exists('$NVIM_TUI_ENABLE_TRUE_COLOR') && !exists("+termguicolors")) || has('gui_running') || (has("termtruecolor") && &guicolors == 1) || (has("termguicolors") && &termguicolors == 1)) ? 'gui' : 'cterm'

FUNCTION  53()
Called 8 times
Total time:   0.000190
 Self time:   0.000085

count  total (s)   self (s)
    8   0.000155   0.000049     if !nerdtree#runningWindows()
    8              0.000023         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  282()
Called 39 times
Total time:   0.267683
 Self time:   0.035883

count  total (s)   self (s)
   39              0.000147   let side = 1
   39              0.000086   let line = ''
   39              0.000081   let i = 0
   39              0.000170   let length = len(self._sections)
   39              0.000091   let split = 0
   39              0.000107   let is_empty = 0
   39              0.000091   let prev_group = ''
                            
  288              0.000698   while i < length
  249              0.001103     let section = self._sections[i]
  249              0.000919     let group = section[0]
  249              0.000830     let contents = section[1]
  249              0.000654     let pgroup = prev_group
  249   0.007401   0.002151     let prev_group = s:get_prev_group(self._sections, i)
  249              0.001308     if group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    6              0.000027       let group = 'airline_c'. self._context.bufnr
    6              0.000030     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    6              0.000027       let prev_group = 'airline_c'. self._context.bufnr
    6              0.000008     endif
  249              0.000403     if is_empty
                                  let prev_group = pgroup
                                endif
  249   0.006489   0.002104     let is_empty = s:section_is_empty(self, contents)
                            
  249              0.000455     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
  249              0.000504     if group == ''
                                  let line .= contents
                                elseif group == '|'
   39              0.000076       let side = 0
   39              0.000127       let line .= contents
   39              0.000074       let split = 1
   39              0.000042     else
  210              0.000432       if prev_group == ''
   39              0.000171         let line .= '%#'.group.'#'
   39              0.000069       elseif split
   27              0.000043         if !is_empty
   27   0.024518   0.000300           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   27              0.000041         endif
   27              0.000059         let split = 0
   27              0.000033       else
  144              0.000261         if !is_empty
  144   0.184492   0.001509           let line .= s:get_seperator(self, prev_group, group, side)
  144              0.000227         endif
  144              0.000149       endif
  210   0.017592   0.002627       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  210              0.000317     endif
                            
  249              0.000948     let i = i + 1
  249              0.000425   endwhile
                            
   39              0.000102   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   13              0.000717     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   13              0.000027   endif
   39              0.000089   return line

FUNCTION  airline#extensions#tabline#tabs#invalidate()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   let s:current_bufnr = -1

FUNCTION  airline#extensions#ctrlp#apply()
Called 14 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
   14              0.000157   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  airline#extensions#hunks#get_hunks()
Called 1247 times
Total time:   0.335792
 Self time:   0.184321

count  total (s)   self (s)
 1247              0.007473   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
 1247              0.026033   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty'
                                return b:airline_hunks
                              endif
 1247   0.161123   0.009652   let hunks = s:get_hunks()
 1247              0.003561   let string = ''
 1247              0.004075   if !empty(hunks)
 4984              0.011929     for i in [0, 1, 2]
 3738              0.021293       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
 3738              0.036930         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 3738              0.006589       endif
 3738              0.005332     endfor
 1246              0.001721   endif
 1247              0.004725   let b:airline_hunks = string
 1247              0.004504   let b:airline_changenr = b:changedtick
 1247              0.005324   let s:airline_winwidth = winwidth(0)
 1247              0.002954   return string

FUNCTION  <SNR>132_ws_refresh()
Called 18 times
Total time:   0.000301
 Self time:   0.000301

count  total (s)   self (s)
   18              0.000116   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   12              0.000025     return
                              endif
    6              0.000031   unlet! b:airline_whitespace_check
    6              0.000029   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    6              0.000027   let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#extensions#ctrlp#generate_color_map()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000021   return { 'CtrlPdark'   : a:dark, 'CtrlPlight'  : a:light, 'CtrlPwhite'  : a:white, 'CtrlParrow1' : [ a:light[1] , a:white[1] , a:light[3] , a:white[3] , ''     ] , 'CtrlParrow2' : [ a:white[1] , a:light[1] , a:white[3] , a:light[3] , ''     ] , 'CtrlParrow3' : [ a:light[1] , a:dark[1]  , a:light[3] , a:dark[3]  , ''     ] , }

FUNCTION  <SNR>145_get_transitioned_seperator()
Called 161 times
Total time:   0.144571
 Self time:   0.005351

count  total (s)   self (s)
  161              0.000532   let line = ''
  161   0.140625   0.001404   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  161              0.001107   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  161              0.001051   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  161              0.000626   let line .= '%#'.a:group.'#'
  161              0.000314   return line

FUNCTION  gitgutter#utility#getbufvar()
Called 1251 times
Total time:   0.026739
 Self time:   0.026739

count  total (s)   self (s)
 1251              0.012841   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
 1251              0.006777   if has_key(dict, a:varname)
 1246              0.004611     return dict[a:varname]
                              else
    5              0.000007     if a:0
    4              0.000006       return a:1
                                endif
    1              0.000001   endif

FUNCTION  <SNR>68_buffer_sha1()
Called 1 time
Total time:   0.337792
 Self time:   0.000079

count  total (s)   self (s)
    1   0.000090   0.000032   if self.spec() =~ '^fugitive://' || self.spec() =~ '\.git/refs/\|\.git/.*HEAD$'
    1   0.337700   0.000045     return self.repo().rev_parse(self.rev())
                              else
                                return ''
                              endif

FUNCTION  <SNR>125_sync_active_winnr()
Called 452 times
Total time:   0.008375
 Self time:   0.008375

count  total (s)   self (s)
  452              0.004928   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  ale#sign#GetSignCommands()
Called 4 times
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
    4              0.000017     let l:command_list = []
    4              0.000017     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    4              0.000021     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
    4              0.000019     for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if l:info.new_id isnot l:info.current_id
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
                                    endif
                                endfor
                            
                                " Remove signs without new IDs.
    4              0.000017     for l:info in values(a:sign_map)
                                    if l:info.current_id && l:info.current_id isnot l:info.new_id
                                        call add(l:command_list, 'sign unplace '   . (l:info.current_id)   . ' buffer=' . a:buffer)
                                    endif
                                endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    4              0.000016     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
    4              0.000010     return l:command_list

FUNCTION  <SNR>129_is_branch_empty()
Called 1247 times
Total time:   0.013720
 Self time:   0.013720

count  total (s)   self (s)
 1247              0.012321   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>68_buffer_setvar()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000014   return setbufvar(self['#'],a:var,a:value)

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 468 times
Total time:   0.191761
 Self time:   0.016450

count  total (s)   self (s)
  468   0.190361   0.015049     return ale#CallWithCooldown(   'dont_echo_with_delay_until',   function('s:EchoWithDelayImpl'),   [],)

FUNCTION  NERDTreeGitStatusRefreshListener()
Called 1478 times
Total time:   7.002905
 Self time:   0.059876

count  total (s)   self (s)
 1478              0.008799     if !exists('b:NOT_A_GIT_REPOSITORY')
                                    call g:NERDTreeGitStatusRefresh()
                                endif
 1478              0.006012     let l:path = a:event.subject
 1478   6.939989   0.012438     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
 1478   0.022203   0.011043     call l:path.flagSet.clearFlags('git')
 1478              0.004264     if l:flag !=# ''
  126   0.005268   0.000949         call l:path.flagSet.addFlag('git', l:flag)
  126              0.000140     endif

FUNCTION  <SNR>68_buffer_spec()
Called 3 times
Total time:   0.000176
 Self time:   0.000078

count  total (s)   self (s)
    3              0.000024     let bufname = bufname(self['#'])
    3   0.000147   0.000049     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  ale#highlight#RemoveHighlights()
Called 11 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
   12              0.000061     for l:match in getmatches()
    1              0.000007         if l:match.group =~# '^ALE'
                                        call matchdelete(l:match.id)
                                    endif
    1              0.000001     endfor

FUNCTION  ale#sign#ReadSigns()
Called 4 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
    4              0.000025     redir => l:output
    4              0.000129        silent execute 'sign place buffer=' . a:buffer
    4              0.000021     redir end
                            
    4              0.000053     return split(l:output, "\n")

FUNCTION  <SNR>70_invoke_funcrefs()
Called 27 times
Total time:   0.201095
 Self time:   0.001723

count  total (s)   self (s)
   27   0.001161   0.000229   let builder = airline#builder#new(a:context)
   27   0.036301   0.000403   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   27              0.000060   if err == 1
   27   0.162805   0.000263     let a:context.line = builder.build()
   27              0.000252     let s:contexts[a:context.winnr] = a:context
   27              0.000393     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   27              0.000047   endif

FUNCTION  airline#extensions#tabline#tabs#map_keys()
Called 64 times
Total time:   0.000672
 Self time:   0.000672

count  total (s)   self (s)
   64              0.000398   if exists("s:airline_tabline_map_key")
   64              0.000109     return
                              endif
                              noremap <silent> <Plug>AirlineSelectTab1 :1tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab2 :2tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab3 :3tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab4 :4tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab5 :5tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab6 :6tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab7 :7tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab8 :8tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab9 :9tabn<CR>
                              noremap <silent> <Plug>AirlineSelectPrevTab gT
                              " tabn {count} goes to count tab does not go {count} tab pages forward!
                              noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>
                              let s:airline_tabline_map_key = 1

FUNCTION  <SNR>158_notify_core_channel()
Called 13 times
Total time:   0.000814
 Self time:   0.000814

count  total (s)   self (s)
                            	" if s:channel_jobid==-1
   13              0.000064 	if g:_cm_channel_id==-1
                            		return -1
                            	endif
                            	" forward arguments
   13              0.000595 	call call(s:rpcnotify,[g:_cm_channel_id, a:event] + a:000 )
   13              0.000044 	return 0

FUNCTION  <SNR>155_EchoWithDelayImpl()
Called 468 times
Total time:   0.133630
 Self time:   0.027323

count  total (s)   self (s)
  468   0.103385   0.005012     if ale#ShouldDoNothing(bufnr(''))
    5              0.000007         return
                                endif
                            
  463   0.011798   0.003864     call s:StopCursorTimer()
                            
  463              0.004025     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  463              0.002198     if l:pos != s:last_pos
  428              0.001765         let s:last_pos = l:pos
  428              0.004213         let s:cursor_timer = timer_start(10, function('ale#cursor#EchoCursorWarning'))
  428              0.000742     endif

FUNCTION  plug#end()
Called 1 time
Total time:   0.067828
 Self time:   0.004694

count  total (s)   self (s)
    1              0.000004   if !exists('g:plugs')
                                return s:err('Call plug#begin() first')
                              endif
                            
    1              0.000003   if exists('#PlugLOD')
    1              0.000002     augroup PlugLOD
    1              0.000126       autocmd!
    1              0.000001     augroup END
    1              0.000018     augroup! PlugLOD
    1              0.000001   endif
    1              0.000005   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
    1              0.000004   if exists('g:did_load_filetypes')
    1   0.001701   0.000534     filetype off
    1              0.000006   endif
   68              0.000102   for name in g:plugs_order
   67              0.000193     if !has_key(g:plugs, name)
                                  continue
                                endif
   67              0.000186     let plug = g:plugs[name]
   67              0.000325     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
   60              0.000161       let s:loaded[name] = 1
   60              0.000117       continue
                                endif
                            
    7              0.000027     if has_key(plug, 'on')
    2              0.000012       let s:triggers[name] = { 'map': [], 'cmd': [] }
    5   0.000050   0.000033       for cmd in s:to_a(plug.on)
    3              0.000019         if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
    3              0.000033           let cmd = substitute(cmd, '!*$', '', '')
    3              0.000019           if exists(':'.cmd) != 2
                                        call s:assoc(lod.cmd, cmd, name)
                                      endif
    3              0.000018           call add(s:triggers[name].cmd, cmd)
    3              0.000004         else
                                      call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
    3              0.000003       endfor
    2              0.000002     endif
                            
    7              0.000019     if has_key(plug, 'for')
    5   0.000067   0.000035       let types = s:to_a(plug.for)
    5              0.000014       if !empty(types)
    5              0.000009         augroup filetypedetect
    5   0.000797   0.000061         call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
    5              0.000008         augroup END
    5              0.000005       endif
   17              0.000028       for type in types
   12   0.000177   0.000083         call s:assoc(lod.ft, type, name)
   12              0.000020       endfor
    5              0.000005     endif
    7              0.000007   endfor
                            
    1              0.000005   for [cmd, names] in items(lod.cmd)
                                execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
                              endfor
                            
    1              0.000003   for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
                              endfor
                            
   10              0.000028   for [ft, names] in items(lod.ft)
    9              0.000016     augroup PlugLOD
    9              0.000143       execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
    9              0.000014     augroup END
    9              0.000009   endfor
                            
    1   0.007672   0.000016   call s:reorg_rtp()
    1   0.030830   0.001419   filetype plugin indent on
    1              0.000006   if has('vim_starting')
                                if has('syntax') && !exists('g:syntax_on')
                                  syntax enable
                                end
                              else
    1   0.024039   0.000016     call s:reload_plugins()
    1              0.000001   endif

FUNCTION  airline#extensions#ale#get_warning()
Called 1247 times
Total time:   0.175196
 Self time:   0.013377

count  total (s)   self (s)
 1247   0.173857   0.012038   return airline#extensions#ale#get('warning')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  990   8.647225   6.977900  164()
 1478   7.807168   0.026604  43()
 1478   7.632496   0.079149  267()
 1478   7.002905   0.059876  NERDTreeGitStatusRefreshListener()
 1478   6.927550   0.152084  NERDTreeGetGitStatusPrefix()
   16   6.687205   0.002394  <SNR>61_CursorHoldUpdate()
   15   6.192886   6.184577  NERDTreeGitStatusRefresh()
    5   4.970165   1.755120  <SNR>68_BufWriteIndexFile()
 1247   2.959185   0.045357  airline#extensions#branch#get_head()
 1247   2.913828   0.049614  airline#extensions#branch#head()
 1247   2.193437   0.173746  <SNR>130_update_untracked()
 1308   2.049419   0.250083  airline#check_mode()
   23   2.031635   0.217269  airline#highlighter#highlight()
    6   1.977464   1.977297  airline#util#system()
    6   1.930886   1.929806  <SNR>68_repo_git_chomp()
 1568   1.833873   1.616970  135()
  482   1.538786   0.005518  132()
 3615   1.485827   0.432307  airline#highlighter#exec()
   16   1.335510   0.001864  <SNR>74_CursorHoldUpdate()
 5713   1.114844   0.331840  airline#highlighter#get_highlight()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  990   8.647225   6.977900  164()
   15   6.192886   6.184577  NERDTreeGitStatusRefresh()
    6   1.977464   1.977297  airline#util#system()
    6   1.930886   1.929806  <SNR>68_repo_git_chomp()
    5   4.970165   1.755120  <SNR>68_BufWriteIndexFile()
 1568   1.833873   1.616970  135()
11426              0.716461  <SNR>141_get_syn()
 1989              0.620259  WebDevIconsGetFileTypeSymbol()
 3615   1.485827   0.432307  airline#highlighter#exec()
 5713   1.114844   0.331840  airline#highlighter#get_highlight()
    1   0.402030   0.302037  <SNR>68_ReplaceCmd()
 3724   0.614998   0.286745  45()
 3616   0.592292   0.264512  32()
 1308   2.049419   0.250083  airline#check_mode()
 1247   0.283190   0.225023  airline#extensions#whitespace#check()
   23   2.031635   0.217269  airline#highlighter#highlight()
 1478   0.478809   0.206554  NERDTreeWebDevIconsRefreshListener()
 3615              0.192203  <SNR>141_CheckDefined()
 1247   0.335792   0.184321  airline#extensions#hunks#get_hunks()
 2494   0.309323   0.183897  airline#extensions#ale#get()

